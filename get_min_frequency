Documentation/ABI/stable/sysfs-bus-firewire:			Binary attribute; an array of host-endian u32.
Documentation/ABI/testing/sysfs-firmware-gsmi:			32bit host-endian type used as part of the
Documentation/DocBook/usb.tmpl:    <para>The only host-side drivers that actually touch hardware
Documentation/RCU/lockdep-splat.txt: #0:  (&shost->scan_mutex){+.+.+.}, at: [<ffffffff8145efca>]
Documentation/devices.txt:		238 = /dev/vhost-net	Host kernel accelerator for virtio net
Documentation/devicetree/bindings/input/tegra-kbc.txt:- nvidia,ghost-filter: enable ghost filtering for this device
Documentation/devicetree/bindings/input/tegra-kbc.txt:	nvidia,ghost-filter;
Documentation/kbuild/makefiles.txt:	Note: The syntax <executable>-y is not permitted for host-programs.
Documentation/kbuild/makefiles.txt:	Kbuild will only build host-programs when they are referenced
Documentation/m68k/kernel-options.txt:Syntax: atascsi=<can_queue>[,<cmd_per_lun>[,<scat-gat>[,<host-id>[,<tagged>]]]]
Documentation/m68k/kernel-options.txt:  <host-id>:
Documentation/parport-lowlevel.txt:Enables the data line drivers, for 8-bit host-to-peripheral
Documentation/powerpc/eeh-pci-error-recovery.txt:   SCSI device resets, SCSI bus resets, and SCSI host-bus-adapter
Documentation/scsi/ChangeLog.1992-1997:	* eata.c: Update to 1.16.  Use wish_block instead of host->block.
Documentation/scsi/ChangeLog.1992-1997:	* scsi.c: If the host->irq field is set, use
Documentation/scsi/ChangeLog.lpfc:	* Set host->unique_id in lpfc_fcp.c.
Documentation/scsi/ChangeLog.lpfc:	* Removed per HBA driver lock.  Driver now uses the host->host_lock
Documentation/scsi/cxgb3i.txt:	  payload into pre-posted final destination host-memory buffers based
Documentation/scsi/ibmmca.txt:   stage confused the driver and resulted in the detection of some ghost-SCSI. 
Documentation/scsi/ibmmca.txt:   After the I/O-address range is assigned, the host-adapter is assigned
Documentation/scsi/scsi_eh.txt: 2. Links scmd->eh_entry to shost->eh_cmd_q
Documentation/scsi/scsi_eh.txt: 3. Sets SHOST_RECOVERY bit in shost->shost_state
Documentation/scsi/scsi_eh.txt: 4. Increments shost->host_failed
Documentation/scsi/scsi_eh.txt: 5. Wakes up SCSI EH thread if shost->host_busy == shost->host_failed
Documentation/scsi/scsi_eh.txt: As can be seen above, once any scmd is added to shost->eh_cmd_q,
Documentation/scsi/scsi_eh.txt:time out and get added to shost->eh_cmd_q.
Documentation/scsi/scsi_eh.txt:becomes equal to the number of failed scmds - i.e. shost->host_busy ==
Documentation/scsi/scsi_eh.txt:shost->host_failed.  This wakes up SCSI EH thread.  So, once woken up,
Documentation/scsi/scsi_eh.txt:are linked on shost->eh_cmd_q.
Documentation/scsi/scsi_eh.txt: 3. Wakes up waiters on shost->host_wait.  This occurs if someone
Documentation/scsi/scsi_eh.txt:	- add scmd to shost->eh_cmd_q
Documentation/scsi/scsi_eh.txt:	- shost->host_failed++
Documentation/scsi/scsi_eh.txt:    LOCKING: shost->host_lock
Documentation/scsi/scsi_eh.txt:    ACTION: move all scmds to EH's local eh_work_q.  shost->eh_cmd_q
Documentation/scsi/scsi_eh.txt:    LOCKING: shost->host_lock (not strictly necessary, just for
Documentation/scsi/scsi_eh.txt:	- shost->host_failed--
Documentation/scsi/scsi_eh.txt:    1. Lock shost->host_lock, splice_init shost->eh_cmd_q into local
Documentation/scsi/scsi_eh.txt:       eh_work_q and unlock host_lock.  Note that shost->eh_cmd_q is
Documentation/scsi/scsi_eh.txt: - shost->host_failed == shost->host_busy
Documentation/scsi/scsi_eh.txt: - shost->host_failed is zero.
Documentation/scsi/scsi_eh.txt: - shost->eh_cmd_q is cleared.
Documentation/scsi/scsi_eh.txt:   grab shost->host_lock.
Documentation/scsi/scsi_mid_low_api.txt: *              -1 - drop back to untagged operation using host->cmd_per_lun
Documentation/sound/alsa/compress_offload.txt:reduction of power consumption compared to host-based
Documentation/usb/gadget_serial.txt:On the host-side system, the gadget serial device looks like a
Documentation/video4linux/soc-camera.txt:from the host, apart from performing host-internal tasks they shall also call
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  needed to get things working (the examples use a host-side IP of
arch/arm/mach-davinci/board-da830-evm.c:	 * host-only mode -- ID pin will float if no cable is connected, so the
arch/arm/mach-footbridge/cats-pci.c:/* cats host-specific stuff */
arch/arm/mach-ixp23xx/pci.c: * Prevent PCI layer from seeing the inbound host-bridge resources
arch/arm/mach-s3c24xx/common-s3c2443.c:		.name		= "usb-bus-host-parent",
arch/arm/plat-iop/pci.c:/* for platforms that might be host-bus-adapters */
arch/c6x/platforms/megamod-pic.c:	struct device_node *np = pic->irqhost->of_node;
arch/c6x/platforms/megamod-pic.c:	pic->irqhost->host_data = pic;
arch/mips/pmc-sierra/msp71xx/msp_usb.c:	 * Use the features key "U", and follow with "H" for host-mode,
arch/powerpc/platforms/cell/spider-pic.c:	if (of_irq_map_one(pic->host->of_node, 0, &oirq) == 0) {
arch/powerpc/platforms/cell/spider-pic.c:	tmp = of_get_property(pic->host->of_node, "#interrupt-cells", NULL);
arch/powerpc/platforms/cell/spider-pic.c:	imap = of_get_property(pic->host->of_node, "interrupt-map", &imaplen);
arch/powerpc/platforms/embedded6xx/flipper-pic.c:	void __iomem *io_base = flipper_irq_host->host_data;
arch/powerpc/platforms/embedded6xx/flipper-pic.c:	void __iomem *io_base = flipper_irq_host->host_data;
arch/powerpc/platforms/embedded6xx/flipper-pic.c:	if (flipper_irq_host && flipper_irq_host->host_data) {
arch/powerpc/platforms/embedded6xx/flipper-pic.c:		io_base = flipper_irq_host->host_data;
arch/powerpc/platforms/embedded6xx/flipper-pic.c:	if (flipper_irq_host && flipper_irq_host->host_data) {
arch/powerpc/platforms/embedded6xx/flipper-pic.c:		io_base = flipper_irq_host->host_data;
arch/powerpc/platforms/embedded6xx/hlwd-pic.c:	void __iomem *io_base = hlwd_irq_host->host_data;
arch/powerpc/platforms/powermac/low_i2c.c:		       name, __kw_state_names[host->state], isr); \
arch/powerpc/platforms/powermac/low_i2c.c:	return readb(host->base + (((unsigned int)reg) << host->bsteps));
arch/powerpc/platforms/powermac/low_i2c.c:	writeb(val, host->base + (((unsigned)reg) << host->bsteps));
arch/powerpc/platforms/powermac/low_i2c.c:		if (host->polled) {
arch/powerpc/platforms/powermac/low_i2c.c:	host->state = state_stop;
arch/powerpc/platforms/powermac/low_i2c.c:	host->result = result;
arch/powerpc/platforms/powermac/low_i2c.c:		__kw_state_names[host->state], isr);
arch/powerpc/platforms/powermac/low_i2c.c:	if (host->state == state_idle) {
arch/powerpc/platforms/powermac/low_i2c.c:		if (host->state != state_stop) {
arch/powerpc/platforms/powermac/low_i2c.c:		host->state = state_idle;
arch/powerpc/platforms/powermac/low_i2c.c:		if (!host->polled)
arch/powerpc/platforms/powermac/low_i2c.c:			complete(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:		if (host->state != state_addr) {
arch/powerpc/platforms/powermac/low_i2c.c:			host->result = -ENXIO;
arch/powerpc/platforms/powermac/low_i2c.c:			host->state = state_stop;
arch/powerpc/platforms/powermac/low_i2c.c:			if (host->len == 0)
arch/powerpc/platforms/powermac/low_i2c.c:			else if (host->rw) {
arch/powerpc/platforms/powermac/low_i2c.c:				host->state = state_read;
arch/powerpc/platforms/powermac/low_i2c.c:				if (host->len > 1)
arch/powerpc/platforms/powermac/low_i2c.c:				host->state = state_write;
arch/powerpc/platforms/powermac/low_i2c.c:				kw_write_reg(reg_data, *(host->data++));
arch/powerpc/platforms/powermac/low_i2c.c:				host->len--;
arch/powerpc/platforms/powermac/low_i2c.c:		if (host->state == state_read) {
arch/powerpc/platforms/powermac/low_i2c.c:			*(host->data++) = kw_read_reg(reg_data);
arch/powerpc/platforms/powermac/low_i2c.c:			host->len--;
arch/powerpc/platforms/powermac/low_i2c.c:			if (host->len == 0)
arch/powerpc/platforms/powermac/low_i2c.c:				host->state = state_stop;
arch/powerpc/platforms/powermac/low_i2c.c:			else if (host->len == 1)
arch/powerpc/platforms/powermac/low_i2c.c:		} else if (host->state == state_write) {
arch/powerpc/platforms/powermac/low_i2c.c:				host->result = -EFBIG;
arch/powerpc/platforms/powermac/low_i2c.c:				host->state = state_stop;
arch/powerpc/platforms/powermac/low_i2c.c:			} else if (host->len) {
arch/powerpc/platforms/powermac/low_i2c.c:				kw_write_reg(reg_data, *(host->data++));
arch/powerpc/platforms/powermac/low_i2c.c:				host->len--;
arch/powerpc/platforms/powermac/low_i2c.c:			if (host->state != state_stop)
arch/powerpc/platforms/powermac/low_i2c.c:		if (host->state != state_stop) {
arch/powerpc/platforms/powermac/low_i2c.c:			host->result = -EIO;
arch/powerpc/platforms/powermac/low_i2c.c:		host->state = state_idle;
arch/powerpc/platforms/powermac/low_i2c.c:		if (!host->polled)
arch/powerpc/platforms/powermac/low_i2c.c:			complete(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:	spin_lock_irqsave(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:	del_timer(&host->timeout_timer);
arch/powerpc/platforms/powermac/low_i2c.c:	if (host->state != state_idle) {
arch/powerpc/platforms/powermac/low_i2c.c:		host->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;
arch/powerpc/platforms/powermac/low_i2c.c:		add_timer(&host->timeout_timer);
arch/powerpc/platforms/powermac/low_i2c.c:	spin_unlock_irqrestore(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:	spin_lock_irqsave(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:	if (timer_pending(&host->timeout_timer))
arch/powerpc/platforms/powermac/low_i2c.c:	if (host->state != state_idle) {
arch/powerpc/platforms/powermac/low_i2c.c:		host->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;
arch/powerpc/platforms/powermac/low_i2c.c:		add_timer(&host->timeout_timer);
arch/powerpc/platforms/powermac/low_i2c.c:	spin_unlock_irqrestore(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_lock(&host->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_unlock(&host->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	u8 mode_reg = host->speed;
arch/powerpc/platforms/powermac/low_i2c.c:	int use_irq = host->irq != NO_IRQ && !bus->polled;
arch/powerpc/platforms/powermac/low_i2c.c:	host->data = data;
arch/powerpc/platforms/powermac/low_i2c.c:	host->len = len;
arch/powerpc/platforms/powermac/low_i2c.c:	host->state = state_addr;
arch/powerpc/platforms/powermac/low_i2c.c:	host->result = 0;
arch/powerpc/platforms/powermac/low_i2c.c:	host->rw = (addrdir & 1);
arch/powerpc/platforms/powermac/low_i2c.c:	host->polled = bus->polled;
arch/powerpc/platforms/powermac/low_i2c.c:		INIT_COMPLETION(host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:		host->timeout_timer.expires = jiffies + KW_POLL_TIMEOUT;
arch/powerpc/platforms/powermac/low_i2c.c:		add_timer(&host->timeout_timer);
arch/powerpc/platforms/powermac/low_i2c.c:		wait_for_completion(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:		while(host->state != state_idle) {
arch/powerpc/platforms/powermac/low_i2c.c:			spin_lock_irqsave(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:			spin_unlock_irqrestore(&host->lock, flags);
arch/powerpc/platforms/powermac/low_i2c.c:	return host->result;
arch/powerpc/platforms/powermac/low_i2c.c:	mutex_init(&host->mutex);
arch/powerpc/platforms/powermac/low_i2c.c:	init_completion(&host->complete);
arch/powerpc/platforms/powermac/low_i2c.c:	spin_lock_init(&host->lock);
arch/powerpc/platforms/powermac/low_i2c.c:	init_timer(&host->timeout_timer);
arch/powerpc/platforms/powermac/low_i2c.c:	host->timeout_timer.function = kw_i2c_timeout;
arch/powerpc/platforms/powermac/low_i2c.c:	host->timeout_timer.data = (unsigned long)host;
arch/powerpc/platforms/powermac/low_i2c.c:	for (host->bsteps = 0; (steps & 0x01) == 0; host->bsteps++)
arch/powerpc/platforms/powermac/low_i2c.c:	host->speed = KW_I2C_MODE_25KHZ;
arch/powerpc/platforms/powermac/low_i2c.c:		host->speed = KW_I2C_MODE_100KHZ;
arch/powerpc/platforms/powermac/low_i2c.c:		host->speed = KW_I2C_MODE_50KHZ;
arch/powerpc/platforms/powermac/low_i2c.c:		host->speed = KW_I2C_MODE_25KHZ;
arch/powerpc/platforms/powermac/low_i2c.c:	host->irq = irq_of_parse_and_map(np, 0);
arch/powerpc/platforms/powermac/low_i2c.c:	if (host->irq == NO_IRQ)
arch/powerpc/platforms/powermac/low_i2c.c:	host->base = ioremap((*addrp), 0x1000);
arch/powerpc/platforms/powermac/low_i2c.c:	if (host->base == NULL) {
arch/powerpc/platforms/powermac/low_i2c.c:	if (request_irq(host->irq, kw_i2c_irq, IRQF_NO_SUSPEND,
arch/powerpc/platforms/powermac/low_i2c.c:		host->irq = NO_IRQ;
arch/powerpc/platforms/powermac/low_i2c.c:	       *addrp, host->irq, np->full_name);
arch/powerpc/platforms/powermac/pci.c:		struct resource *r = &host->mem_resources[i];
arch/powerpc/platforms/wsp/opb_pic.c:	opb = host->host_data;
arch/powerpc/sysdev/fsl_msi.c:			      msi_data->irqhost->of_node);
arch/powerpc/sysdev/fsl_msi.c:		/* chip_data is msi_data via host->hostdata in host->map() */
arch/powerpc/sysdev/mpic_msi.c:	const struct irq_domain_ops *ops = mpic->irqhost->ops;
arch/powerpc/sysdev/mpic_msi.c:			      mpic->irqhost->of_node);
arch/powerpc/sysdev/mpic_pasemi_msi.c:	if (!mpic->irqhost->of_node ||
arch/powerpc/sysdev/mpic_pasemi_msi.c:	    !of_device_is_compatible(mpic->irqhost->of_node,
arch/powerpc/sysdev/xilinx_intc.c:	void * regs = master_irqhost->host_data;
arch/sparc/kernel/pci.c:/* If the user uses a host-bridge as the PCI device, he may use
arch/x86/kernel/cpu/perf_event_amd.c:	 * We only mask out the Host-only bit so that host-only counting works
arch/x86/kvm/mmu.c: * 2. while doing 1. it walks guest-physical to host-physical
arch/x86/kvm/vmx.c:	/* The host-usable pointer to the above */
arch/x86/kvm/vmx.c:	 * Guest pages referred to in vmcs02 with host-physical pointers, so
arch/x86/kvm/vmx.c: * Set up the vmcs's constant host-state fields, i.e., host-state fields that
arch/x86/kvm/vmx.c: * Note that host-state that does change is set elsewhere. E.g., host-state
arch/x86/kvm/vmx.c:	 * Set host-state according to L0's settings (vmcs12 is irrelevant here)
arch/xtensa/boot/Makefile:	      $(addprefix $(obj)/,$(host-progs))
block/scsi_ioctl.c:	/* In particular, rule out all resets and host-specific ioctls.  */
drivers/ata/acard-ahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/acard-ahci.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/acard-ahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/acard-ahci.c:	struct device *dev = ap->host->dev;
drivers/ata/acard-ahci.c:	host->private_data = hpriv;
drivers/ata/acard-ahci.c:		host->flags |= ATA_HOST_PARALLEL_SCAN;
drivers/ata/acard-ahci.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/acard-ahci.c:		struct ata_port *ap = host->ports[i];
drivers/ata/ahci.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ahci.c:		struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/ahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/ahci.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/ahci.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ahci.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ahci.c:		struct ata_port *ap = host->ports[1];
drivers/ata/ahci.c:	dev_info(host->dev, "applying extra ACPI _GTF filter 0x%x for %s\n",
drivers/ata/ahci.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/ahci.c:		struct ata_port *ap = host->ports[i];
drivers/ata/ahci.c:	host->private_data = hpriv;
drivers/ata/ahci.c:		host->flags |= ATA_HOST_PARALLEL_SCAN;
drivers/ata/ahci.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/ahci.c:		struct ata_port *ap = host->ports[i];
drivers/ata/ahci.h:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/ahci_platform.c:	host->private_data = hpriv;
drivers/ata/ahci_platform.c:		host->flags |= ATA_HOST_PARALLEL_SCAN;
drivers/ata/ahci_platform.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/ahci_platform.c:		struct ata_port *ap = host->ports[i];
drivers/ata/ahci_platform.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/ata_generic.c:	const struct pci_device_id *id = ap->host->private_data;
drivers/ata/ata_piix.c:	/* host->flags bits */
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = ap->host->private_data;
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/ata_piix.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/ata_piix.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = ap->host->private_data;
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = link->ap->host->private_data;
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = link->ap->host->private_data;
drivers/ata/ata_piix.c:		spin_lock_irqsave(&host->lock, flags);
drivers/ata/ata_piix.c:		host->flags |= PIIX_HOST_BROKEN_SUSPEND;
drivers/ata/ata_piix.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/ata_piix.c:	if (host->flags & PIIX_HOST_BROKEN_SUSPEND) {
drivers/ata/ata_piix.c:		spin_lock_irqsave(&host->lock, flags);
drivers/ata/ata_piix.c:		host->flags &= ~PIIX_HOST_BROKEN_SUSPEND;
drivers/ata/ata_piix.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ata_piix.c:		dev_warn(host->dev,
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = host->private_data;
drivers/ata/ata_piix.c:	struct ata_link *link0 = &host->ports[0]->link;
drivers/ata/ata_piix.c:	if (!(host->ports[0]->flags & PIIX_FLAG_SIDPR))
drivers/ata/ata_piix.c:			dev_info(host->dev,
drivers/ata/ata_piix.c:		struct ata_port *ap = host->ports[i];
drivers/ata/ata_piix.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = host->private_data;
drivers/ata/ata_piix.c:		host->flags |= ATA_HOST_IGNORE_ATA;
drivers/ata/ata_piix.c:		dev_info(host->dev, "%s detected, ATA device ignore set\n",
drivers/ata/ata_piix.c:	host->private_data = hpriv;
drivers/ata/ata_piix.c:		if (host->ports[0]->ops == &piix_sidpr_sata_ops)
drivers/ata/ata_piix.c:		host->ports[0]->mwdma_mask = 0;
drivers/ata/ata_piix.c:		host->ports[0]->udma_mask = 0;
drivers/ata/ata_piix.c:		host->ports[1]->mwdma_mask = 0;
drivers/ata/ata_piix.c:		host->ports[1]->udma_mask = 0;
drivers/ata/ata_piix.c:	host->flags |= ATA_HOST_PARALLEL_SCAN;
drivers/ata/ata_piix.c:	struct piix_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:			dev_err(host->dev, "controller reset failed (0x%x)\n",
drivers/ata/libahci.c:		dev_info(host->dev, "skipping global host reset\n");
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libahci.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libahci.c:		ahci_port_init(host->dev, ap, i, mmio, port_mmio);
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = dev->link->ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:		dev_err(ap->host->dev, "failed to clear device error\n");
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	hpriv = host->private_data;
drivers/ata/libahci.c:	spin_lock(&host->lock);
drivers/ata/libahci.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libahci.c:		ap = host->ports[i];
drivers/ata/libahci.c:				dev_warn(host->dev,
drivers/ata/libahci.c:	spin_unlock(&host->lock);
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:		dev_info(ap->host->dev, "FBS is enabled\n");
drivers/ata/libahci.c:		dev_err(ap->host->dev, "Failed to enable FBS\n");
drivers/ata/libahci.c:		dev_err(ap->host->dev, "Failed to disable FBS\n");
drivers/ata/libahci.c:		dev_info(ap->host->dev, "FBS is disabled\n");
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = ap->host->private_data;
drivers/ata/libahci.c:	struct device *dev = ap->host->dev;
drivers/ata/libahci.c:	struct ahci_host_priv *hpriv = host->private_data;
drivers/ata/libahci.c:	dev_info(host->dev,
drivers/ata/libahci.c:	dev_info(host->dev,
drivers/ata/libata-acpi.c:			acpi_get_child(ap->host->acpi_handle, adr);
drivers/ata/libata-acpi.c:				acpi_get_child(ap->host->acpi_handle, adr);
drivers/ata/libata-acpi.c:	ap->acpi_handle = acpi_get_child(ap->host->acpi_handle, ap->port_no);
drivers/ata/libata-acpi.c:	if (!is_pci_dev(host->dev) || libata_noacpi)
drivers/ata/libata-acpi.c:	host->acpi_handle = DEVICE_ACPI_HANDLE(host->dev);
drivers/ata/libata-acpi.c:	if (!host->acpi_handle)
drivers/ata/libata-acpi.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-acpi.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-acpi.c:		if (host->ports[0]->flags & ATA_FLAG_ACPI_SATA)
drivers/ata/libata-acpi.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-acpi.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:		if (ap->host->flags & ATA_HOST_IGNORE_ATA &&
drivers/ata/libata-core.c:		hdepth = min(ap->scsi_host->can_queue, ATA_MAX_QUEUE - 1);
drivers/ata/libata-core.c:	if (used_dma && (ap->host->flags & ATA_HOST_SIMPLEX))
drivers/ata/libata-core.c:		ap->host->simplex_claimed = ap;
drivers/ata/libata-core.c:	if (link->ap->host->flags & ATA_HOST_PARALLEL_SCAN)
drivers/ata/libata-core.c:	if ((host->flags & ATA_HOST_SIMPLEX) &&
drivers/ata/libata-core.c:	    host->simplex_claimed && host->simplex_claimed != ap) {
drivers/ata/libata-core.c:	host->dev->power.power_state = mesg;
drivers/ata/libata-core.c:	host->dev->power.power_state = PMSG_ON;
drivers/ata/libata-core.c:	ap->lock = &host->lock;
drivers/ata/libata-core.c:	ap->dev = host->dev;
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:		host->ports[i] = NULL;
drivers/ata/libata-core.c: *	@max_ports ports are allocated and host->n_ports is
drivers/ata/libata-core.c: *	host->n_ports before calling ata_host_register().  The unused
drivers/ata/libata-core.c:	spin_lock_init(&host->lock);
drivers/ata/libata-core.c:	mutex_init(&host->eh_mutex);
drivers/ata/libata-core.c:	host->dev = dev;
drivers/ata/libata-core.c:	host->n_ports = max_ports;
drivers/ata/libata-core.c:		host->ports[i] = ap;
drivers/ata/libata-core.c:	for (i = 0, j = 0, pi = NULL; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:		if (!host->ops && (pi->port_ops != &ata_dummy_port_ops))
drivers/ata/libata-core.c:			host->ops = pi->port_ops;
drivers/ata/libata-core.c:	WARN_ON(!(host->flags & ATA_HOST_STARTED));
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:	if (host->ops->host_stop)
drivers/ata/libata-core.c:		host->ops->host_stop(host);
drivers/ata/libata-core.c: *	recorded in host->flags, so this function can be called
drivers/ata/libata-core.c: *	once.  If host->ops isn't initialized yet, its set to the
drivers/ata/libata-core.c:	if (host->flags & ATA_HOST_STARTED)
drivers/ata/libata-core.c:	ata_finalize_port_ops(host->ops);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:		if (!host->ops && !ata_port_is_dummy(ap))
drivers/ata/libata-core.c:			host->ops = ap->ops;
drivers/ata/libata-core.c:	if (host->ops->host_stop)
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:					dev_err(host->dev,
drivers/ata/libata-core.c:		devres_add(host->dev, start_dr);
drivers/ata/libata-core.c:	host->flags |= ATA_HOST_STARTED;
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:	spin_lock_init(&host->lock);
drivers/ata/libata-core.c:	mutex_init(&host->eh_mutex);
drivers/ata/libata-core.c:	host->dev = dev;
drivers/ata/libata-core.c:	host->flags = flags;
drivers/ata/libata-core.c:	host->ops = ops;
drivers/ata/libata-core.c:	if (!(ap->host->flags & ATA_HOST_PARALLEL_SCAN) && ap->port_no != 0)
drivers/ata/libata-core.c:	if (!(host->flags & ATA_HOST_STARTED)) {
drivers/ata/libata-core.c:		dev_err(host->dev, "BUG: trying to register unstarted host\n");
drivers/ata/libata-core.c:	for (i = host->n_ports; host->ports[i]; i++)
drivers/ata/libata-core.c:		kfree(host->ports[i]);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/libata-core.c:		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		rc = ata_tport_add(host->dev,host->ports[i]);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-core.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-core.c:		ata_tport_delete(host->ports[i]);
drivers/ata/libata-core.c:	rc = devm_request_irq(host->dev, irq, irq_handler, irq_flags,
drivers/ata/libata-core.c:			      dev_driver_string(host->dev), host);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/libata-core.c:		ata_port_desc(host->ports[i], "irq %d", irq);
drivers/ata/libata-core.c:		devm_free_irq(host->dev, irq, host);
drivers/ata/libata-core.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/libata-core.c:		ata_port_detach(host->ports[i]);
drivers/ata/libata-core.c:	bool owns_eh = ap && ap->host->eh_owner == current;
drivers/ata/libata-eh.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/libata-eh.c:	mutex_lock(&ap->host->eh_mutex);
drivers/ata/libata-eh.c:	WARN_ON_ONCE(ap->host->eh_owner);
drivers/ata/libata-eh.c:	ap->host->eh_owner = current;
drivers/ata/libata-eh.c:	WARN_ON_ONCE(ap->host->eh_owner != current);
drivers/ata/libata-eh.c:	ap->host->eh_owner = NULL;
drivers/ata/libata-eh.c:	mutex_unlock(&ap->host->eh_mutex);
drivers/ata/libata-eh.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/ata/libata-eh.c:	list_splice_init(&host->eh_cmd_q, &eh_work_q);
drivers/ata/libata-eh.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/ata/libata-eh.c:	WARN_ON(host->host_failed || !list_empty(&eh_work_q));
drivers/ata/libata-eh.c:		host->host_eh_scheduled = 0;
drivers/ata/libata-scsi.c:		depth = min(sdev->host->can_queue, ata_id_queue_depth(dev->id));
drivers/ata/libata-scsi.c:	queue_depth = min(queue_depth, sdev->host->can_queue);
drivers/ata/libata-scsi.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-scsi.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-scsi.c:		shost->eh_noresume = 1;
drivers/ata/libata-scsi.c:		*(struct ata_port **)&shost->hostdata[0] = ap;
drivers/ata/libata-scsi.c:		shost->transportt = ata_scsi_transport_template;
drivers/ata/libata-scsi.c:		shost->unique_id = ap->print_id;
drivers/ata/libata-scsi.c:		shost->max_id = 16;
drivers/ata/libata-scsi.c:		shost->max_lun = 1;
drivers/ata/libata-scsi.c:		shost->max_channel = 1;
drivers/ata/libata-scsi.c:		shost->max_cmd_len = 16;
drivers/ata/libata-scsi.c:		shost->max_host_blocked = 1;
drivers/ata/libata-scsi.c:						&ap->tdev, ap->host->dev);
drivers/ata/libata-scsi.c:	scsi_host_put(host->ports[i]->scsi_host);
drivers/ata/libata-scsi.c:		struct Scsi_Host *shost = host->ports[i]->scsi_host;
drivers/ata/libata-scsi.c:	mutex_lock(&ap->scsi_host->scan_mutex);
drivers/ata/libata-scsi.c:	mutex_unlock(&ap->scsi_host->scan_mutex);
drivers/ata/libata-scsi.c:	ap->lock = &host->lock;
drivers/ata/libata-sff.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/libata-sff.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-sff.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-sff.c:		for (i = 0; i < host->n_ports; i++) {
drivers/ata/libata-sff.c:			struct ata_port *ap = host->ports[i];
drivers/ata/libata-sff.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/libata-sff.c:	struct device *gdev = host->dev;
drivers/ata/libata-sff.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-sff.c:		host->iomap = iomap = pcim_iomap_table(pdev);
drivers/ata/libata-sff.c:	struct device *dev = host->dev;
drivers/ata/libata-sff.c:	const char *drv_name = dev_driver_string(host->dev);
drivers/ata/libata-sff.c:			if (ata_port_is_dummy(host->ports[i]))
drivers/ata/libata-sff.c:			ata_port_desc(host->ports[i], "irq %d", pdev->irq);
drivers/ata/libata-sff.c:		if (!ata_port_is_dummy(host->ports[0])) {
drivers/ata/libata-sff.c:			ata_port_desc(host->ports[0], "irq %d",
drivers/ata/libata-sff.c:		if (!ata_port_is_dummy(host->ports[1])) {
drivers/ata/libata-sff.c:			ata_port_desc(host->ports[1], "irq %d",
drivers/ata/libata-sff.c:	host->private_data = host_priv;
drivers/ata/libata-sff.c:	host->flags |= hflags;
drivers/ata/libata-sff.c:			dmam_alloc_coherent(ap->host->dev, ATA_PRD_TBL_SZ,
drivers/ata/libata-sff.c:	dev_err(host->dev, "BMDMA: %s, falling back to PIO\n", reason);
drivers/ata/libata-sff.c:		host->ports[i]->mwdma_mask = 0;
drivers/ata/libata-sff.c:		host->ports[i]->udma_mask = 0;
drivers/ata/libata-sff.c:	struct device *gdev = host->dev;
drivers/ata/libata-sff.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/libata-sff.c:		struct ata_port *ap = host->ports[i];
drivers/ata/libata-sff.c:		void __iomem *bmdma = host->iomap[4] + 8 * i;
drivers/ata/libata-sff.c:			host->flags |= ATA_HOST_SIMPLEX;
drivers/ata/pata_acpi.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ali.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ali.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ali.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ali.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:/* Both host-side and drive-side detection results are worthless on NV
drivers/ata/pata_amd.c:	udma = saved_udma = (unsigned long)ap->host->private_data;
drivers/ata/pata_amd.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_amd.c:	u32 udma = (unsigned long)host->private_data;
drivers/ata/pata_amd.c:	pci_write_config_dword(to_pci_dev(host->dev), 0x60, udma);
drivers/ata/pata_arasan_cf.c:	struct device *dev = acdev->host->dev;
drivers/ata/pata_arasan_cf.c:	struct ata_port *ap = acdev->host->ports[0];
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_pdata *pdata = dev_get_platdata(acdev->host->dev);
drivers/ata/pata_arasan_cf.c:		dev_dbg(acdev->host->dev, "clock enable failed");
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "%s TimeOut", rw ? "write" : "read");
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "device_prep_dma_memcpy failed\n");
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "dma_submit_error\n");
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "wait_for_completion_timeout\n");
drivers/ata/pata_arasan_cf.c:		spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:				dev_err(acdev->host->dev, "dma failed");
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "Unable to get dma_chan\n");
drivers/ata/pata_arasan_cf.c:		spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		dev_err(acdev->host->dev, "pio xfer err irq\n");
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = ap->host->private_data;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = ap->host->private_data;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = ap->host->private_data;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = ap->host->private_data;
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = ap->host->private_data;
drivers/ata/pata_arasan_cf.c:	spin_lock_irqsave(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:		spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	spin_unlock_irqrestore(&acdev->host->lock, flags);
drivers/ata/pata_arasan_cf.c:	ap = host->ports[0];
drivers/ata/pata_arasan_cf.c:	host->private_data = acdev;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = host->ports[0]->private_data;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = host->ports[0]->private_data;
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_dev *acdev = host->ports[0]->private_data;
drivers/ata/pata_artop.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_artop.c:	struct ata_port *alt = host->ports[1 ^ qc->ap->port_no];
drivers/ata/pata_at32.c:	struct at32_ide_info *info = ap->host->private_data;
drivers/ata/pata_at32.c:	ap = host->ports[0];
drivers/ata/pata_at32.c:	host->private_data = info;
drivers/ata/pata_at32.c:	info = host->private_data;
drivers/ata/pata_at91.c:	struct at91_ide_info *info = ap->host->private_data;
drivers/ata/pata_at91.c:	struct at91_ide_info *info = dev->link->ap->host->private_data;
drivers/ata/pata_at91.c:	ap = host->ports[0];
drivers/ata/pata_at91.c:	host->private_data = info;
drivers/ata/pata_at91.c:	info = host->private_data;
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atiixp.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atp867x.c:#define ATP867X_IOBASE(ap)		((ap)->host->iomap[0])
drivers/ata/pata_atp867x.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_atp867x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atp867x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_atp867x.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/pata_atp867x.c:	struct ata_port *ap = host->ports[0];
drivers/ata/pata_atp867x.c:	struct device *gdev = host->dev;
drivers/ata/pata_atp867x.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pata_atp867x.c:			(unsigned long long)(host->iomap[i]));
drivers/ata/pata_atp867x.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/pata_atp867x.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_bf54x.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/pata_bf54x.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/pata_bf54x.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_bf54x.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/pata_bf54x.c:	void __iomem *base = (void __iomem *)host->ports[0]->ioaddr.ctl_addr;
drivers/ata/pata_bf54x.c:	host->ports[0]->ioaddr.ctl_addr = (void *)res->start;
drivers/ata/pata_cmd640.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd640.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd640.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd640.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cmd64x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cs5520.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cs5520.c:	ioaddr = &host->ports[0]->ioaddr;
drivers/ata/pata_cs5520.c:	ata_port_desc(host->ports[0],
drivers/ata/pata_cs5520.c:	ata_port_pbar_desc(host->ports[0], 4, 0, "bmdma");
drivers/ata/pata_cs5520.c:	ioaddr = &host->ports[1]->ioaddr;
drivers/ata/pata_cs5520.c:	ata_port_desc(host->ports[1],
drivers/ata/pata_cs5520.c:	ata_port_pbar_desc(host->ports[1], 4, 8, "bmdma");
drivers/ata/pata_cs5520.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_cs5535.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cs5536.c:	struct pci_dev *pdev = to_pci_dev(adev->link->ap->host->dev);
drivers/ata/pata_cs5536.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cs5536.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cs5536.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_cypress.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_efar.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_efar.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_efar.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_efar.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt366.c:	struct hpt_clock *clocks = ap->host->private_data;
drivers/ata/pata_hpt366.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt366.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct hpt_clock *clocks = ap->host->private_data;
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt37x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x2n.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x2n.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x2n.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x2n.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x2n.c:	long flags = (long)ap->host->private_data;
drivers/ata/pata_hpt3x2n.c:	struct ata_port *alt = ap->host->ports[ap->port_no ^ 1];
drivers/ata/pata_hpt3x2n.c:	int rc, flags = (long)ap->host->private_data;
drivers/ata/pata_hpt3x2n.c:	int flags = (long)ap->host->private_data;
drivers/ata/pata_hpt3x2n.c:		ap->host->private_data = (void *)(long)flags;
drivers/ata/pata_hpt3x3.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x3.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_hpt3x3.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pata_hpt3x3.c:	base = host->iomap[4];	/* Bus mastering base */
drivers/ata/pata_hpt3x3.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/pata_hpt3x3.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = ap->host->private_data;
drivers/ata/pata_icside.c:	host->private_data = info->state;
drivers/ata/pata_icside.c:	host->flags = ATA_HOST_SIMPLEX;
drivers/ata/pata_icside.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_icside.c:		struct pata_icside_state *state = host->private_data;
drivers/ata/pata_icside.c:	struct pata_icside_state *state = host->private_data;
drivers/ata/pata_imx.c:	struct pata_imx_priv *priv = ap->host->private_data;
drivers/ata/pata_imx.c:	host->private_data = priv;
drivers/ata/pata_imx.c:	ap = host->ports[0];
drivers/ata/pata_imx.c:	struct pata_imx_priv *priv = host->private_data;
drivers/ata/pata_imx.c:	struct pata_imx_priv *priv = host->private_data;
drivers/ata/pata_imx.c:	struct pata_imx_priv *priv = host->private_data;
drivers/ata/pata_isapnp.c:	ap = host->ports[0];
drivers/ata/pata_it8213.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it8213.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it8213.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_it8213.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_it821x.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ixp4xx_cf.c:	struct ixp4xx_pata_data *data = ap->host->dev->platform_data;
drivers/ata/pata_ixp4xx_cf.c:	ap = host->ports[0];
drivers/ata/pata_jmicron.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_legacy.c:	ap->host->private_data = ap;
drivers/ata/pata_legacy.c:	if (ap->host->private_data != ap->host
drivers/ata/pata_legacy.c:	    && ap->host->private_data != NULL)
drivers/ata/pata_legacy.c:	struct legacy_data *ld_qdi = ap->host->private_data;
drivers/ata/pata_legacy.c:	struct legacy_data *ld_qdi = ap->host->private_data;
drivers/ata/pata_legacy.c:	struct legacy_data *ld_winbond = ap->host->private_data;
drivers/ata/pata_legacy.c:	ap = host->ports[0];
drivers/ata/pata_legacy.c:	ap->host->private_data = ld;
drivers/ata/pata_macio.c:	pata_macio_apply_timings(priv->host->ports[0], 0);
drivers/ata/pata_macio.c:	priv->host->private_data = priv;
drivers/ata/pata_macio.c:	priv->host->iomap = &priv->tfregs;
drivers/ata/pata_macio.c:	pata_macio_setup_ios(&priv->host->ports[0]->ioaddr,
drivers/ata/pata_macio.c:	priv->host->ports[0]->private_data = priv;
drivers/ata/pata_macio.c:	pata_macio_apply_timings(priv->host->ports[0], 0);
drivers/ata/pata_macio.c:	struct pata_macio_priv *priv = host->private_data;
drivers/ata/pata_macio.c:	priv->host->private_data = NULL;
drivers/ata/pata_macio.c:	return pata_macio_do_suspend(host->private_data, mesg);
drivers/ata/pata_macio.c:	return pata_macio_do_resume(host->private_data);
drivers/ata/pata_macio.c:	if (!host || !host->private_data)
drivers/ata/pata_macio.c:	ap = host->ports[0];
drivers/ata/pata_macio.c:	return pata_macio_do_suspend(host->private_data, mesg);
drivers/ata/pata_macio.c:	return pata_macio_do_resume(host->private_data);
drivers/ata/pata_marvell.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = ap->host->private_data;
drivers/ata/pata_mpc52xx.c:	ap = host->ports[0];
drivers/ata/pata_mpc52xx.c:	host->private_data	= priv;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = host->private_data;
drivers/ata/pata_mpc52xx.c:	struct mpc52xx_ata_priv *priv = host->private_data;
drivers/ata/pata_mpc52xx.c:		dev_err(host->dev, "error initializing hardware\n");
drivers/ata/pata_mpiix.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_mpiix.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_mpiix.c:	ap = host->ports[0];
drivers/ata/pata_ninja32.c:	ap = host->ports[0];
drivers/ata/pata_ninja32.c:	host->iomap = pcim_iomap_table(dev);
drivers/ata/pata_ninja32.c:	base = host->iomap[0];
drivers/ata/pata_ninja32.c:	ninja32_program(host->iomap[0]);
drivers/ata/pata_ns87410.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ns87410.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_ns87415.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_octeon_cf.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/pata_octeon_cf.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/pata_octeon_cf.c:		ap = host->ports[i];
drivers/ata/pata_octeon_cf.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/pata_octeon_cf.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/pata_octeon_cf.c:	 * protected by host->lock.
drivers/ata/pata_octeon_cf.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/pata_octeon_cf.c:	ap = host->ports[0];
drivers/ata/pata_oldpiix.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_oldpiix.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_oldpiix.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_opti.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_optidma.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_optidma.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_optidma.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_palmld.c:	ap = host->ports[0];
drivers/ata/pata_pcmcia.c:		ap = host->ports[p];
drivers/ata/pata_pdc2027x.c:	return ap->host->iomap[PDC_MMIO_BAR] + ap->port_no * 0x100 + offset;
drivers/ata/pata_pdc2027x.c:	void __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];
drivers/ata/pata_pdc2027x.c:	void __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];
drivers/ata/pata_pdc2027x.c:	void __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];
drivers/ata/pata_pdc2027x.c:	dev_info(host->dev, "PLL input clock %ld kHz\n", pll_clock/1000);
drivers/ata/pata_pdc2027x.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pata_pdc2027x.c:	mmio_base = host->iomap[PDC_MMIO_BAR];
drivers/ata/pata_pdc2027x.c:		struct ata_port *ap = host->ports[i];
drivers/ata/pata_pdc202xx_old.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_pdc202xx_old.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_pdc202xx_old.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_pdc202xx_old.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_pdc202xx_old.c:	void __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;
drivers/ata/pata_pdc202xx_old.c:	void __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;
drivers/ata/pata_piccolo.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_piccolo.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_platform.c:	ap = host->ports[0];
drivers/ata/pata_pxa.c:	ap		= host->ports[0];
drivers/ata/pata_pxa.c:	struct pata_pxa_data *data = host->ports[0]->private_data;
drivers/ata/pata_radisys.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_radisys.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_rdc.c:	struct rdc_host_priv *hpriv = ap->host->private_data;
drivers/ata/pata_rdc.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_rdc.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_rdc.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_rdc.c:	host->private_data = hpriv;
drivers/ata/pata_rdc.c:	host->flags |= ATA_HOST_PARALLEL_SCAN;
drivers/ata/pata_rdc.c:	struct rdc_host_priv *hpriv = host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = ap->host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = ap->host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = host->private_data;
drivers/ata/pata_samsung_cf.c:	ap = host->ports[0];
drivers/ata/pata_samsung_cf.c:	host->private_data = info;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = host->private_data;
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_info *info = host->private_data;
drivers/ata/pata_sc1200.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sc1200.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sc1200.c:	struct ata_port *alt = host->ports[1 ^ qc->ap->port_no];
drivers/ata/pata_scc.c:	void __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];
drivers/ata/pata_scc.c:	void __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];
drivers/ata/pata_scc.c:	void __iomem *ctrl_base = ap->host->iomap[SCC_CTRL_BAR];
drivers/ata/pata_scc.c:	void __iomem *bmid_base = ap->host->iomap[SCC_BMID_BAR];
drivers/ata/pata_scc.c:	void __iomem *ctrl_base = host->iomap[SCC_CTRL_BAR];
drivers/ata/pata_scc.c:	void __iomem *bmid_base = host->iomap[SCC_BMID_BAR];
drivers/ata/pata_scc.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/pata_scc.c:	scc_setup_ports(&host->ports[0]->ioaddr, host->iomap[SCC_BMID_BAR]);
drivers/ata/pata_scc.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pata_scc.c:	ata_port_pbar_desc(host->ports[0], SCC_CTRL_BAR, -1, "ctrl");
drivers/ata/pata_scc.c:	ata_port_pbar_desc(host->ports[0], SCC_BMID_BAR, -1, "bmid");
drivers/ata/pata_sch.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_sch.c:	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_serverworks.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_serverworks.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_serverworks.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_serverworks.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sil680.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sil680.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sil680.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sil680.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_sil680.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pata_sil680.c:	mmio_base = host->iomap[SIL680_MMIO_BAR];
drivers/ata/pata_sil680.c:	host->ports[0]->ioaddr.bmdma_addr = mmio_base + 0x00;
drivers/ata/pata_sil680.c:	host->ports[0]->ioaddr.cmd_addr = mmio_base + 0x80;
drivers/ata/pata_sil680.c:	host->ports[0]->ioaddr.ctl_addr = mmio_base + 0x8a;
drivers/ata/pata_sil680.c:	host->ports[0]->ioaddr.altstatus_addr = mmio_base + 0x8a;
drivers/ata/pata_sil680.c:	ata_sff_std_ports(&host->ports[0]->ioaddr);
drivers/ata/pata_sil680.c:	host->ports[1]->ioaddr.bmdma_addr = mmio_base + 0x08;
drivers/ata/pata_sil680.c:	host->ports[1]->ioaddr.cmd_addr = mmio_base + 0xc0;
drivers/ata/pata_sil680.c:	host->ports[1]->ioaddr.ctl_addr = mmio_base + 0xca;
drivers/ata/pata_sil680.c:	host->ports[1]->ioaddr.altstatus_addr = mmio_base + 0xca;
drivers/ata/pata_sil680.c:	ata_sff_std_ports(&host->ports[1]->ioaddr);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sis.c:				if (host->revision >= 0x30)	/* 630 ET */
drivers/ata/pata_sis.c:	sis_fixup(pdev, host->private_data);
drivers/ata/pata_sl82c105.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sl82c105.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sl82c105.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sl82c105.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_sl82c105.c:	struct ata_port *alt = host->ports[1 ^ qc->ap->port_no];
drivers/ata/pata_sl82c105.c:	struct pci_dev *pdev	= to_pci_dev(ap->host->dev);
drivers/ata/pata_triflex.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_triflex.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_via.c:	const struct via_isa_bridge *config = ap->host->private_data;
drivers/ata/pata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_via.c:	const struct via_isa_bridge *config = ap->host->private_data;
drivers/ata/pata_via.c:		struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_via.c:	const struct via_isa_bridge *config = ap->host->private_data;
drivers/ata/pata_via.c:	const struct via_isa_bridge *config = ap->host->private_data;
drivers/ata/pata_via.c:	const struct via_isa_bridge *config = host->private_data;
drivers/ata/pata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/pata_via.c:	via_fixup(pdev, host->private_data);
drivers/ata/pdc_adma.c:	ADMA_REGS((ap)->host->iomap[ADMA_MMIO_BAR], ap->port_no)
drivers/ata/pdc_adma.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/pdc_adma.c:		struct ata_port *ap = host->ports[port_no];
drivers/ata/pdc_adma.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/pdc_adma.c:		struct ata_port *ap = host->ports[port_no];
drivers/ata/pdc_adma.c:	spin_lock(&host->lock);
drivers/ata/pdc_adma.c:	spin_unlock(&host->lock);
drivers/ata/pdc_adma.c:	struct device *dev = ap->host->dev;
drivers/ata/pdc_adma.c:	writeb(7, host->iomap[ADMA_MMIO_BAR] + ADMA_MODE_LOCK);
drivers/ata/pdc_adma.c:		adma_reset_engine(host->ports[port_no]);
drivers/ata/pdc_adma.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/pdc_adma.c:	mmio_base = host->iomap[ADMA_MMIO_BAR];
drivers/ata/pdc_adma.c:		struct ata_port *ap = host->ports[port_no];
drivers/ata/sata_dwc_460ex.c:					(ap)->host->private_data)
drivers/ata/sata_dwc_460ex.c:					(qc)->ap->host->private_data)
drivers/ata/sata_dwc_460ex.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	ap = host->ports[port];
drivers/ata/sata_dwc_460ex.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	ap = host->ports[port];
drivers/ata/sata_dwc_460ex.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	pdev = ap->host->dev;
drivers/ata/sata_dwc_460ex.c:		dev_err(ap->dev, "%s: no ap->host->dev\n", __func__);
drivers/ata/sata_dwc_460ex.c:			dma_free_coherent(ap->host->dev,
drivers/ata/sata_dwc_460ex.c:	spin_lock_irqsave(&ap->host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	spin_unlock_irqrestore(&ap->host->lock, flags);
drivers/ata/sata_dwc_460ex.c:	host->private_data = hsdev;
drivers/ata/sata_dwc_460ex.c:	host->ports[0]->ioaddr.cmd_addr = base;
drivers/ata/sata_dwc_460ex.c:	host->ports[0]->ioaddr.scr_addr = base + SATA_DWC_SCR_OFFSET;
drivers/ata/sata_dwc_460ex.c:	sata_dwc_setup_port(&host->ports[0]->ioaddr, (unsigned long)base);
drivers/ata/sata_dwc_460ex.c:	struct sata_dwc_device *hsdev = host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = host->private_data;
drivers/ata/sata_fsl.c:	spin_lock(&host->lock);
drivers/ata/sata_fsl.c:	spin_unlock(&host->lock);
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = qc->ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = link->ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = link->ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = ap->host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = host->private_data;
drivers/ata/sata_fsl.c:	spin_lock(&host->lock);
drivers/ata/sata_fsl.c:	ap = host->ports[0];
drivers/ata/sata_fsl.c:		dev_warn(host->dev, "interrupt on disabled port 0\n");
drivers/ata/sata_fsl.c:	spin_unlock(&host->lock);
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = host->private_data;
drivers/ata/sata_fsl.c:	/* host->iomap is not used currently */
drivers/ata/sata_fsl.c:	host->private_data = host_priv;
drivers/ata/sata_fsl.c:	retval = device_create_file(host->dev, &host_priv->intr_coalescing);
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = host->private_data;
drivers/ata/sata_fsl.c:	struct sata_fsl_host_priv *host_priv = host->private_data;
drivers/ata/sata_fsl.c:	struct ata_port *ap = host->ports[0];
drivers/ata/sata_inic162x.c:	struct inic_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_inic162x.c:	struct inic_host_priv *hpriv = host->private_data;
drivers/ata/sata_inic162x.c:	spin_lock(&host->lock);
drivers/ata/sata_inic162x.c:			inic_host_intr(host->ports[i]);
drivers/ata/sata_inic162x.c:	spin_unlock(&host->lock);
drivers/ata/sata_inic162x.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_inic162x.c:	struct inic_host_priv *hpriv = host->private_data;
drivers/ata/sata_inic162x.c:	host->private_data = hpriv;
drivers/ata/sata_inic162x.c:	host->iomap = iomap = pcim_iomap_table(pdev);
drivers/ata/sata_inic162x.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_mv.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_mv.c:		struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:		struct ata_port *this_ap = host->ports[port];
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:		struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:		struct ata_port *ap = host->ports[port];
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	dev_err(host->dev, "PCI ERROR; PCI IRQ cause=0x%08x\n", err_cause);
drivers/ata/sata_mv.c:	mv_dump_all_regs(mmio, -1, to_pci_dev(host->dev));
drivers/ata/sata_mv.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_mv.c:		ap = host->ports[i];
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	spin_lock(&host->lock);
drivers/ata/sata_mv.c:	spin_unlock(&host->lock);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = link->ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = link->ap->host->private_data;
drivers/ata/sata_mv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = ap->host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:		dev_err(host->dev, "BUG: invalid board index %u\n", board_idx);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	n_hc = mv_get_hc_count(host->ports[0]->flags);
drivers/ata/sata_mv.c:	for (port = 0; port < host->n_ports; port++)
drivers/ata/sata_mv.c:	for (port = 0; port < host->n_ports; port++) {
drivers/ata/sata_mv.c:		struct ata_port *ap = host->ports[port];
drivers/ata/sata_mv.c:	host->private_data = hpriv;
drivers/ata/sata_mv.c:	host->iomap = NULL;
drivers/ata/sata_mv.c:		 (unsigned)MV_MAX_Q_DEPTH, host->n_ports);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:		struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_mv.c:	struct mv_host_priv *hpriv = host->private_data;
drivers/ata/sata_mv.c:		 gen, (unsigned)MV_MAX_Q_DEPTH, host->n_ports,
drivers/ata/sata_mv.c:	host->private_data = hpriv;
drivers/ata/sata_mv.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_mv.c:	hpriv->base = host->iomap[MV_PRIMARY_BAR];
drivers/ata/sata_mv.c:	for (port = 0; port < host->n_ports; port++) {
drivers/ata/sata_mv.c:		struct ata_port *ap = host->ports[port];
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_nv.c:	port0 = ap->host->ports[0]->private_data;
drivers/ata/sata_nv.c:	port1 = ap->host->ports[1]->private_data;
drivers/ata/sata_nv.c:	sdev0 = ap->host->ports[0]->link.device[0].sdev;
drivers/ata/sata_nv.c:	sdev1 = ap->host->ports[1]->link.device[0].sdev;
drivers/ata/sata_nv.c:		      (unsigned long long)*ap->host->dev->dma_mask,
drivers/ata/sata_nv.c:	spin_lock(&host->lock);
drivers/ata/sata_nv.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_nv.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_nv.c:			u8 irq_stat = readb(host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804)
drivers/ata/sata_nv.c:			u8 irq_stat = readb(host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804)
drivers/ata/sata_nv.c:		struct nv_adma_port_priv *pp = host->ports[0]->private_data;
drivers/ata/sata_nv.c:		pp = host->ports[1]->private_data;
drivers/ata/sata_nv.c:	spin_unlock(&host->lock);
drivers/ata/sata_nv.c:		ap->host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804);
drivers/ata/sata_nv.c:		ap->host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804);
drivers/ata/sata_nv.c:	pp = ap->host->ports[0]->private_data;
drivers/ata/sata_nv.c:	pp = ap->host->ports[1]->private_data;
drivers/ata/sata_nv.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_nv.c:	mmio = ap->host->iomap[NV_MMIO_BAR] + NV_ADMA_PORT +
drivers/ata/sata_nv.c:	pp->gen_block = ap->host->iomap[NV_MMIO_BAR] + NV_ADMA_GEN;
drivers/ata/sata_nv.c:	void __iomem *mmio = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_nv.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/sata_nv.c:		nv_adma_setup_port(host->ports[i]);
drivers/ata/sata_nv.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_nv.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_nv.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_nv.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_nv.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_nv.c:		handled += nv_host_intr(host->ports[i], irq_stat);
drivers/ata/sata_nv.c:	spin_lock(&host->lock);
drivers/ata/sata_nv.c:	irq_stat = ioread8(host->ports[0]->ioaddr.scr_addr + NV_INT_STATUS);
drivers/ata/sata_nv.c:	spin_unlock(&host->lock);
drivers/ata/sata_nv.c:	spin_lock(&host->lock);
drivers/ata/sata_nv.c:	irq_stat = readb(host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_CK804);
drivers/ata/sata_nv.c:	spin_unlock(&host->lock);
drivers/ata/sata_nv.c:	void __iomem *scr_addr = ap->host->ports[0]->ioaddr.scr_addr;
drivers/ata/sata_nv.c:	void __iomem *scr_addr = ap->host->ports[0]->ioaddr.scr_addr;
drivers/ata/sata_nv.c:	void __iomem *mmio_base = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio_base = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio_base = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio_base = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	void __iomem *mmio = host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_nv.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_nv.c:	void __iomem *mmio = ap->host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_nv.c:	irq_stat = readl(host->iomap[NV_MMIO_BAR] + NV_INT_STATUS_MCP55);
drivers/ata/sata_nv.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_nv.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_nv.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_nv.c:	host->private_data = hpriv;
drivers/ata/sata_nv.c:	base = host->iomap[NV_MMIO_BAR];
drivers/ata/sata_nv.c:	host->ports[0]->ioaddr.scr_addr = base + NV_PORT0_SCR_REG_OFFSET;
drivers/ata/sata_nv.c:	host->ports[1]->ioaddr.scr_addr = base + NV_PORT1_SCR_REG_OFFSET;
drivers/ata/sata_nv.c:	struct nv_host_priv *hpriv = host->private_data;
drivers/ata/sata_nv.c:			pp = host->ports[0]->private_data;
drivers/ata/sata_nv.c:			pp = host->ports[1]->private_data;
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_nv.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_promise.c:	/* host register offsets (from host->iomap[PDC_MMIO_BAR]) */
drivers/ata/sata_promise.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_promise.c:	for (i = 0; i < nr_ports && host->ports[i] != ap; ++i)
drivers/ata/sata_promise.c:	void __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	 * 1) hotplug register accesses must be serialised via host->lock
drivers/ata/sata_promise.c:	 * 2) ap->lock == &ap->host->lock
drivers/ata/sata_promise.c:	void __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	void __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	void __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	spin_lock(&ap->host->lock);
drivers/ata/sata_promise.c:	spin_unlock(&ap->host->lock);
drivers/ata/sata_promise.c:	if (!host || !host->iomap[PDC_MMIO_BAR]) {
drivers/ata/sata_promise.c:	host_mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	spin_lock(&host->lock);
drivers/ata/sata_promise.c:	if (host->ports[0]->flags & PDC_FLAG_GEN_II) {
drivers/ata/sata_promise.c:	is_sataii_tx4 = pdc_is_sataii_tx4(host->ports[0]->flags);
drivers/ata/sata_promise.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_promise.c:		ap = host->ports[i];
drivers/ata/sata_promise.c:	spin_unlock(&host->lock);
drivers/ata/sata_promise.c:	void __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	void __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_promise.c:	int is_gen2 = host->ports[0]->flags & PDC_FLAG_GEN_II;
drivers/ata/sata_promise.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_promise.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_promise.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_qstor.c:	return host->iomap[QS_MMIO_BAR];
drivers/ata/sata_qstor.c:			struct ata_port *ap = host->ports[port_no];
drivers/ata/sata_qstor.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/sata_qstor.c:		struct ata_port *ap = host->ports[port_no];
drivers/ata/sata_qstor.c:	spin_lock_irqsave(&host->lock, flags);
drivers/ata/sata_qstor.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/ata/sata_qstor.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_qstor.c:	void __iomem *mmio_base = host->iomap[QS_MMIO_BAR];
drivers/ata/sata_qstor.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/sata_qstor.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/sata_qstor.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_qstor.c:	rc = qs_set_dma_masks(pdev, host->iomap[QS_MMIO_BAR]);
drivers/ata/sata_qstor.c:	for (port_no = 0; port_no < host->n_ports; ++port_no) {
drivers/ata/sata_qstor.c:		struct ata_port *ap = host->ports[port_no];
drivers/ata/sata_qstor.c:		void __iomem *chan = host->iomap[QS_MMIO_BAR] + offset;
drivers/ata/sata_sil.c:	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	spin_lock(&host->lock);
drivers/ata/sata_sil.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_sil.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sil.c:	spin_unlock(&host->lock);
drivers/ata/sata_sil.c:	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c: *	sil_dev_config - Apply device/host-specific errata fixups
drivers/ata/sata_sil.c:	struct pci_dev *pdev = to_pci_dev(host->dev);
drivers/ata/sata_sil.c:	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:		for (i = 0; i < host->n_ports; i++)
drivers/ata/sata_sil.c:	if (host->ports[0]->flags & SIL_FLAG_RERR_ON_DMA_ACT) {
drivers/ata/sata_sil.c:		for (i = 0, cnt = 0; i < host->n_ports; i++) {
drivers/ata/sata_sil.c:	if (host->n_ports == 4) {
drivers/ata/sata_sil.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_sil.c:	mmio_base = host->iomap[SIL_MMIO_BAR];
drivers/ata/sata_sil.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_sil.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sil24.c:	return ap->host->iomap[SIL24_PORT_BAR] + sil24_port_offset(ap);
drivers/ata/sata_sil24.c:	void __iomem *host_base = host->iomap[SIL24_HOST_BAR];
drivers/ata/sata_sil24.c:	spin_lock(&host->lock);
drivers/ata/sata_sil24.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/sata_sil24.c:			sil24_host_intr(host->ports[i]);
drivers/ata/sata_sil24.c:	spin_unlock(&host->lock);
drivers/ata/sata_sil24.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_sil24.c:	void __iomem *host_base = host->iomap[SIL24_HOST_BAR];
drivers/ata/sata_sil24.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_sil24.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sil24.c:				dev_err(host->dev,
drivers/ata/sata_sil24.c:	host->iomap = iomap;
drivers/ata/sata_sil24.c:	void __iomem *host_base = host->iomap[SIL24_HOST_BAR];
drivers/ata/sata_sis.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_sis.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_sis.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_sis.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sis.c:		mmio = host->iomap[SIS_SCR_PCI_BAR];
drivers/ata/sata_sis.c:		host->ports[0]->ioaddr.scr_addr = mmio;
drivers/ata/sata_sis.c:		host->ports[1]->ioaddr.scr_addr = mmio + port2_start;
drivers/ata/sata_svw.c:	np = pci_device_to_OF_node(to_pci_dev(ap->host->dev));
drivers/ata/sata_svw.c:	index = (ap == ap->host->ports[0]) ? 0 : 1;
drivers/ata/sata_svw.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_svw.c:	mmio_base = host->iomap[bar_pos];
drivers/ata/sata_svw.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_svw.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sx4.c:	struct device *dev = ap->host->dev;
drivers/ata/sata_sx4.c:	void __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	struct pdc_host_priv *pp = ap->host->private_data;
drivers/ata/sata_sx4.c:	struct pdc_host_priv *pp = ap->host->private_data;
drivers/ata/sata_sx4.c:	void __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	if (!host || !host->iomap[PDC_MMIO_BAR]) {
drivers/ata/sata_sx4.c:	mmio_base = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	spin_lock(&host->lock);
drivers/ata/sata_sx4.c:		if (port_no >= host->n_ports)
drivers/ata/sata_sx4.c:			ap = host->ports[port_no];
drivers/ata/sata_sx4.c:	spin_unlock(&host->lock);
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	void __iomem *mmio = host->iomap[PDC_MMIO_BAR];
drivers/ata/sata_sx4.c:	host->private_data = hpriv;
drivers/ata/sata_sx4.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_sx4.c:		struct ata_port *ap = host->ports[i];
drivers/ata/sata_sx4.c:		void __iomem *base = host->iomap[PDC_MMIO_BAR] + PDC_CHIP0_OFS;
drivers/ata/sata_uli.c:	struct uli_priv *hpriv = ap->host->private_data;
drivers/ata/sata_uli.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_uli.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_uli.c:	host->private_data = hpriv;
drivers/ata/sata_uli.c:	iomap = host->iomap;
drivers/ata/sata_uli.c:		ioaddr = &host->ports[2]->ioaddr;
drivers/ata/sata_uli.c:		ata_port_desc(host->ports[2],
drivers/ata/sata_uli.c:		ioaddr = &host->ports[3]->ioaddr;
drivers/ata/sata_uli.c:		ata_port_desc(host->ports[2],
drivers/ata/sata_via.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_via.c:	struct pci_dev *pdev = to_pci_dev(link->ap->host->dev);
drivers/ata/sata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_via.c:	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
drivers/ata/sata_via.c:	void __iomem * const * iomap = ap->host->iomap;
drivers/ata/sata_via.c:	host->ports[0]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 0);
drivers/ata/sata_via.c:	host->ports[1]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 1);
drivers/ata/sata_via.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_via.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/sata_via.c:		vt6421_init_addrs(host->ports[i]);
drivers/ata/sata_via.c:	for (i = 0; i < host->n_ports; i++)
drivers/ata/sata_via.c:		ata_slave_link_init(host->ports[i]);
drivers/ata/sata_vsc.c:	mask_addr = ap->host->iomap[VSC_MMIO_BAR] +
drivers/ata/sata_vsc.c:	mask_addr = ap->host->iomap[VSC_MMIO_BAR] +
drivers/ata/sata_vsc.c:	mask_addr = ap->host->iomap[VSC_MMIO_BAR] +
drivers/ata/sata_vsc.c:	status = readl(host->iomap[VSC_MMIO_BAR] + VSC_SATA_INT_STAT_OFFSET);
drivers/ata/sata_vsc.c:			dev_err(host->dev,
drivers/ata/sata_vsc.c:	spin_lock(&host->lock);
drivers/ata/sata_vsc.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_vsc.c:			vsc_port_intr(port_status, host->ports[i]);
drivers/ata/sata_vsc.c:	spin_unlock(&host->lock);
drivers/ata/sata_vsc.c:	host->iomap = pcim_iomap_table(pdev);
drivers/ata/sata_vsc.c:	mmio_base = host->iomap[VSC_MMIO_BAR];
drivers/ata/sata_vsc.c:	for (i = 0; i < host->n_ports; i++) {
drivers/ata/sata_vsc.c:		struct ata_port *ap = host->ports[i];
drivers/atm/ambassador.c:  pointer to a descriptor containing details of the host-based queues
drivers/atm/ambassador.c:  All queues are host-based circular queues. They are contiguous and
drivers/atm/ambassador.c:  Each TX supply item contains a unique, host-supplied handle (the skb
drivers/atm/ambassador.c:  RX supply items consist of a unique, host-supplied handle (the skb
drivers/bcma/driver_pci.c:		/* This bcma device is not on a PCI host-bus. So the IRQs are
drivers/bcma/driver_pci_host.c:	pc = pc_host->pdev;
drivers/bcma/driver_pci_host.c:	spin_lock_irqsave(&pc_host->cfgspace_lock, flags);
drivers/bcma/driver_pci_host.c:	spin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);
drivers/bcma/driver_pci_host.c:	pc = pc_host->pdev;
drivers/bcma/driver_pci_host.c:	spin_lock_irqsave(&pc_host->cfgspace_lock, flags);
drivers/bcma/driver_pci_host.c:	spin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);
drivers/bcma/driver_pci_host.c:	pc_host->pci_controller.io_resource = &pc_host->io_resource;
drivers/bcma/driver_pci_host.c:	pc_host->pci_controller.mem_resource = &pc_host->mem_resource;
drivers/bcma/driver_pci_host.c:	pc_host->pci_controller.pci_ops = &pc_host->pci_ops;
drivers/bcma/driver_pci_host.c:	pc_host->pdev = pc;
drivers/bcma/driver_pci_host.c:	pc_host->host_cfg_addr = BCMA_SOC_PCI_CFG;
drivers/bcma/driver_pci_host.c:	pc_host->pci_ops.read = bcma_core_pci_hostmode_read_config;
drivers/bcma/driver_pci_host.c:	pc_host->pci_ops.write = bcma_core_pci_hostmode_write_config;
drivers/bcma/driver_pci_host.c:	pc_host->mem_resource.name = "BCMA PCIcore external memory",
drivers/bcma/driver_pci_host.c:	pc_host->mem_resource.start = BCMA_SOC_PCI_DMA;
drivers/bcma/driver_pci_host.c:	pc_host->mem_resource.end = BCMA_SOC_PCI_DMA + BCMA_SOC_PCI_DMA_SZ - 1;
drivers/bcma/driver_pci_host.c:	pc_host->mem_resource.flags = IORESOURCE_MEM | IORESOURCE_PCI_FIXED;
drivers/bcma/driver_pci_host.c:	pc_host->io_resource.name = "BCMA PCIcore external I/O",
drivers/bcma/driver_pci_host.c:	pc_host->io_resource.start = 0x100;
drivers/bcma/driver_pci_host.c:	pc_host->io_resource.end = 0x7FF;
drivers/bcma/driver_pci_host.c:	pc_host->io_resource.flags = IORESOURCE_IO | IORESOURCE_PCI_FIXED;
drivers/bcma/driver_pci_host.c:		pc_host->mem_resource.start = BCMA_SOC_PCI_MEM;
drivers/bcma/driver_pci_host.c:		pc_host->mem_resource.end = BCMA_SOC_PCI_MEM +
drivers/bcma/driver_pci_host.c:			pc_host->mem_resource.start = BCMA_SOC_PCI_MEM;
drivers/bcma/driver_pci_host.c:			pc_host->mem_resource.end = BCMA_SOC_PCI_MEM +
drivers/bcma/driver_pci_host.c:			pc_host->mem_resource.start = BCMA_SOC_PCI1_MEM;
drivers/bcma/driver_pci_host.c:			pc_host->mem_resource.end = BCMA_SOC_PCI1_MEM +
drivers/bcma/driver_pci_host.c:			pc_host->host_cfg_addr = BCMA_SOC_PCI1_CFG;
drivers/bcma/driver_pci_host.c:	pc_host->pci_controller.io_map_base = io_map_base;
drivers/bcma/driver_pci_host.c:	set_io_port_base(pc_host->pci_controller.io_map_base);
drivers/bcma/driver_pci_host.c:	register_pci_controller(&pc_host->pci_controller);
drivers/bcma/driver_pci_host.c:	dev->irq = bcma_core_mips_irq(pc_host->pdev->core) + 2;
drivers/bcma/driver_pci_host.c:	return bcma_core_mips_irq(pc_host->pdev->core) + 2;
drivers/block/cciss_scsi.c:	h = (ctlr_info_t *) cmd->device->host->hostdata[0];
drivers/block/cciss_scsi.c: * complaining.  Doing a host- or bus-reset can't do anything good here. 
drivers/block/cciss_scsi.c:	h = (ctlr_info_t *) scsicmd->device->host->hostdata[0];
drivers/block/cciss_scsi.c:	h = (ctlr_info_t *) scsicmd->device->host->hostdata[0];
drivers/block/cpqarray.c:		if (!capable(CAP_SYS_ADMIN) && drv != host->drv)
drivers/block/cpqarray.c:	host->usage_count++;
drivers/block/cpqarray.c:	host->usage_count--;
drivers/block/cpqarray.c:		error = ida_ctlr_ioctl(host, drv - host->drv, my_io);
drivers/block/cpqarray.c:		if (put_user(host->ctlr_sig, (int __user *)arg))
drivers/block/cpqarray.c:		pciinfo.bus = host->pci_dev->bus->number;
drivers/block/cpqarray.c:		pciinfo.dev_fn = host->pci_dev->devfn;
drivers/block/cpqarray.c:		pciinfo.board_id = host->board_id;
drivers/block/cpqarray.c:	int ctlr = host->ctlr;
drivers/block/cpqarray.c:	if (host->usage_count > 1) {
drivers/block/cpqarray.c:			" revalidation (usage=%d)\n", host->usage_count);
drivers/block/cpqarray.c:	host->usage_count++;
drivers/block/cpqarray.c:	memset(host->drv, 0, sizeof(drv_info_t)*NWD);
drivers/block/cpqarray.c:	host->access.set_intr_mask(host, 0);
drivers/block/cpqarray.c:	host->access.set_intr_mask(host, FIFO_NOT_EMPTY);
drivers/block/cpqarray.c:		drv_info_t *drv = &host->drv[i];
drivers/block/cpqarray.c:		blk_queue_logical_block_size(host->queue, drv->blk_size);
drivers/block/cpqarray.c:		disk->queue = host->queue;
drivers/block/cpqarray.c:	host->usage_count--;
drivers/block/loop.c:	lo->lo_blocksize = S_ISBLK(mapping->host->i_mode) ?
drivers/block/loop.c:		mapping->host->i_bdev->bd_block_size : PAGE_SIZE;
drivers/block/loop.c:		if (f->f_mapping->host->i_bdev == bdev)
drivers/block/loop.c:		l = f->f_mapping->host->i_bdev->bd_disk->private_data;
drivers/block/mg_disk.c:	if (__blk_end_request(host->req, err, nr_bytes))
drivers/block/mg_disk.c:	host->req = NULL;
drivers/block/mg_disk.c:	return mg_end_request(host, err, blk_rq_cur_bytes(host->req));
drivers/block/mg_disk.c:	if (host->req)
drivers/block/mg_disk.c:		name = host->req->rq_disk->disk_name;
drivers/block/mg_disk.c:		host->error = 0;
drivers/block/mg_disk.c:		host->error = inb((unsigned long)host->dev_base + MG_REG_ERROR);
drivers/block/mg_disk.c:				host->error & 0xff);
drivers/block/mg_disk.c:		if (host->error & ATA_BBK)
drivers/block/mg_disk.c:		if (host->error & ATA_UNC)
drivers/block/mg_disk.c:		if (host->error & ATA_IDNF)
drivers/block/mg_disk.c:		if (host->error & ATA_ABORTED)
drivers/block/mg_disk.c:		if (host->error & ATA_AMNF)
drivers/block/mg_disk.c:		if (host->error & (ATA_BBK | ATA_UNC | ATA_IDNF | ATA_AMNF)) {
drivers/block/mg_disk.c:			if (host->req)
drivers/block/mg_disk.c:				       (unsigned int)blk_rq_pos(host->req));
drivers/block/mg_disk.c:	struct mg_drv_data *prv_data = host->dev->platform_data;
drivers/block/mg_disk.c:	host->error = MG_ERR_NONE;
drivers/block/mg_disk.c:		status = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:		status = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:	status = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:		status = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:		host->error = MG_ERR_TIMEOUT;
drivers/block/mg_disk.c:	return host->error;
drivers/block/mg_disk.c:	u32 status = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:	void (*handler)(struct mg_host *) = host->mg_do_intr;
drivers/block/mg_disk.c:	spin_lock(&host->lock);
drivers/block/mg_disk.c:	host->mg_do_intr = NULL;
drivers/block/mg_disk.c:	del_timer(&host->timer);
drivers/block/mg_disk.c:	spin_unlock(&host->lock);
drivers/block/mg_disk.c:	const u16 *id = host->id;
drivers/block/mg_disk.c:	struct mg_drv_data *prv_data = host->dev->platform_data;
drivers/block/mg_disk.c:		outb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	outb(MG_CMD_ID, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:		host->id[i] = le16_to_cpu(inw((unsigned long)host->dev_base +
drivers/block/mg_disk.c:	outb(MG_CMD_RD_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:	host->n_sectors = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
drivers/block/mg_disk.c:	host->cyls = id[ATA_ID_CYLS];
drivers/block/mg_disk.c:	host->heads = id[ATA_ID_HEADS];
drivers/block/mg_disk.c:	host->sectors = id[ATA_ID_SECTORS];
drivers/block/mg_disk.c:	if (MG_RES_SEC && host->heads && host->sectors) {
drivers/block/mg_disk.c:		host->cyls = (host->n_sectors - MG_RES_SEC) /
drivers/block/mg_disk.c:			host->heads / host->sectors;
drivers/block/mg_disk.c:		host->nres_sectors = host->n_sectors - host->cyls *
drivers/block/mg_disk.c:			host->heads * host->sectors;
drivers/block/mg_disk.c:		host->n_sectors -= host->nres_sectors;
drivers/block/mg_disk.c:			host->n_sectors, host->nres_sectors);
drivers/block/mg_disk.c:		outb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	struct mg_drv_data *prv_data = host->dev->platform_data;
drivers/block/mg_disk.c:	gpio_set_value(host->rst, 0);
drivers/block/mg_disk.c:	gpio_set_value(host->rst, 1);
drivers/block/mg_disk.c:			(unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:			(unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	init_status = inb((unsigned long)host->dev_base + MG_REG_STATUS) & 0xf;
drivers/block/mg_disk.c:	if (host->req)
drivers/block/mg_disk.c:		if (++host->req->errors >= MG_MAX_ERRORS ||
drivers/block/mg_disk.c:		    host->error == MG_ERR_TIMEOUT)
drivers/block/mg_disk.c:	struct mg_drv_data *prv_data = host->dev->platform_data;
drivers/block/mg_disk.c:		return host->error;
drivers/block/mg_disk.c:		host->mg_do_intr = intr_addr;
drivers/block/mg_disk.c:		mod_timer(&host->timer, jiffies + 3 * HZ);
drivers/block/mg_disk.c:	outb((u8)sect_cnt, (unsigned long)host->dev_base + MG_REG_SECT_CNT);
drivers/block/mg_disk.c:	outb((u8)sect_num, (unsigned long)host->dev_base + MG_REG_SECT_NUM);
drivers/block/mg_disk.c:	outb((u8)(sect_num >> 8), (unsigned long)host->dev_base +
drivers/block/mg_disk.c:	outb((u8)(sect_num >> 16), (unsigned long)host->dev_base +
drivers/block/mg_disk.c:			(unsigned long)host->dev_base + MG_REG_DRV_HEAD);
drivers/block/mg_disk.c:	outb(cmd, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:		*buff++ = inw((unsigned long)host->dev_base + MG_BUFF_OFFSET +
drivers/block/mg_disk.c:		outb(MG_CMD_RD_CONF, (unsigned long)host->dev_base +
drivers/block/mg_disk.c:		outw(*buff++, (unsigned long)host->dev_base + MG_BUFF_OFFSET +
drivers/block/mg_disk.c:		outb(MG_CMD_WR_CONF, (unsigned long)host->dev_base +
drivers/block/mg_disk.c:	struct request *req = host->req;
drivers/block/mg_disk.c:		i = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:	mg_request(host->breq);
drivers/block/mg_disk.c:	outb(MG_CMD_RD_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:		host->mg_do_intr = mg_read_intr;
drivers/block/mg_disk.c:		mod_timer(&host->timer, jiffies + 3 * HZ);
drivers/block/mg_disk.c:		mg_request(host->breq);
drivers/block/mg_disk.c:	struct request *req = host->req;
drivers/block/mg_disk.c:		i = inb((unsigned long)host->dev_base + MG_REG_STATUS);
drivers/block/mg_disk.c:	mg_request(host->breq);
drivers/block/mg_disk.c:		host->mg_do_intr = mg_write_intr;
drivers/block/mg_disk.c:		mod_timer(&host->timer, jiffies + 3 * HZ);
drivers/block/mg_disk.c:	outb(MG_CMD_WR_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:		mg_request(host->breq);
drivers/block/mg_disk.c:	spin_lock_irq(&host->lock);
drivers/block/mg_disk.c:	if (!host->req)
drivers/block/mg_disk.c:	host->mg_do_intr = NULL;
drivers/block/mg_disk.c:	name = host->req->rq_disk->disk_name;
drivers/block/mg_disk.c:	host->error = MG_ERR_TIMEOUT;
drivers/block/mg_disk.c:	mg_request(host->breq);
drivers/block/mg_disk.c:	spin_unlock_irq(&host->lock);
drivers/block/mg_disk.c:		if (!host->req) {
drivers/block/mg_disk.c:			host->req = blk_fetch_request(q);
drivers/block/mg_disk.c:			if (!host->req)
drivers/block/mg_disk.c:		if (unlikely(host->req->cmd_type != REQ_TYPE_FS)) {
drivers/block/mg_disk.c:		if (rq_data_dir(host->req) == READ)
drivers/block/mg_disk.c:			mg_read(host->req);
drivers/block/mg_disk.c:			mg_write(host->req);
drivers/block/mg_disk.c:			return host->error;
drivers/block/mg_disk.c:		outb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:			return host->error;
drivers/block/mg_disk.c:		del_timer(&host->timer);
drivers/block/mg_disk.c:		outb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:		if (host->error) {
drivers/block/mg_disk.c:			return host->error;
drivers/block/mg_disk.c:		mod_timer(&host->timer, jiffies + 3 * HZ);
drivers/block/mg_disk.c:		outb(MG_CMD_WR_CONF, (unsigned long)host->dev_base +
drivers/block/mg_disk.c:		if (!host->req) {
drivers/block/mg_disk.c:			host->req = blk_fetch_request(q);
drivers/block/mg_disk.c:			if (!host->req)
drivers/block/mg_disk.c:		req = host->req;
drivers/block/mg_disk.c:		if (host->mg_do_intr)
drivers/block/mg_disk.c:		del_timer(&host->timer);
drivers/block/mg_disk.c:	geo->cylinders = (unsigned short)host->cyls;
drivers/block/mg_disk.c:	geo->heads = (unsigned char)host->heads;
drivers/block/mg_disk.c:	geo->sectors = (unsigned char)host->sectors;
drivers/block/mg_disk.c:		outb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	outb(MG_CMD_SLEEP, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:			outb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	outb(MG_CMD_WAKEUP, (unsigned long)host->dev_base + MG_REG_COMMAND);
drivers/block/mg_disk.c:		outb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);
drivers/block/mg_disk.c:	host->major = MG_DISK_MAJ;
drivers/block/mg_disk.c:	host->dev = &plat_dev->dev;
drivers/block/mg_disk.c:	host->dev_base = ioremap(rsc->start, resource_size(rsc));
drivers/block/mg_disk.c:	if (!host->dev_base) {
drivers/block/mg_disk.c:	MG_DBG("dev_base = 0x%x\n", (u32)host->dev_base);
drivers/block/mg_disk.c:	host->rst = rsc->start;
drivers/block/mg_disk.c:	err = gpio_request(host->rst, MG_RST_PIN);
drivers/block/mg_disk.c:	gpio_direction_output(host->rst, 1);
drivers/block/mg_disk.c:		host->rstout = rsc->start;
drivers/block/mg_disk.c:		err = gpio_request(host->rstout, MG_RSTOUT_PIN);
drivers/block/mg_disk.c:		gpio_direction_input(host->rstout);
drivers/block/mg_disk.c:		err = mg_wait_rstout(host->rstout, MG_TMAX_RSTOUT);
drivers/block/mg_disk.c:		host->irq = platform_get_irq(plat_dev, 0);
drivers/block/mg_disk.c:		if (host->irq == -ENXIO) {
drivers/block/mg_disk.c:			err = host->irq;
drivers/block/mg_disk.c:		err = request_irq(host->irq, mg_irq,
drivers/block/mg_disk.c:	err = register_blkdev(host->major, MG_DISK_NAME);
drivers/block/mg_disk.c:	if (!host->major)
drivers/block/mg_disk.c:		host->major = err;
drivers/block/mg_disk.c:	spin_lock_init(&host->lock);
drivers/block/mg_disk.c:		host->breq = blk_init_queue(mg_request_poll, &host->lock);
drivers/block/mg_disk.c:		host->breq = blk_init_queue(mg_request, &host->lock);
drivers/block/mg_disk.c:	if (!host->breq) {
drivers/block/mg_disk.c:	host->breq->queuedata = host;
drivers/block/mg_disk.c:	err = elevator_change(host->breq, "noop");
drivers/block/mg_disk.c:	blk_queue_max_hw_sectors(host->breq, MG_MAX_SECTS);
drivers/block/mg_disk.c:	blk_queue_logical_block_size(host->breq, MG_SECTOR_SIZE);
drivers/block/mg_disk.c:	init_timer(&host->timer);
drivers/block/mg_disk.c:	host->timer.function = mg_times_out;
drivers/block/mg_disk.c:	host->timer.data = (unsigned long)host;
drivers/block/mg_disk.c:	host->gd = alloc_disk(MG_DISK_MAX_PART);
drivers/block/mg_disk.c:	if (!host->gd) {
drivers/block/mg_disk.c:	host->gd->major = host->major;
drivers/block/mg_disk.c:	host->gd->first_minor = 0;
drivers/block/mg_disk.c:	host->gd->fops = &mg_disk_ops;
drivers/block/mg_disk.c:	host->gd->queue = host->breq;
drivers/block/mg_disk.c:	host->gd->private_data = host;
drivers/block/mg_disk.c:	sprintf(host->gd->disk_name, MG_DISK_NAME"a");
drivers/block/mg_disk.c:	set_capacity(host->gd, host->n_sectors);
drivers/block/mg_disk.c:	add_disk(host->gd);
drivers/block/mg_disk.c:	del_timer_sync(&host->timer);
drivers/block/mg_disk.c:	blk_cleanup_queue(host->breq);
drivers/block/mg_disk.c:		free_irq(host->irq, host);
drivers/block/mg_disk.c:	gpio_free(host->rstout);
drivers/block/mg_disk.c:	gpio_free(host->rst);
drivers/block/mg_disk.c:	iounmap(host->dev_base);
drivers/block/mg_disk.c:	del_timer_sync(&host->timer);
drivers/block/mg_disk.c:	if (host->gd) {
drivers/block/mg_disk.c:		del_gendisk(host->gd);
drivers/block/mg_disk.c:		put_disk(host->gd);
drivers/block/mg_disk.c:	if (host->breq)
drivers/block/mg_disk.c:		blk_cleanup_queue(host->breq);
drivers/block/mg_disk.c:	unregister_blkdev(host->major, MG_DISK_NAME);
drivers/block/mg_disk.c:		free_irq(host->irq, host);
drivers/block/mg_disk.c:		gpio_free(host->rstout);
drivers/block/mg_disk.c:	if (host->rst)
drivers/block/mg_disk.c:		gpio_free(host->rst);
drivers/block/mg_disk.c:	if (host->dev_base)
drivers/block/mg_disk.c:		iounmap(host->dev_base);
drivers/block/sx8.c:	/* S/G limits, host-wide and per-request */
drivers/block/sx8.c:	return host->msg_base + (msg_idx * CARM_MSG_SIZE);
drivers/block/sx8.c:	return host->msg_dma + (msg_idx * CARM_MSG_SIZE);
drivers/block/sx8.c:	void __iomem *mmio = host->mmio;
drivers/block/sx8.c:	if (host->hw_sg_used >= (CARM_MAX_HOST_SG - CARM_MAX_REQ_SG))
drivers/block/sx8.c:		if ((host->msg_alloc & (1ULL << i)) == 0) {
drivers/block/sx8.c:			struct carm_request *crq = &host->req[i];
drivers/block/sx8.c:			host->msg_alloc |= (1ULL << i);
drivers/block/sx8.c:			host->n_msgs++;
drivers/block/sx8.c:			assert(host->n_msgs <= CARM_MAX_REQ);
drivers/block/sx8.c:	if (unlikely((host->msg_alloc & (1ULL << crq->tag)) == 0))
drivers/block/sx8.c:	assert(host->hw_sg_used >= crq->n_elem);
drivers/block/sx8.c:	host->msg_alloc &= ~(1ULL << crq->tag);
drivers/block/sx8.c:	host->hw_sg_used -= crq->n_elem;
drivers/block/sx8.c:	host->n_msgs--;
drivers/block/sx8.c:		spin_lock_irqsave(&host->lock, flags);
drivers/block/sx8.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/block/sx8.c:	rq = blk_get_request(host->oob_q, WRITE /* bogus */, GFP_KERNEL);
drivers/block/sx8.c:		spin_lock_irqsave(&host->lock, flags);
drivers/block/sx8.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/block/sx8.c:	spin_lock_irq(&host->lock);
drivers/block/sx8.c:	assert(host->state == HST_DEV_SCAN_START ||
drivers/block/sx8.c:	       host->state == HST_DEV_SCAN);
drivers/block/sx8.c:	spin_unlock_irq(&host->lock);
drivers/block/sx8.c:	blk_execute_rq_nowait(host->oob_q, NULL, crq->rq, true, NULL);
drivers/block/sx8.c:	spin_lock_irq(&host->lock);
drivers/block/sx8.c:	host->state = HST_ERROR;
drivers/block/sx8.c:	spin_unlock_irq(&host->lock);
drivers/block/sx8.c:	blk_execute_rq_nowait(host->oob_q, NULL, crq->rq, true, NULL);
drivers/block/sx8.c:	ab->addr	= cpu_to_le32(host->shm_dma + (PDC_SHM_SIZE >> 1));
drivers/block/sx8.c:	ab->evt_pool	= cpu_to_le32(host->shm_dma + (16 * 1024));
drivers/block/sx8.c:	ab->rbuf_pool	= cpu_to_le32(host->shm_dma);
drivers/block/sx8.c:	ab->msg_pool	= cpu_to_le32(host->shm_dma + RBUF_LEN);
drivers/block/sx8.c:	ab->sg[0].start	= cpu_to_le32(host->shm_dma + (PDC_SHM_SIZE >> 1));
drivers/block/sx8.c:	unsigned int idx = host->wait_q_prod % CARM_MAX_WAIT_Q;
drivers/block/sx8.c:	host->wait_q[idx] = q;
drivers/block/sx8.c:	host->wait_q_prod++;
drivers/block/sx8.c:	BUG_ON(host->wait_q_prod == host->wait_q_cons); /* overrun */
drivers/block/sx8.c:	if (host->wait_q_prod == host->wait_q_cons)
drivers/block/sx8.c:	idx = host->wait_q_cons % CARM_MAX_WAIT_Q;
drivers/block/sx8.c:	host->wait_q_cons++;
drivers/block/sx8.c:	return host->wait_q[idx];
drivers/block/sx8.c:	else if ((host->n_msgs <= CARM_MSG_LOW_WATER) &&
drivers/block/sx8.c:		 (host->hw_sg_used <= CARM_SG_LOW_WATER)) {
drivers/block/sx8.c:	n_elem = pci_map_sg(host->pdev, sg, n_elem, pci_dir);
drivers/block/sx8.c:	host->hw_sg_used += n_elem;
drivers/block/sx8.c:	cur_port = host->cur_scan_dev;
drivers/block/sx8.c:	port = &host->port[cur_port];
drivers/block/sx8.c:	host->dev_active |= (1 << cur_port);
drivers/block/sx8.c:	       pci_name(host->pdev), port->port_no,
drivers/block/sx8.c:	       pci_name(host->pdev), port->port_no, port->name);
drivers/block/sx8.c:	assert(host->state == HST_DEV_SCAN);
drivers/block/sx8.c:	schedule_work(&host->fsm_task);
drivers/block/sx8.c:			host->dev_present |= (1 << i);
drivers/block/sx8.c:	       pci_name(host->pdev), dev_count);
drivers/block/sx8.c:	assert(host->state == HST_PORT_SCAN);
drivers/block/sx8.c:	host->state = new_state;
drivers/block/sx8.c:	schedule_work(&host->fsm_task);
drivers/block/sx8.c:	assert(host->state == cur_state);
drivers/block/sx8.c:		host->state = HST_ERROR;
drivers/block/sx8.c:		host->state = next_state;
drivers/block/sx8.c:	schedule_work(&host->fsm_task);
drivers/block/sx8.c:	pci_unmap_sg(host->pdev, &crq->sg[0], crq->n_elem, pci_dir);
drivers/block/sx8.c:		       pci_name(host->pdev), handle);
drivers/block/sx8.c:	crq = &host->req[msg_idx];
drivers/block/sx8.c:				host->fw_ver = le32_to_cpu(ver->version);
drivers/block/sx8.c:				host->flags |= (ver->features & FL_FW_VER_MASK);
drivers/block/sx8.c:	       pci_name(host->pdev), crq->msg_type, crq->msg_subtype);
drivers/block/sx8.c:	void __iomem *mmio = host->mmio;
drivers/block/sx8.c:	struct carm_response *resp = (struct carm_response *) host->shm;
drivers/block/sx8.c:	unsigned int idx = host->resp_idx % RMSG_Q_LEN;
drivers/block/sx8.c:			       pci_name(host->pdev), (int) evt_type);
drivers/block/sx8.c:	host->resp_idx += work;
drivers/block/sx8.c:	spin_lock_irqsave(&host->lock, flags);
drivers/block/sx8.c:	mmio = host->mmio;
drivers/block/sx8.c:	if (unlikely(host->state == HST_INVALID)) {
drivers/block/sx8.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/block/sx8.c:	spin_lock_irqsave(&host->lock, flags);
drivers/block/sx8.c:	state = host->state;
drivers/block/sx8.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/block/sx8.c:		host->cur_scan_dev = -1;
drivers/block/sx8.c:		for (i = host->cur_scan_dev + 1; i < CARM_MAX_PORTS; i++)
drivers/block/sx8.c:			if (host->dev_present & (1 << i)) {
drivers/block/sx8.c:			host->cur_scan_dev = next_dev;
drivers/block/sx8.c:			if (host->dev_active & (1 << i)) {
drivers/block/sx8.c:				struct carm_port *port = &host->port[i];
drivers/block/sx8.c:		       pci_name(host->pdev), activated);
drivers/block/sx8.c:		complete(&host->probe_comp);
drivers/block/sx8.c:		spin_lock_irqsave(&host->lock, flags);
drivers/block/sx8.c:		host->state = new_state;
drivers/block/sx8.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/block/sx8.c:		schedule_work(&host->fsm_task);
drivers/block/sx8.c:	void __iomem *mmio = host->mmio;
drivers/block/sx8.c:	struct carm_response *resp = (struct carm_response *) host->shm;
drivers/block/sx8.c:	void __iomem *mmio = host->mmio;
drivers/block/sx8.c:	writel(host->shm_dma & 0xffffffff, mmio + RBUF_ADDR_LO);
drivers/block/sx8.c:	writel((host->shm_dma >> 16) >> 16, mmio + RBUF_ADDR_HI);
drivers/block/sx8.c:	spin_lock_irq(&host->lock);
drivers/block/sx8.c:	assert(host->state == HST_INVALID);
drivers/block/sx8.c:	host->state = HST_PROBE_START;
drivers/block/sx8.c:	spin_unlock_irq(&host->lock);
drivers/block/sx8.c:	schedule_work(&host->fsm_task);
drivers/block/sx8.c:		port = &host->port[i];
drivers/block/sx8.c:			(unsigned int) (host->id * CARM_MAX_PORTS) + i);
drivers/block/sx8.c:		disk->major = host->major;
drivers/block/sx8.c:		q = blk_init_queue(carm_rq_fn, &host->lock);
drivers/block/sx8.c:		struct gendisk *disk = host->port[i].disk;
drivers/block/sx8.c:	host->shm = pci_alloc_consistent(host->pdev, CARM_SHM_SIZE,
drivers/block/sx8.c:					 &host->shm_dma);
drivers/block/sx8.c:	if (!host->shm)
drivers/block/sx8.c:	host->msg_base = host->shm + RBUF_LEN;
drivers/block/sx8.c:	host->msg_dma = host->shm_dma + RBUF_LEN;
drivers/block/sx8.c:	memset(host->shm, 0xff, RBUF_LEN);
drivers/block/sx8.c:	memset(host->msg_base, 0, PDC_SHM_SIZE - RBUF_LEN);
drivers/block/sx8.c:	host->pdev = pdev;
drivers/block/sx8.c:	host->flags = pci_dac ? FL_DAC : 0;
drivers/block/sx8.c:	spin_lock_init(&host->lock);
drivers/block/sx8.c:	INIT_WORK(&host->fsm_task, carm_fsm_task);
drivers/block/sx8.c:	init_completion(&host->probe_comp);
drivers/block/sx8.c:	for (i = 0; i < ARRAY_SIZE(host->req); i++)
drivers/block/sx8.c:		host->req[i].tag = i;
drivers/block/sx8.c:	host->mmio = ioremap(pci_resource_start(pdev, 0),
drivers/block/sx8.c:	if (!host->mmio) {
drivers/block/sx8.c:	q = blk_init_queue(carm_oob_rq_fn, &host->lock);
drivers/block/sx8.c:	host->oob_q = q;
drivers/block/sx8.c:		host->major = 160;
drivers/block/sx8.c:		host->major = 161;
drivers/block/sx8.c:		host->flags |= FL_DYN_MAJOR;
drivers/block/sx8.c:	host->id = carm_host_id;
drivers/block/sx8.c:	sprintf(host->name, DRV_NAME "%d", carm_host_id);
drivers/block/sx8.c:	rc = register_blkdev(host->major, host->name);
drivers/block/sx8.c:	if (host->flags & FL_DYN_MAJOR)
drivers/block/sx8.c:		host->major = rc;
drivers/block/sx8.c:	wait_for_completion(&host->probe_comp);
drivers/block/sx8.c:	       host->name, pci_name(pdev), (int) CARM_MAX_PORTS,
drivers/block/sx8.c:		   pdev->irq, host->major);
drivers/block/sx8.c:	unregister_blkdev(host->major, host->name);
drivers/block/sx8.c:	if (host->major == 160)
drivers/block/sx8.c:	else if (host->major == 161)
drivers/block/sx8.c:	blk_cleanup_queue(host->oob_q);
drivers/block/sx8.c:	pci_free_consistent(pdev, CARM_SHM_SIZE, host->shm, host->shm_dma);
drivers/block/sx8.c:	iounmap(host->mmio);
drivers/block/sx8.c:	unregister_blkdev(host->major, host->name);
drivers/block/sx8.c:	if (host->major == 160)
drivers/block/sx8.c:	else if (host->major == 161)
drivers/block/sx8.c:	blk_cleanup_queue(host->oob_q);
drivers/block/sx8.c:	pci_free_consistent(pdev, CARM_SHM_SIZE, host->shm, host->shm_dma);
drivers/block/sx8.c:	iounmap(host->mmio);
drivers/bluetooth/hci_ath.c:					 "host-wake-gpio", 0);
drivers/char/ps3flash.c:	mutex_lock(&file->f_mapping->host->i_mutex);
drivers/char/ps3flash.c:	mutex_unlock(&file->f_mapping->host->i_mutex);
drivers/char/virtio_console.c:	 * guest->host transfers, one for host->guest transfers
drivers/dma/amba-pl08x.c:		pl08x_select_bus(chan->cd->periph_buses, chan->host->mem_buses);
drivers/dma/amba-pl08x.c:		pl08x_select_bus(chan->host->mem_buses, chan->cd->periph_buses);
drivers/edac/ppc4xx_edac.c:	return __mfdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,
drivers/edac/ppc4xx_edac.c:			dcr_host->base + SDRAM_DCR_DATA_OFFSET,
drivers/edac/ppc4xx_edac.c:	return __mtdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,
drivers/edac/ppc4xx_edac.c:			dcr_host->base + SDRAM_DCR_DATA_OFFSET,
drivers/firewire/sbp2.c: * the section might clash with shost->host_lock.
drivers/firewire/sbp2.c: * the section might clash with shost->host_lock.
drivers/firewire/sbp2.c:	tgt = (struct sbp2_target *)shost->hostdata;
drivers/firewire/sbp2.c:	shost->max_cmd_len = SBP2_MAX_CDB_SIZE;
drivers/firewire/sbp2.c:	dev_notice(dev, "released target %d:0:0\n", shost->host_no);
drivers/gpu/drm/vmwgfx/svga_reg.h: *    This is a host-to-guest blit. It performs a DMA operation to
drivers/gpu/drm/vmwgfx/svga_reg.h: *    Note that our guest-to-host blits and host-to-guest blits aren't
drivers/gpu/drm/vmwgfx/svga_reg.h: *    are identical, host-to-guest blits are a lot less featureful.
drivers/hv/hv_kvp.c:		 * terminate the current  host-side iteration.
drivers/ide/aec62xx.c:	struct chipset_bus_clock_list_entry *bus_clock = host->host_priv;
drivers/ide/aec62xx.c:	struct chipset_bus_clock_list_entry *bus_clock = host->host_priv;
drivers/ide/au1xxx-ide.c:	auide_hwif.hwif = host->ports[0];
drivers/ide/cy82c693.c:	struct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;
drivers/ide/delkin_cb.c:	if (host->init_chipset)
drivers/ide/delkin_cb.c:		host->init_chipset(dev);
drivers/ide/hpt366.c:	struct hpt_info *info	= (struct hpt_info *)host->host_priv;
drivers/ide/hpt366.c:	return dev == host->dev[1] ? info + 1 : info;
drivers/ide/hpt366.c:	struct hpt_info *info	= host->host_priv + (&dev->dev == host->dev[1]);
drivers/ide/hpt366.c:		hwif->host->host_flags |= IDE_HFLAG_SERIALIZE;
drivers/ide/hpt366.c:	struct ide_info *info = host->host_priv;
drivers/ide/hpt366.c:	struct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;
drivers/ide/ide-cs.c:    hwif = host->ports[0];
drivers/ide/ide-cs.c:	    'a' + host->ports[0]->index * 2,
drivers/ide/ide-cs.c:	ide_hwif_t *hwif = host->ports[0];
drivers/ide/ide-io.c:	if (host->host_flags & IDE_HFLAG_SERIALIZE) {
drivers/ide/ide-io.c:		rc = test_and_set_bit_lock(IDE_HOST_BUSY, &host->host_busy);
drivers/ide/ide-io.c:			if (host->get_lock)
drivers/ide/ide-io.c:				host->get_lock(ide_intr, hwif);
drivers/ide/ide-io.c:	if (host->host_flags & IDE_HFLAG_SERIALIZE) {
drivers/ide/ide-io.c:		if (host->release_lock)
drivers/ide/ide-io.c:			host->release_lock();
drivers/ide/ide-io.c:		clear_bit_unlock(IDE_HOST_BUSY, &host->host_busy);
drivers/ide/ide-io.c:		prev_port = hwif->host->cur_port;
drivers/ide/ide-io.c:		if ((hwif->host->host_flags & IDE_HFLAG_SERIALIZE) &&
drivers/ide/ide-io.c:			hwif->host->cur_port = hwif;
drivers/ide/ide-io.c:	if (host->host_flags & IDE_HFLAG_SERIALIZE) {
drivers/ide/ide-io.c:		if (hwif != host->cur_port)
drivers/ide/ide-io.c:		if ((host->irq_flags & IRQF_SHARED) == 0) {
drivers/ide/ide-probe.c:	irq_handler_t irq_handler = host->irq_handler;
drivers/ide/ide-probe.c:	int sa = host->irq_flags;
drivers/ide/ide-probe.c:	if (hwif->host->host_flags & IDE_HFLAG_SERIALIZE)
drivers/ide/ide-probe.c:		hwif->host->host_flags |= IDE_HFLAG_SERIALIZE;
drivers/ide/ide-probe.c:		host->ports[i] = hwif;
drivers/ide/ide-probe.c:		host->n_ports++;
drivers/ide/ide-probe.c:	if (host->n_ports == 0) {
drivers/ide/ide-probe.c:	host->dev[0] = dev;
drivers/ide/ide-probe.c:		host->init_chipset = d->init_chipset;
drivers/ide/ide-probe.c:		host->get_lock     = d->get_lock;
drivers/ide/ide-probe.c:		host->release_lock = d->release_lock;
drivers/ide/ide-probe.c:		host->host_flags = d->host_flags;
drivers/ide/ide-probe.c:		host->irq_flags = d->irq_flags;
drivers/ide/ide-probe.c:		if (host->ports[i] == hwif) {
drivers/ide/ide-probe.c:			host->ports[i] = NULL;
drivers/ide/ide-probe.c:			host->n_ports--;
drivers/ide/ide.c:	host_dev = drive->hwif->host->dev[0];
drivers/ide/ide.c:	struct device *host_dev = drive->hwif->host->dev[0];
drivers/ide/it821x.c:	struct it821x_dev *itdevs = host->host_priv;
drivers/ide/it821x.c:	struct it821x_dev *itdevs = host->host_priv;
drivers/ide/pdc202xx_new.c:	struct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;
drivers/ide/pmac.c:	hwif = pmif->hwif = host->ports[0];
drivers/ide/sc1200.c:		struct sc1200_saved_state *ss = host->host_priv;
drivers/ide/sc1200.c:	struct sc1200_saved_state *ss = host->host_priv;
drivers/ide/setup-pci.c:	host->dev[0] = &dev1->dev;
drivers/ide/setup-pci.c:		host->dev[1] = &dev2->dev;
drivers/ide/setup-pci.c:	host->host_priv = priv;
drivers/ide/setup-pci.c:	host->irq_flags = IRQF_SHARED;
drivers/ide/setup-pci.c:	struct pci_dev *dev2 = host->dev[1] ? to_pci_dev(host->dev[1]) : NULL;
drivers/ide/setup-pci.c:	if (host->host_flags & IDE_HFLAG_SINGLE)
drivers/ide/setup-pci.c:	if ((host->host_flags & IDE_HFLAG_NO_DMA) == 0) {
drivers/ide/setup-pci.c:		if (host->host_flags & IDE_HFLAG_CS5520)
drivers/ide/setup-pci.c:	if (host->init_chipset)
drivers/ide/setup-pci.c:		host->init_chipset(dev);
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	void __iomem *ioaddr = host->host_priv;
drivers/ide/siimage.c:	void *addr		= host->host_priv;
drivers/ide/siimage.c:	if (host->host_priv)
drivers/ide/siimage.c:	void __iomem *ioaddr = host->host_priv;
drivers/ide/sis5513.c:			if (host->revision >= 0x30)
drivers/ide/tx4939ide.c:	host->ports[0]->extra_base = mapbase;
drivers/ide/tx4939ide.c:	ide_hwif_t *hwif = host->ports[0];
drivers/ide/via82cxxx.c:	struct via82cxxx_dev *vdev = host->host_priv;
drivers/ide/via82cxxx.c:	struct via82cxxx_dev *vdev = host->host_priv;
drivers/ide/via82cxxx.c:	struct via82cxxx_dev *vdev = host->host_priv;
drivers/ide/via82cxxx.c:	struct via82cxxx_dev *vdev = host->host_priv;
drivers/ide/via82cxxx.c:	struct via82cxxx_dev *vdev = host->host_priv;
drivers/infiniband/hw/amso1100/c2_qp.c: * Post an mq index to the host->adapter activity fifo.
drivers/infiniband/hw/amso1100/c2_qp.c: * This in-line function allocates a MQ msg, then moves the host-copy of
drivers/infiniband/hw/amso1100/c2_qp.c: * wr		- ptr to host-copy of the WR.
drivers/infiniband/hw/amso1100/c2_qp.c:		 * Create local host-copy of the WR
drivers/infiniband/hw/ipath/ipath_driver.c:			 * we have to flip to host-order first.
drivers/infiniband/hw/qib/qib_tx.c:			 * we have to flip to host-order first.
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->transportt = iscsi_iser_scsi_transport;
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->max_lun = iscsi_max_lun;
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->max_id = 0;
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->max_channel = 0;
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->max_cmd_len = 16;
drivers/infiniband/ulp/iser/iscsi_iser.c:	shost->can_queue = session->scsi_cmds_max;
drivers/infiniband/ulp/srp/ib_srp.c:	return (struct srp_target_port *) host->hostdata;
drivers/infiniband/ulp/srp/ib_srp.c:	iu->dma = ib_dma_map_single(host->srp_dev->dev, iu->buf, size,
drivers/infiniband/ulp/srp/ib_srp.c:	if (ib_dma_mapping_error(host->srp_dev->dev, iu->dma))
drivers/infiniband/ulp/srp/ib_srp.c:	ib_dma_unmap_single(host->srp_dev->dev, iu->dma, iu->size,
drivers/infiniband/ulp/srp/ib_srp.c:	ret = ib_find_pkey(target->srp_host->srp_dev->dev,
drivers/infiniband/ulp/srp/ib_srp.c:			   target->srp_host->port,
drivers/infiniband/ulp/srp/ib_srp.c:	attr->port_num        = target->srp_host->port;
drivers/infiniband/ulp/srp/ib_srp.c:	new_cm_id = ib_create_cm_id(target->srp_host->srp_dev->dev,
drivers/infiniband/ulp/srp/ib_srp.c:	target->recv_cq = ib_create_cq(target->srp_host->srp_dev->dev,
drivers/infiniband/ulp/srp/ib_srp.c:	target->send_cq = ib_create_cq(target->srp_host->srp_dev->dev,
drivers/infiniband/ulp/srp/ib_srp.c:	target->qp = ib_create_qp(target->srp_host->srp_dev->pd, init_attr);
drivers/infiniband/ulp/srp/ib_srp.c:						   target->srp_host->srp_dev->dev,
drivers/infiniband/ulp/srp/ib_srp.c:						   target->srp_host->port,
drivers/infiniband/ulp/srp/ib_srp.c:		       &target->srp_host->srp_dev->dev->node_guid, 8);
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *ibdev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	for (attr = shost->hostt->shost_attrs; attr && *attr; ++attr)
drivers/infiniband/ulp/srp/ib_srp.c:		device_remove_file(&shost->shost_dev, *attr);
drivers/infiniband/ulp/srp/ib_srp.c:	spin_lock(&target->srp_host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:	spin_unlock(&target->srp_host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *ibdev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	struct srp_device *dev = target->srp_host->srp_dev;
drivers/infiniband/ulp/srp/ib_srp.c:	struct srp_device *dev = target->srp_host->srp_dev;
drivers/infiniband/ulp/srp/ib_srp.c:	dev = target->srp_host->srp_dev;
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *dev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *dev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	dev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:		target->scsi_host->can_queue
drivers/infiniband/ulp/srp/ib_srp.c:			      target->scsi_host->can_queue);
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *dev = target->srp_host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	return sprintf(buf, "%d\n", target->srp_host->port);
drivers/infiniband/ulp/srp/ib_srp.c:	return sprintf(buf, "%s\n", target->srp_host->srp_dev->dev->name);
drivers/infiniband/ulp/srp/ib_srp.c:	if (scsi_add_host(target->scsi_host, host->srp_dev->dev->dma_device))
drivers/infiniband/ulp/srp/ib_srp.c:	spin_lock(&host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:	list_add_tail(&target->list, &host->target_list);
drivers/infiniband/ulp/srp/ib_srp.c:	spin_unlock(&host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:	scsi_scan_target(&target->scsi_host->shost_gendev,
drivers/infiniband/ulp/srp/ib_srp.c:	complete(&host->released);
drivers/infiniband/ulp/srp/ib_srp.c:			target->scsi_host->max_sectors = token;
drivers/infiniband/ulp/srp/ib_srp.c:			target->scsi_host->cmd_per_lun = min(token, SRP_CMD_SQ_SIZE);
drivers/infiniband/ulp/srp/ib_srp.c:	struct ib_device *ibdev = host->srp_dev->dev;
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->transportt  = ib_srp_transport_template;
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->max_channel = 0;
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->max_id      = 1;
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->max_lun     = SRP_MAX_LUN;
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->max_cmd_len = sizeof ((struct srp_cmd *) (void *) 0L)->cdb;
drivers/infiniband/ulp/srp/ib_srp.c:	target->lkey		= host->srp_dev->mr->lkey;
drivers/infiniband/ulp/srp/ib_srp.c:	target->rkey		= host->srp_dev->mr->rkey;
drivers/infiniband/ulp/srp/ib_srp.c:	if (!host->srp_dev->fmr_pool && !target->allow_ext_sg &&
drivers/infiniband/ulp/srp/ib_srp.c:	target_host->sg_tablesize = target->sg_tablesize;
drivers/infiniband/ulp/srp/ib_srp.c:	ib_query_gid(ibdev, host->port, 0, &target->path.sgid);
drivers/infiniband/ulp/srp/ib_srp.c:	return sprintf(buf, "%s\n", host->srp_dev->dev->name);
drivers/infiniband/ulp/srp/ib_srp.c:	return sprintf(buf, "%d\n", host->port);
drivers/infiniband/ulp/srp/ib_srp.c:	INIT_LIST_HEAD(&host->target_list);
drivers/infiniband/ulp/srp/ib_srp.c:	spin_lock_init(&host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:	init_completion(&host->released);
drivers/infiniband/ulp/srp/ib_srp.c:	host->srp_dev = device;
drivers/infiniband/ulp/srp/ib_srp.c:	host->port = port;
drivers/infiniband/ulp/srp/ib_srp.c:	host->dev.class = &srp_class;
drivers/infiniband/ulp/srp/ib_srp.c:	host->dev.parent = device->dev->dma_device;
drivers/infiniband/ulp/srp/ib_srp.c:	dev_set_name(&host->dev, "srp-%s-%d", device->dev->name, port);
drivers/infiniband/ulp/srp/ib_srp.c:	if (device_register(&host->dev))
drivers/infiniband/ulp/srp/ib_srp.c:	if (device_create_file(&host->dev, &dev_attr_add_target))
drivers/infiniband/ulp/srp/ib_srp.c:	if (device_create_file(&host->dev, &dev_attr_ibdev))
drivers/infiniband/ulp/srp/ib_srp.c:	if (device_create_file(&host->dev, &dev_attr_port))
drivers/infiniband/ulp/srp/ib_srp.c:	device_unregister(&host->dev);
drivers/infiniband/ulp/srp/ib_srp.c:			list_add_tail(&host->list, &srp_dev->dev_list);
drivers/infiniband/ulp/srp/ib_srp.c:		device_unregister(&host->dev);
drivers/infiniband/ulp/srp/ib_srp.c:		wait_for_completion(&host->released);
drivers/infiniband/ulp/srp/ib_srp.c:		spin_lock(&host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:		list_for_each_entry(target, &host->target_list, list) {
drivers/infiniband/ulp/srp/ib_srp.c:		spin_unlock(&host->target_lock);
drivers/infiniband/ulp/srp/ib_srp.c:					 &host->target_list, list) {
drivers/input/keyboard/tegra-kbc.c:	if (of_find_property(np, "nvidia,needs-ghost-filter", NULL))
drivers/md/bitmap.h: * with version 3, it is host-endian which is non-portable
drivers/media/rc/ati_remote.c:	if (iface_host->desc.bNumEndpoints != 2) {
drivers/media/rc/ati_remote.c:	endpoint_in = &iface_host->endpoint[0].desc;
drivers/media/rc/ati_remote.c:	endpoint_out = &iface_host->endpoint[1].desc;
drivers/media/rc/streamzap.c:	if (iface_host->desc.bNumEndpoints != 1) {
drivers/media/rc/streamzap.c:			__func__, iface_host->desc.bNumEndpoints);
drivers/media/rc/streamzap.c:	sz->endpoint = &(iface_host->endpoint[0].desc);
drivers/media/video/atmel-isi.c:	soc_host->drv_name	= "isi-camera";
drivers/media/video/atmel-isi.c:	soc_host->ops		= &isi_soc_camera_host_ops;
drivers/media/video/atmel-isi.c:	soc_host->priv		= isi;
drivers/media/video/atmel-isi.c:	soc_host->v4l2_dev.dev	= &pdev->dev;
drivers/media/video/atmel-isi.c:	soc_host->nr		= pdev->id;
drivers/media/video/mx3_camera.c: * As long as we don't implement host-side cropping and scaling, we can use
drivers/media/video/mx3_camera.c:	soc_host->drv_name	= MX3_CAM_DRV_NAME;
drivers/media/video/mx3_camera.c:	soc_host->ops		= &mx3_soc_camera_host_ops;
drivers/media/video/mx3_camera.c:	soc_host->priv		= mx3_cam;
drivers/media/video/mx3_camera.c:	soc_host->v4l2_dev.dev	= &pdev->dev;
drivers/media/video/mx3_camera.c:	soc_host->nr		= pdev->id;
drivers/media/video/soc_camera.c:		 * First pass - only count formats this host-sensor
drivers/media/video/soc_camera.c:/* Called during host-driver probe */
drivers/memstick/core/memstick.c:	queue_work(workqueue, &host->media_checker);
drivers/memstick/core/memstick.c:	if ((*mrq) && (*mrq)->error && host->retries) {
drivers/memstick/core/memstick.c:		host->retries--;
drivers/memstick/core/memstick.c:	if (host->card && host->card->next_request)
drivers/memstick/core/memstick.c:		rc = host->card->next_request(host->card, mrq);
drivers/memstick/core/memstick.c:		host->retries = cmd_retries > 1 ? cmd_retries - 1 : 1;
drivers/memstick/core/memstick.c:	if (host->card) {
drivers/memstick/core/memstick.c:		host->retries = cmd_retries;
drivers/memstick/core/memstick.c:		INIT_COMPLETION(host->card->mrq_complete);
drivers/memstick/core/memstick.c:		host->request(host);
drivers/memstick/core/memstick.c:	struct memstick_dev *old_card = host->card;
drivers/memstick/core/memstick.c:		dev_set_name(&card->dev, "%s", dev_name(&host->dev));
drivers/memstick/core/memstick.c:		card->dev.parent = &host->dev;
drivers/memstick/core/memstick.c:		host->card = card;
drivers/memstick/core/memstick.c:	host->card = old_card;
drivers/memstick/core/memstick.c:	host->card = old_card;
drivers/memstick/core/memstick.c:	int rc = host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);
drivers/memstick/core/memstick.c:		rc = host->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);
drivers/memstick/core/memstick.c:	dev_dbg(&host->dev, "memstick_check started\n");
drivers/memstick/core/memstick.c:	mutex_lock(&host->lock);
drivers/memstick/core/memstick.c:	if (!host->card) {
drivers/memstick/core/memstick.c:	} else if (host->card->stop)
drivers/memstick/core/memstick.c:		host->card->stop(host->card);
drivers/memstick/core/memstick.c:		if (host->card) {
drivers/memstick/core/memstick.c:			device_unregister(&host->card->dev);
drivers/memstick/core/memstick.c:			host->card = NULL;
drivers/memstick/core/memstick.c:		dev_dbg(&host->dev, "new card %02x, %02x, %02x\n",
drivers/memstick/core/memstick.c:		if (host->card) {
drivers/memstick/core/memstick.c:			if (memstick_set_rw_addr(host->card)
drivers/memstick/core/memstick.c:			    || !memstick_dev_match(host->card, &card->id)
drivers/memstick/core/memstick.c:			    || !(host->card->check(host->card))) {
drivers/memstick/core/memstick.c:				device_unregister(&host->card->dev);
drivers/memstick/core/memstick.c:				host->card = NULL;
drivers/memstick/core/memstick.c:			} else if (host->card->start)
drivers/memstick/core/memstick.c:				host->card->start(host->card);
drivers/memstick/core/memstick.c:		if (!host->card) {
drivers/memstick/core/memstick.c:			host->card = card;
drivers/memstick/core/memstick.c:				kfree(host->card);
drivers/memstick/core/memstick.c:				host->card = NULL;
drivers/memstick/core/memstick.c:	if (!host->card)
drivers/memstick/core/memstick.c:		host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);
drivers/memstick/core/memstick.c:	mutex_unlock(&host->lock);
drivers/memstick/core/memstick.c:	dev_dbg(&host->dev, "memstick_check finished\n");
drivers/memstick/core/memstick.c:		mutex_init(&host->lock);
drivers/memstick/core/memstick.c:		INIT_WORK(&host->media_checker, memstick_check);
drivers/memstick/core/memstick.c:		host->dev.class = &memstick_host_class;
drivers/memstick/core/memstick.c:		host->dev.parent = dev;
drivers/memstick/core/memstick.c:		device_initialize(&host->dev);
drivers/memstick/core/memstick.c:		rc = idr_get_new(&memstick_host_idr, host, &host->id);
drivers/memstick/core/memstick.c:	dev_set_name(&host->dev, "memstick%u", host->id);
drivers/memstick/core/memstick.c:	rc = device_add(&host->dev);
drivers/memstick/core/memstick.c:		idr_remove(&memstick_host_idr, host->id);
drivers/memstick/core/memstick.c:	host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);
drivers/memstick/core/memstick.c:	mutex_lock(&host->lock);
drivers/memstick/core/memstick.c:	if (host->card)
drivers/memstick/core/memstick.c:		device_unregister(&host->card->dev);
drivers/memstick/core/memstick.c:	host->card = NULL;
drivers/memstick/core/memstick.c:	host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);
drivers/memstick/core/memstick.c:	mutex_unlock(&host->lock);
drivers/memstick/core/memstick.c:	idr_remove(&memstick_host_idr, host->id);
drivers/memstick/core/memstick.c:	device_del(&host->dev);
drivers/memstick/core/memstick.c:	mutex_destroy(&host->lock);
drivers/memstick/core/memstick.c:	put_device(&host->dev);
drivers/memstick/core/memstick.c:	mutex_lock(&host->lock);
drivers/memstick/core/memstick.c:	host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);
drivers/memstick/core/memstick.c:	mutex_unlock(&host->lock);
drivers/memstick/core/memstick.c:	mutex_lock(&host->lock);
drivers/memstick/core/memstick.c:	if (host->card)
drivers/memstick/core/memstick.c:	mutex_unlock(&host->lock);
drivers/memstick/core/mspro_block.c:	host->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_PAR4);
drivers/memstick/core/mspro_block.c:			host->set_param(host, MEMSTICK_INTERFACE,
drivers/memstick/core/mspro_block.c:		host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);
drivers/memstick/core/mspro_block.c:		host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);
drivers/memstick/core/mspro_block.c:		host->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);
drivers/memstick/core/mspro_block.c:	msb->caps = host->caps;
drivers/memstick/core/mspro_block.c:	if (host->dev.dma_mask && *(host->dev.dma_mask))
drivers/memstick/core/mspro_block.c:		limit = *(host->dev.dma_mask);
drivers/memstick/core/mspro_block.c:	mutex_lock(&host->lock);
drivers/memstick/core/mspro_block.c:	mutex_unlock(&host->lock);
drivers/memstick/host/jmb38x_ms.c:	while (host->io_pos && length) {
drivers/memstick/host/jmb38x_ms.c:		buf[off++] = host->io_word[0] & 0xff;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] >>= 8;
drivers/memstick/host/jmb38x_ms.c:		host->io_pos--;
drivers/memstick/host/jmb38x_ms.c:	while (!(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {
drivers/memstick/host/jmb38x_ms.c:		*(unsigned int *)(buf + off) = __raw_readl(host->addr + DATA);
drivers/memstick/host/jmb38x_ms.c:	    && !(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] = readl(host->addr + DATA);
drivers/memstick/host/jmb38x_ms.c:		for (host->io_pos = 4; host->io_pos; --host->io_pos) {
drivers/memstick/host/jmb38x_ms.c:			buf[off++] = host->io_word[0] & 0xff;
drivers/memstick/host/jmb38x_ms.c:			host->io_word[0] >>= 8;
drivers/memstick/host/jmb38x_ms.c:	while (host->io_pos > 4 && length) {
drivers/memstick/host/jmb38x_ms.c:		buf[off++] = host->io_word[0] & 0xff;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] >>= 8;
drivers/memstick/host/jmb38x_ms.c:		host->io_pos--;
drivers/memstick/host/jmb38x_ms.c:	while (host->io_pos && length) {
drivers/memstick/host/jmb38x_ms.c:		buf[off++] = host->io_word[1] & 0xff;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[1] >>= 8;
drivers/memstick/host/jmb38x_ms.c:		host->io_pos--;
drivers/memstick/host/jmb38x_ms.c:	if (host->io_pos) {
drivers/memstick/host/jmb38x_ms.c:		while (host->io_pos < 4 && length) {
drivers/memstick/host/jmb38x_ms.c:			host->io_word[0] |=  buf[off++] << (host->io_pos * 8);
drivers/memstick/host/jmb38x_ms.c:			host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:	if (host->io_pos == 4
drivers/memstick/host/jmb38x_ms.c:	    && !(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {
drivers/memstick/host/jmb38x_ms.c:		writel(host->io_word[0], host->addr + DATA);
drivers/memstick/host/jmb38x_ms.c:		host->io_pos = 0;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] = 0;
drivers/memstick/host/jmb38x_ms.c:	} else if (host->io_pos) {
drivers/memstick/host/jmb38x_ms.c:	while (!(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {
drivers/memstick/host/jmb38x_ms.c:			     host->addr + DATA);
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] |= buf[off + 2] << 16;
drivers/memstick/host/jmb38x_ms.c:		host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] |= buf[off + 1] << 8;
drivers/memstick/host/jmb38x_ms.c:		host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] |= buf[off];
drivers/memstick/host/jmb38x_ms.c:		host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:	off += host->io_pos;
drivers/memstick/host/jmb38x_ms.c:	while (host->io_pos < 4 && length) {
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] &= ~(0xff << (host->io_pos * 8));
drivers/memstick/host/jmb38x_ms.c:		host->io_word[0] |=  buf[off++] << (host->io_pos * 8);
drivers/memstick/host/jmb38x_ms.c:		host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:	while (host->io_pos < 8 && length) {
drivers/memstick/host/jmb38x_ms.c:		host->io_word[1] &= ~(0xff << (host->io_pos * 8));
drivers/memstick/host/jmb38x_ms.c:		host->io_word[1] |=  buf[off++] << (host->io_pos * 8);
drivers/memstick/host/jmb38x_ms.c:		host->io_pos++;
drivers/memstick/host/jmb38x_ms.c:	if (host->req->long_data) {
drivers/memstick/host/jmb38x_ms.c:		length = host->req->sg.length - host->block_pos;
drivers/memstick/host/jmb38x_ms.c:		off = host->req->sg.offset + host->block_pos;
drivers/memstick/host/jmb38x_ms.c:		length = host->req->data_len - host->block_pos;
drivers/memstick/host/jmb38x_ms.c:		if (host->req->long_data) {
drivers/memstick/host/jmb38x_ms.c:			pg = nth_page(sg_page(&host->req->sg),
drivers/memstick/host/jmb38x_ms.c:			buf = host->req->data + host->block_pos;
drivers/memstick/host/jmb38x_ms.c:			p_cnt = host->req->data_len - host->block_pos;
drivers/memstick/host/jmb38x_ms.c:		if (host->req->data_dir == WRITE)
drivers/memstick/host/jmb38x_ms.c:			t_size = !(host->cmd_flags & REG_DATA)
drivers/memstick/host/jmb38x_ms.c:			t_size = !(host->cmd_flags & REG_DATA)
drivers/memstick/host/jmb38x_ms.c:		if (host->req->long_data) {
drivers/memstick/host/jmb38x_ms.c:		host->block_pos += t_size;
drivers/memstick/host/jmb38x_ms.c:	if (!length && host->req->data_dir == WRITE) {
drivers/memstick/host/jmb38x_ms.c:		if (host->cmd_flags & REG_DATA) {
drivers/memstick/host/jmb38x_ms.c:			writel(host->io_word[0], host->addr + TPC_P0);
drivers/memstick/host/jmb38x_ms.c:			writel(host->io_word[1], host->addr + TPC_P1);
drivers/memstick/host/jmb38x_ms.c:		} else if (host->io_pos) {
drivers/memstick/host/jmb38x_ms.c:			writel(host->io_word[0], host->addr + DATA);
drivers/memstick/host/jmb38x_ms.c:	if (!(STATUS_HAS_MEDIA & readl(host->addr + STATUS))) {
drivers/memstick/host/jmb38x_ms.c:		host->req->error = -ETIME;
drivers/memstick/host/jmb38x_ms.c:		return host->req->error;
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&msh->dev, "control %08x\n", readl(host->addr + HOST_CONTROL));
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&msh->dev, "status %08x\n", readl(host->addr + INT_STATUS));
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&msh->dev, "hstatus %08x\n", readl(host->addr + STATUS));
drivers/memstick/host/jmb38x_ms.c:	host->cmd_flags = 0;
drivers/memstick/host/jmb38x_ms.c:	host->block_pos = 0;
drivers/memstick/host/jmb38x_ms.c:	host->io_pos = 0;
drivers/memstick/host/jmb38x_ms.c:	host->io_word[0] = 0;
drivers/memstick/host/jmb38x_ms.c:	host->io_word[1] = 0;
drivers/memstick/host/jmb38x_ms.c:	cmd = host->req->tpc << 16;
drivers/memstick/host/jmb38x_ms.c:	if (host->req->data_dir == READ)
drivers/memstick/host/jmb38x_ms.c:	if (host->req->need_card_int) {
drivers/memstick/host/jmb38x_ms.c:		if (host->ifmode == MEMSTICK_SERIAL)
drivers/memstick/host/jmb38x_ms.c:	data = host->req->data;
drivers/memstick/host/jmb38x_ms.c:		host->cmd_flags |= DMA_DATA;
drivers/memstick/host/jmb38x_ms.c:	if (host->req->long_data) {
drivers/memstick/host/jmb38x_ms.c:		data_len = host->req->sg.length;
drivers/memstick/host/jmb38x_ms.c:		data_len = host->req->data_len;
drivers/memstick/host/jmb38x_ms.c:		host->cmd_flags &= ~DMA_DATA;
drivers/memstick/host/jmb38x_ms.c:		host->cmd_flags |= REG_DATA;
drivers/memstick/host/jmb38x_ms.c:		host->cmd_flags &= ~DMA_DATA;
drivers/memstick/host/jmb38x_ms.c:	if (host->cmd_flags & DMA_DATA) {
drivers/memstick/host/jmb38x_ms.c:		if (1 != pci_map_sg(host->chip->pdev, &host->req->sg, 1,
drivers/memstick/host/jmb38x_ms.c:				    host->req->data_dir == READ
drivers/memstick/host/jmb38x_ms.c:			host->req->error = -ENOMEM;
drivers/memstick/host/jmb38x_ms.c:			return host->req->error;
drivers/memstick/host/jmb38x_ms.c:		data_len = sg_dma_len(&host->req->sg);
drivers/memstick/host/jmb38x_ms.c:		writel(sg_dma_address(&host->req->sg),
drivers/memstick/host/jmb38x_ms.c:		       host->addr + DMA_ADDRESS);
drivers/memstick/host/jmb38x_ms.c:		       host->addr + BLOCK);
drivers/memstick/host/jmb38x_ms.c:		writel(DMA_CONTROL_ENABLE, host->addr + DMA_CONTROL);
drivers/memstick/host/jmb38x_ms.c:	} else if (!(host->cmd_flags & REG_DATA)) {
drivers/memstick/host/jmb38x_ms.c:		       host->addr + BLOCK);
drivers/memstick/host/jmb38x_ms.c:			t_val = readl(host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:			t_val |= host->req->data_dir == READ
drivers/memstick/host/jmb38x_ms.c:			writel(t_val, host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:			writel(t_val, host->addr + INT_SIGNAL_ENABLE);
drivers/memstick/host/jmb38x_ms.c:		host->cmd_flags |= REG_DATA;
drivers/memstick/host/jmb38x_ms.c:		if (host->req->data_dir == WRITE) {
drivers/memstick/host/jmb38x_ms.c:			writel(host->io_word[0], host->addr + TPC_P0);
drivers/memstick/host/jmb38x_ms.c:			writel(host->io_word[1], host->addr + TPC_P1);
drivers/memstick/host/jmb38x_ms.c:	mod_timer(&host->timer, jiffies + host->timeout_jiffies);
drivers/memstick/host/jmb38x_ms.c:	writel(HOST_CONTROL_LED | readl(host->addr + HOST_CONTROL),
drivers/memstick/host/jmb38x_ms.c:	       host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:	host->req->error = 0;
drivers/memstick/host/jmb38x_ms.c:	writel(cmd, host->addr + TPC);
drivers/memstick/host/jmb38x_ms.c:	del_timer(&host->timer);
drivers/memstick/host/jmb38x_ms.c:		readl(host->addr + HOST_CONTROL));
drivers/memstick/host/jmb38x_ms.c:		readl(host->addr + INT_STATUS));
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&msh->dev, "c hstatus %08x\n", readl(host->addr + STATUS));
drivers/memstick/host/jmb38x_ms.c:	host->req->int_reg = readl(host->addr + STATUS) & 0xff;
drivers/memstick/host/jmb38x_ms.c:	writel(0, host->addr + BLOCK);
drivers/memstick/host/jmb38x_ms.c:	writel(0, host->addr + DMA_CONTROL);
drivers/memstick/host/jmb38x_ms.c:	if (host->cmd_flags & DMA_DATA) {
drivers/memstick/host/jmb38x_ms.c:		pci_unmap_sg(host->chip->pdev, &host->req->sg, 1,
drivers/memstick/host/jmb38x_ms.c:			     host->req->data_dir == READ
drivers/memstick/host/jmb38x_ms.c:		t_val = readl(host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:		if (host->req->data_dir == READ)
drivers/memstick/host/jmb38x_ms.c:		writel(t_val, host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:		writel(t_val, host->addr + INT_SIGNAL_ENABLE);
drivers/memstick/host/jmb38x_ms.c:	writel((~HOST_CONTROL_LED) & readl(host->addr + HOST_CONTROL),
drivers/memstick/host/jmb38x_ms.c:	       host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:			rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/jmb38x_ms.c:			rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/jmb38x_ms.c:				host->req->error = -ETIME;
drivers/memstick/host/jmb38x_ms.c:	spin_lock(&host->lock);
drivers/memstick/host/jmb38x_ms.c:	irq_status = readl(host->addr + INT_STATUS);
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "irq_status = %08x\n", irq_status);
drivers/memstick/host/jmb38x_ms.c:		spin_unlock(&host->lock);
drivers/memstick/host/jmb38x_ms.c:	if (host->req) {
drivers/memstick/host/jmb38x_ms.c:				host->req->error = -EILSEQ;
drivers/memstick/host/jmb38x_ms.c:				dev_dbg(&host->chip->pdev->dev, "TPC_ERR\n");
drivers/memstick/host/jmb38x_ms.c:				host->req->error = -ETIME;
drivers/memstick/host/jmb38x_ms.c:			if (host->cmd_flags & DMA_DATA) {
drivers/memstick/host/jmb38x_ms.c:					host->cmd_flags |= FIFO_READY;
drivers/memstick/host/jmb38x_ms.c:					host->cmd_flags |= FIFO_READY;
drivers/memstick/host/jmb38x_ms.c:				host->cmd_flags |= CMD_READY;
drivers/memstick/host/jmb38x_ms.c:				if (host->cmd_flags & REG_DATA) {
drivers/memstick/host/jmb38x_ms.c:					if (host->req->data_dir == READ) {
drivers/memstick/host/jmb38x_ms.c:						host->io_word[0]
drivers/memstick/host/jmb38x_ms.c:							= readl(host->addr
drivers/memstick/host/jmb38x_ms.c:						host->io_word[1]
drivers/memstick/host/jmb38x_ms.c:							= readl(host->addr
drivers/memstick/host/jmb38x_ms.c:						host->io_pos = 8;
drivers/memstick/host/jmb38x_ms.c:					host->cmd_flags |= FIFO_READY;
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&host->chip->pdev->dev, "media changed\n");
drivers/memstick/host/jmb38x_ms.c:	writel(irq_status, host->addr + INT_STATUS);
drivers/memstick/host/jmb38x_ms.c:	if (host->req
drivers/memstick/host/jmb38x_ms.c:	    && (((host->cmd_flags & CMD_READY)
drivers/memstick/host/jmb38x_ms.c:		 && (host->cmd_flags & FIFO_READY))
drivers/memstick/host/jmb38x_ms.c:		|| host->req->error))
drivers/memstick/host/jmb38x_ms.c:	spin_unlock(&host->lock);
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "abort\n");
drivers/memstick/host/jmb38x_ms.c:	spin_lock_irqsave(&host->lock, flags);
drivers/memstick/host/jmb38x_ms.c:	if (host->req) {
drivers/memstick/host/jmb38x_ms.c:		host->req->error = -ETIME;
drivers/memstick/host/jmb38x_ms.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/memstick/host/jmb38x_ms.c:	spin_lock_irqsave(&host->lock, flags);
drivers/memstick/host/jmb38x_ms.c:	if (!host->req) {
drivers/memstick/host/jmb38x_ms.c:			rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "tasklet req %d\n", rc);
drivers/memstick/host/jmb38x_ms.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/memstick/host/jmb38x_ms.c:	tasklet_schedule(&host->notify);
drivers/memstick/host/jmb38x_ms.c:	       | readl(host->addr + HOST_CONTROL),
drivers/memstick/host/jmb38x_ms.c:	       host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:		      & readl(host->addr + HOST_CONTROL)))
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "reset_req timeout\n");
drivers/memstick/host/jmb38x_ms.c:	       | readl(host->addr + HOST_CONTROL),
drivers/memstick/host/jmb38x_ms.c:	       host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:		      & readl(host->addr + HOST_CONTROL)))
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "reset timeout\n");
drivers/memstick/host/jmb38x_ms.c:	writel(INT_STATUS_ALL, host->addr + INT_SIGNAL_ENABLE);
drivers/memstick/host/jmb38x_ms.c:	writel(INT_STATUS_ALL, host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:	unsigned int host_ctl = readl(host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:			writel(host_ctl, host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:			writel(host->id ? PAD_PU_PD_ON_MS_SOCK1
drivers/memstick/host/jmb38x_ms.c:			       host->addr + PAD_PU_PD);
drivers/memstick/host/jmb38x_ms.c:			       host->addr + PAD_OUTPUT_ENABLE);
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "power on\n");
drivers/memstick/host/jmb38x_ms.c:			writel(host_ctl, host->addr +  HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:			writel(0, host->addr + PAD_OUTPUT_ENABLE);
drivers/memstick/host/jmb38x_ms.c:			writel(PAD_PU_PD_OFF, host->addr + PAD_PU_PD);
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "power off\n");
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&host->chip->pdev->dev,
drivers/memstick/host/jmb38x_ms.c:		writel(host_ctl, host->addr + HOST_CONTROL);
drivers/memstick/host/jmb38x_ms.c:		writel(CLOCK_CONTROL_OFF, host->addr + CLOCK_CONTROL);
drivers/memstick/host/jmb38x_ms.c:		writel(clock_ctl, host->addr + CLOCK_CONTROL);
drivers/memstick/host/jmb38x_ms.c:		pci_write_config_byte(host->chip->pdev,
drivers/memstick/host/jmb38x_ms.c:		host->ifmode = value;
drivers/memstick/host/jmb38x_ms.c:	host->chip = jm;
drivers/memstick/host/jmb38x_ms.c:	host->addr = ioremap(pci_resource_start(jm->pdev, cnt),
drivers/memstick/host/jmb38x_ms.c:	if (!host->addr)
drivers/memstick/host/jmb38x_ms.c:	spin_lock_init(&host->lock);
drivers/memstick/host/jmb38x_ms.c:	host->id = cnt;
drivers/memstick/host/jmb38x_ms.c:	snprintf(host->host_id, sizeof(host->host_id), DRIVER_NAME ":slot%d",
drivers/memstick/host/jmb38x_ms.c:		 host->id);
drivers/memstick/host/jmb38x_ms.c:	host->irq = jm->pdev->irq;
drivers/memstick/host/jmb38x_ms.c:	host->timeout_jiffies = msecs_to_jiffies(1000);
drivers/memstick/host/jmb38x_ms.c:	tasklet_init(&host->notify, jmb38x_ms_req_tasklet, (unsigned long)msh);
drivers/memstick/host/jmb38x_ms.c:	setup_timer(&host->timer, jmb38x_ms_abort, (unsigned long)msh);
drivers/memstick/host/jmb38x_ms.c:	if (!request_irq(host->irq, jmb38x_ms_isr, IRQF_SHARED, host->host_id,
drivers/memstick/host/jmb38x_ms.c:	iounmap(host->addr);
drivers/memstick/host/jmb38x_ms.c:	free_irq(host->irq, msh);
drivers/memstick/host/jmb38x_ms.c:	iounmap(host->addr);
drivers/memstick/host/jmb38x_ms.c:		tasklet_kill(&host->notify);
drivers/memstick/host/jmb38x_ms.c:		writel(0, host->addr + INT_SIGNAL_ENABLE);
drivers/memstick/host/jmb38x_ms.c:		writel(0, host->addr + INT_STATUS_ENABLE);
drivers/memstick/host/jmb38x_ms.c:		spin_lock_irqsave(&host->lock, flags);
drivers/memstick/host/jmb38x_ms.c:		if (host->req) {
drivers/memstick/host/jmb38x_ms.c:			host->req->error = -ETIME;
drivers/memstick/host/jmb38x_ms.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/memstick/host/r592.c:	host->caps = MEMSTICK_CAP_PAR4;
drivers/memstick/host/r592.c:	host->request = r592_submit_req;
drivers/memstick/host/r592.c:	host->set_param = r592_set_param;
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	while (host->io_pos && length) {
drivers/memstick/host/tifm_ms.c:		buf[off++] = host->io_word & 0xff;
drivers/memstick/host/tifm_ms.c:		host->io_word >>= 8;
drivers/memstick/host/tifm_ms.c:		host->io_pos--;
drivers/memstick/host/tifm_ms.c:		host->io_word = readl(sock->addr + SOCK_MS_DATA);
drivers/memstick/host/tifm_ms.c:		for (host->io_pos = 4; host->io_pos; --host->io_pos) {
drivers/memstick/host/tifm_ms.c:			buf[off++] = host->io_word & 0xff;
drivers/memstick/host/tifm_ms.c:			host->io_word >>= 8;
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	if (host->io_pos) {
drivers/memstick/host/tifm_ms.c:		while (host->io_pos < 4 && length) {
drivers/memstick/host/tifm_ms.c:			host->io_word |=  buf[off++] << (host->io_pos * 8);
drivers/memstick/host/tifm_ms.c:			host->io_pos++;
drivers/memstick/host/tifm_ms.c:	if (host->io_pos == 4
drivers/memstick/host/tifm_ms.c:		writel(host->io_word, sock->addr + SOCK_MS_DATA);
drivers/memstick/host/tifm_ms.c:		host->io_pos = 0;
drivers/memstick/host/tifm_ms.c:		host->io_word = 0;
drivers/memstick/host/tifm_ms.c:	} else if (host->io_pos) {
drivers/memstick/host/tifm_ms.c:		host->io_word |= buf[off + 2] << 16;
drivers/memstick/host/tifm_ms.c:		host->io_pos++;
drivers/memstick/host/tifm_ms.c:		host->io_word |= buf[off + 1] << 8;
drivers/memstick/host/tifm_ms.c:		host->io_pos++;
drivers/memstick/host/tifm_ms.c:		host->io_word |= buf[off];
drivers/memstick/host/tifm_ms.c:		host->io_pos++;
drivers/memstick/host/tifm_ms.c:	off += host->io_pos;
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	if (host->req->long_data) {
drivers/memstick/host/tifm_ms.c:		length = host->req->sg.length - host->block_pos;
drivers/memstick/host/tifm_ms.c:		off = host->req->sg.offset + host->block_pos;
drivers/memstick/host/tifm_ms.c:		length = host->req->data_len - host->block_pos;
drivers/memstick/host/tifm_ms.c:		host->block_pos);
drivers/memstick/host/tifm_ms.c:		if (host->req->long_data) {
drivers/memstick/host/tifm_ms.c:			pg = nth_page(sg_page(&host->req->sg),
drivers/memstick/host/tifm_ms.c:			buf = host->req->data + host->block_pos;
drivers/memstick/host/tifm_ms.c:			p_cnt = host->req->data_len - host->block_pos;
drivers/memstick/host/tifm_ms.c:		t_size = host->req->data_dir == WRITE
drivers/memstick/host/tifm_ms.c:		if (host->req->long_data) {
drivers/memstick/host/tifm_ms.c:		host->block_pos += t_size;
drivers/memstick/host/tifm_ms.c:	if (!length && (host->req->data_dir == WRITE)) {
drivers/memstick/host/tifm_ms.c:		if (host->io_pos) {
drivers/memstick/host/tifm_ms.c:			writel(host->io_word, sock->addr + SOCK_MS_DATA);
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	host->cmd_flags = 0;
drivers/memstick/host/tifm_ms.c:	host->block_pos = 0;
drivers/memstick/host/tifm_ms.c:	host->io_pos = 0;
drivers/memstick/host/tifm_ms.c:	host->io_word = 0;
drivers/memstick/host/tifm_ms.c:	host->cmd_flags = 0;
drivers/memstick/host/tifm_ms.c:	data = host->req->data;
drivers/memstick/host/tifm_ms.c:	host->use_dma = !no_dma;
drivers/memstick/host/tifm_ms.c:	if (host->req->long_data) {
drivers/memstick/host/tifm_ms.c:		data_len = host->req->sg.length;
drivers/memstick/host/tifm_ms.c:			host->use_dma = 0;
drivers/memstick/host/tifm_ms.c:		data_len = host->req->data_len;
drivers/memstick/host/tifm_ms.c:		host->use_dma = 0;
drivers/memstick/host/tifm_ms.c:	if (host->use_dma) {
drivers/memstick/host/tifm_ms.c:		if (1 != tifm_map_sg(sock, &host->req->sg, 1,
drivers/memstick/host/tifm_ms.c:				     host->req->data_dir == READ
drivers/memstick/host/tifm_ms.c:			host->req->error = -ENOMEM;
drivers/memstick/host/tifm_ms.c:			return host->req->error;
drivers/memstick/host/tifm_ms.c:		data_len = sg_dma_len(&host->req->sg);
drivers/memstick/host/tifm_ms.c:		if (host->req->data_dir == WRITE)
drivers/memstick/host/tifm_ms.c:		writel(sg_dma_address(&host->req->sg),
drivers/memstick/host/tifm_ms.c:		writel(host->mode_mask | TIFM_MS_SYS_FIFO,
drivers/memstick/host/tifm_ms.c:	mod_timer(&host->timer, jiffies + host->timeout_jiffies);
drivers/memstick/host/tifm_ms.c:	host->req->error = 0;
drivers/memstick/host/tifm_ms.c:	if (host->use_dma)
drivers/memstick/host/tifm_ms.c:	cmd = (host->req->tpc & 0xf) << 12;
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	del_timer(&host->timer);
drivers/memstick/host/tifm_ms.c:	host->req->int_reg = readl(sock->addr + SOCK_MS_STATUS) & 0xff;
drivers/memstick/host/tifm_ms.c:	host->req->int_reg = (host->req->int_reg & 1)
drivers/memstick/host/tifm_ms.c:			     | ((host->req->int_reg << 4) & 0xe0);
drivers/memstick/host/tifm_ms.c:	if (host->use_dma) {
drivers/memstick/host/tifm_ms.c:		tifm_unmap_sg(sock, &host->req->sg, 1,
drivers/memstick/host/tifm_ms.c:			      host->req->data_dir == READ
drivers/memstick/host/tifm_ms.c:		rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/tifm_ms.c:	if (!host->req->error) {
drivers/memstick/host/tifm_ms.c:		if (!(host->cmd_flags & CMD_READY))
drivers/memstick/host/tifm_ms.c:		if (!(host->cmd_flags & FIFO_READY))
drivers/memstick/host/tifm_ms.c:		if (host->req->need_card_int
drivers/memstick/host/tifm_ms.c:		    && !(host->cmd_flags & CARD_INT))
drivers/memstick/host/tifm_ms.c:		fifo_status, host_status, host->cmd_flags);
drivers/memstick/host/tifm_ms.c:	if (host->req) {
drivers/memstick/host/tifm_ms.c:		if (host->use_dma && (fifo_status & 1)) {
drivers/memstick/host/tifm_ms.c:			host->cmd_flags |= FIFO_READY;
drivers/memstick/host/tifm_ms.c:		if (!host->use_dma && (fifo_status & TIFM_FIFO_MORE)) {
drivers/memstick/host/tifm_ms.c:				host->cmd_flags |= FIFO_READY;
drivers/memstick/host/tifm_ms.c:		host_status, host->cmd_flags);
drivers/memstick/host/tifm_ms.c:	if (host->req) {
drivers/memstick/host/tifm_ms.c:			host->req->error = -ETIME;
drivers/memstick/host/tifm_ms.c:			host->req->error = -EILSEQ;
drivers/memstick/host/tifm_ms.c:			host->cmd_flags |= CMD_READY;
drivers/memstick/host/tifm_ms.c:			host->cmd_flags |= CARD_INT;
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:	if (!host->req) {
drivers/memstick/host/tifm_ms.c:		if (host->eject) {
drivers/memstick/host/tifm_ms.c:				rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/tifm_ms.c:					host->req->error = -ETIME;
drivers/memstick/host/tifm_ms.c:			rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/tifm_ms.c:	tasklet_schedule(&host->notify);
drivers/memstick/host/tifm_ms.c:	struct tifm_dev *sock = host->dev;
drivers/memstick/host/tifm_ms.c:			host->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;
drivers/memstick/host/tifm_ms.c:			host->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;
drivers/memstick/host/tifm_ms.c:			host->mode_mask = 0;
drivers/memstick/host/tifm_ms.c:	dev_dbg(&host->dev->dev, "status %x\n",
drivers/memstick/host/tifm_ms.c:		readl(host->dev->addr + SOCK_MS_STATUS));
drivers/memstick/host/tifm_ms.c:	       dev_name(&host->dev->dev), host->req ? host->req->tpc : 0,
drivers/memstick/host/tifm_ms.c:	       host->cmd_flags);
drivers/memstick/host/tifm_ms.c:	tifm_eject(host->dev);
drivers/memstick/host/tifm_ms.c:	host->dev = sock;
drivers/memstick/host/tifm_ms.c:	host->timeout_jiffies = msecs_to_jiffies(1000);
drivers/memstick/host/tifm_ms.c:	setup_timer(&host->timer, tifm_ms_abort, (unsigned long)host);
drivers/memstick/host/tifm_ms.c:	tasklet_init(&host->notify, tifm_ms_req_tasklet, (unsigned long)msh);
drivers/memstick/host/tifm_ms.c:	tasklet_kill(&host->notify);
drivers/memstick/host/tifm_ms.c:	host->eject = 1;
drivers/memstick/host/tifm_ms.c:	if (host->req) {
drivers/memstick/host/tifm_ms.c:		del_timer(&host->timer);
drivers/memstick/host/tifm_ms.c:		if (host->use_dma)
drivers/memstick/host/tifm_ms.c:			tifm_unmap_sg(sock, &host->req->sg, 1,
drivers/memstick/host/tifm_ms.c:				      host->req->data_dir == READ
drivers/memstick/host/tifm_ms.c:		host->req->error = -ETIME;
drivers/memstick/host/tifm_ms.c:			rc = memstick_next_req(msh, &host->req);
drivers/memstick/host/tifm_ms.c:				host->req->error = -ETIME;
drivers/message/fusion/mptfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/message/fusion/mptfc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/message/fusion/mptfc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/message/fusion/mptfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/message/fusion/mptfc.c:		sdev->host->host_no,
drivers/message/fusion/mptsas.c:	return ((MPT_SCSI_HOST *)shost->hostdata)->ioc;
drivers/message/fusion/mptsas.c:	return ((MPT_SCSI_HOST *)shost->hostdata)->ioc;
drivers/message/fusion/mptsas.c:	MPT_ADAPTER *ioc = ((MPT_SCSI_HOST *) shost->hostdata)->ioc;
drivers/message/fusion/mptscsih.c:			sc->device->host->host_no, sc->device->channel,
drivers/message/fusion/mptscsih.c:		scsidir = MPI_SCSIIO_CONTROL_WRITE;	/* DATA OUT (host-->ioc-->dev) */
drivers/message/i2o/i2o_scsi.c:	scsi_host->max_channel = max_channel - 1;
drivers/message/i2o/i2o_scsi.c:	scsi_host->max_id = i2o_scsi_max_id;
drivers/message/i2o/i2o_scsi.c:	scsi_host->max_lun = i2o_scsi_max_lun;
drivers/message/i2o/i2o_scsi.c:	scsi_host->this_id = c->unit;
drivers/message/i2o/i2o_scsi.c:	scsi_host->sg_tablesize = i2o_sg_tablesize(c, body_size);
drivers/message/i2o/i2o_scsi.c:	i2o_shost = (struct i2o_scsi_host *)scsi_host->hostdata;
drivers/message/i2o/i2o_scsi.c:	i2o_shost->scsi_host = scsi_host;
drivers/message/i2o/i2o_scsi.c:	i2o_shost->iop = c;
drivers/message/i2o/i2o_scsi.c:	i2o_shost->lun = 1;
drivers/message/i2o/i2o_scsi.c:			i2o_shost->channel[i++] = i2o_dev;
drivers/message/i2o/i2o_scsi.c:	shost_for_each_device(scsi_dev, i2o_shost->scsi_host)
drivers/message/i2o/i2o_scsi.c:	scsi_host = i2o_shost->scsi_host;
drivers/message/i2o/i2o_scsi.c:			struct i2o_device *d = i2o_shost->channel[0];
drivers/message/i2o/i2o_scsi.c:						    cpu_to_le64(i2o_shost->
drivers/message/i2o/i2o_scsi.c:		for (i = 0; i <= i2o_shost->scsi_host->max_channel; i++)
drivers/message/i2o/i2o_scsi.c:			if (i2o_shost->channel[i] == parent)
drivers/message/i2o/i2o_scsi.c:	if (le32_to_cpu(id) >= scsi_host->max_id) {
drivers/message/i2o/i2o_scsi.c:			 le32_to_cpu(id), scsi_host->max_id);
drivers/message/i2o/i2o_scsi.c:	if (le64_to_cpu(lun) >= scsi_host->max_lun) {
drivers/message/i2o/i2o_scsi.c:			 scsi_host->max_lun);
drivers/message/i2o/i2o_scsi.c:	    __scsi_add_device(i2o_shost->scsi_host, channel, le32_to_cpu(id),
drivers/message/i2o/i2o_scsi.c:	hostdata = (struct i2o_scsi_host *)SChost->hostdata;
drivers/message/i2o/i2o_scsi.c:	rc = scsi_add_host(i2o_shost->scsi_host, &c->device);
drivers/message/i2o/i2o_scsi.c:		scsi_host_put(i2o_shost->scsi_host);
drivers/message/i2o/i2o_scsi.c:	scsi_remove_host(i2o_shost->scsi_host);
drivers/message/i2o/i2o_scsi.c:	scsi_host_put(i2o_shost->scsi_host);
drivers/mmc/card/block.c:	if (!host->card || mmc_card_removed(host->card)) {
drivers/mmc/card/block.c:	if (!mmc_card_present(host->card)) {
drivers/mmc/card/block.c:	mmc_card_set_removed(host->card);
drivers/mmc/card/block.c:	mmc_schedule_card_removal_work(&host->remove, 0);
drivers/mmc/card/block.c:		struct mmc_blk_data *main_md = mmc_get_drvdata(host->card);
drivers/mmc/card/block.c:		part_err = mmc_blk_part_switch(host->card, md);
drivers/mmc/card/block.c:	     (card->host->caps2 & MMC_CAP2_SANITIZE))) {
drivers/mmc/card/block.c:	if (brq->data.blocks > card->host->max_blk_count)
drivers/mmc/card/block.c:		brq->data.blocks = card->host->max_blk_count;
drivers/mmc/card/block.c:		if (card->host->caps2 & MMC_CAP2_NO_MULTI_READ &&
drivers/mmc/card/block.c:	if (!(host->caps2 & MMC_CAP2_PACKED_WR))
drivers/mmc/card/block.c:	if (!(host->caps2 & MMC_CAP2_PACKED_WR_CONTROL)) {
drivers/mmc/card/block.c:			(card->host->caps2 & MMC_CAP2_PACKED_WR))
drivers/mmc/card/block.c:	max_blk_count = min(card->host->max_blk_count,
drivers/mmc/card/block.c:			card->host->max_req_size >> 9);
drivers/mmc/card/block.c:		if (card->host && card->host->areq)
drivers/mmc/card/block.c:		if (card->host->areq)
drivers/mmc/card/block.c:		if (card->host->areq)
drivers/mmc/card/block.c:		if (card->host && card->host->areq)
drivers/mmc/card/block.c:		if (card->host->areq)
drivers/mmc/card/block.c:		if (card->host->areq)
drivers/mmc/card/mmc_test.c:			if (test->card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
drivers/mmc/card/mmc_test.c:	t->max_segs = test->card->host->max_segs;
drivers/mmc/card/mmc_test.c:	t->max_seg_sz = test->card->host->max_seg_size;
drivers/mmc/card/mmc_test.c:	if (t->max_tfr >> 9 > test->card->host->max_blk_count)
drivers/mmc/card/mmc_test.c:		t->max_tfr = test->card->host->max_blk_count << 9;
drivers/mmc/card/mmc_test.c:	if (t->max_tfr > test->card->host->max_req_size)
drivers/mmc/card/mmc_test.c:		t->max_tfr = test->card->host->max_req_size;
drivers/mmc/card/mmc_test.c:	void *pre_req = test->card->host->ops->pre_req;
drivers/mmc/card/mmc_test.c:	void *post_req = test->card->host->ops->post_req;
drivers/mmc/card/queue.c:	if ((mmc_can_sanitize(card) && (host->caps2 & MMC_CAP2_SANITIZE)))
drivers/mmc/card/queue.c:	if (host->max_segs == 1) {
drivers/mmc/card/queue.c:		if (bouncesz > host->max_req_size)
drivers/mmc/card/queue.c:			bouncesz = host->max_req_size;
drivers/mmc/card/queue.c:		if (bouncesz > host->max_seg_size)
drivers/mmc/card/queue.c:			bouncesz = host->max_seg_size;
drivers/mmc/card/queue.c:		if (bouncesz > (host->max_blk_count * 512))
drivers/mmc/card/queue.c:			bouncesz = host->max_blk_count * 512;
drivers/mmc/card/queue.c:			min(host->max_blk_count, host->max_req_size / 512));
drivers/mmc/card/queue.c:		blk_queue_max_segments(mq->queue, host->max_segs);
drivers/mmc/card/queue.c:		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
drivers/mmc/card/queue.c:		mqrq_cur->sg = mmc_alloc_sg(host->max_segs, &ret);
drivers/mmc/card/queue.c:		mqrq_prev->sg = mmc_alloc_sg(host->max_segs, &ret);
drivers/mmc/card/queue.c:                       host->index, subname ? subname : "");
drivers/mmc/core/cd-gpio.c:	size_t len = strlen(dev_name(host->parent)) + 4;
drivers/mmc/core/cd-gpio.c:	snprintf(cd->label, len, "%s cd", dev_name(host->parent));
drivers/mmc/core/cd-gpio.c:	host->hotplug.irq = irq;
drivers/mmc/core/cd-gpio.c:	host->hotplug.handler_priv = cd;
drivers/mmc/core/cd-gpio.c:	struct mmc_cd_gpio *cd = host->hotplug.handler_priv;
drivers/mmc/core/cd-gpio.c:	free_irq(host->hotplug.irq, host);
drivers/mmc/core/core.c:	    !should_fail(&host->fail_mmc_request, data->blksz * data->blocks))
drivers/mmc/core/core.c:	if (host->card && host->clk_scaling.enable)
drivers/mmc/core/core.c:		host->clk_scaling.busy_time_us +=
drivers/mmc/core/core.c:					host->clk_scaling.start_busy));
drivers/mmc/core/core.c:	if (err && cmd->retries && !mmc_card_removed(host->card)) {
drivers/mmc/core/core.c:			if (host->perf_enable) {
drivers/mmc/core/core.c:				diff = ktime_sub(ktime_get(), host->perf.start);
drivers/mmc/core/core.c:				if (host->tp_enable)
drivers/mmc/core/core.c:					trace_mmc_request_done(&host->class_dev,
drivers/mmc/core/core.c:					host->perf.rbytes_drv +=
drivers/mmc/core/core.c:					host->perf.rtime_drv =
drivers/mmc/core/core.c:						ktime_add(host->perf.rtime_drv,
drivers/mmc/core/core.c:					host->perf.wbytes_drv +=
drivers/mmc/core/core.c:					host->perf.wtime_drv =
drivers/mmc/core/core.c:						ktime_add(host->perf.wtime_drv,
drivers/mmc/core/core.c:			if (host->tp_enable)
drivers/mmc/core/core.c:				trace_mmc_req_end(&host->class_dev, cmd->opcode);
drivers/mmc/core/core.c:		if (host->tp_enable)
drivers/mmc/core/core.c:			trace_mmc_req_start(&host->class_dev, mrq->cmd->opcode,
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:		BUG_ON(mrq->data->blksz > host->max_blk_size);
drivers/mmc/core/core.c:		BUG_ON(mrq->data->blocks > host->max_blk_count);
drivers/mmc/core/core.c:			host->max_req_size);
drivers/mmc/core/core.c:		if (host->perf_enable)
drivers/mmc/core/core.c:			host->perf.start = ktime_get();
drivers/mmc/core/core.c:	led_trigger_event(host->led, LED_FULL);
drivers/mmc/core/core.c:	if (host->card && host->clk_scaling.enable) {
drivers/mmc/core/core.c:		host->clk_scaling.start_busy = ktime_get();
drivers/mmc/core/core.c:	host->ops->request(host, mrq);
drivers/mmc/core/core.c:	if (!card->ext_csd.bkops_en || !(card->host->caps2 & MMC_CAP2_BKOPS))
drivers/mmc/core/core.c:	if (card->host->bkops_trigger == ENCRYPT_MAGIC_NUMBER)
drivers/mmc/core/core.c:		spin_lock_irqsave(&card->host->lock, flags);
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&card->host->lock, flags);
drivers/mmc/core/core.c:				spin_lock_irqsave(&card->host->lock, flags);
drivers/mmc/core/core.c:				spin_unlock_irqrestore(&card->host->lock, flags);
drivers/mmc/core/core.c:	if (mmc_card_doing_bkops(card) || !mmc_card_need_bkops(card) || card->host->bkops_trigger == ENCRYPT_MAGIC_NUMBER2) {
drivers/mmc/core/core.c:		spin_lock_irqsave(&card->host->lock, flags);
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&card->host->lock, flags);
drivers/mmc/core/core.c:	spin_lock_irqsave(&card->host->lock, flags);
drivers/mmc/core/core.c:		card->host->bkops_trigger = timeout;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&card->host->lock, flags);
drivers/mmc/core/core.c:	if (mmc_card_removed(host->card)) {
drivers/mmc/core/core.c:				mmc_card_removed(host->card))
drivers/mmc/core/core.c:		host->ops->request(host, mrq);
drivers/mmc/core/core.c:	if (host->ops->pre_req) {
drivers/mmc/core/core.c:		host->ops->pre_req(host, mrq, is_first_req);
drivers/mmc/core/core.c:	if (host->ops->post_req) {
drivers/mmc/core/core.c:		host->ops->post_req(host, mrq, err);
drivers/mmc/core/core.c:	struct mmc_async_req *data = host->areq;
drivers/mmc/core/core.c:		mmc_pre_req(host, areq->mrq, !host->areq);
drivers/mmc/core/core.c:	if (host->areq) {
drivers/mmc/core/core.c:		mmc_wait_for_req_done(host, host->areq->mrq);
drivers/mmc/core/core.c:		if (mmc_card_sd(host->card)) {
drivers/mmc/core/core.c:			io_diff = ktime_sub(ktime_get(), host->areq->rq_stime);
drivers/mmc/core/core.c:				mmc_hostname(host), current->comm, host->areq->mrq->cmd->opcode,
drivers/mmc/core/core.c:				host->areq->mrq->cmd->arg , host->areq->mrq->data->blocks , ktime_to_us(io_diff));
drivers/mmc/core/core.c:		err = host->areq->err_check(host->card, host->areq);
drivers/mmc/core/core.c:		if (mmc_card_sd(host->card)) {
drivers/mmc/core/core.c:				mmc_hostname(host), current->comm, host->areq->mrq->cmd->opcode, host->areq->mrq->cmd->arg,
drivers/mmc/core/core.c:				host->areq->mrq->data->blocks, ktime_to_us(wait_diff), ktime_to_us(io_diff));
drivers/mmc/core/core.c:		if (mmc_card_sd(host->card))
drivers/mmc/core/core.c:	if (host->areq)
drivers/mmc/core/core.c:		mmc_post_req(host, host->areq->mrq, 0);
drivers/mmc/core/core.c:		host->areq = NULL;
drivers/mmc/core/core.c:		host->areq = areq;
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:	spin_lock_irqsave(&card->host->lock, flags);
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&card->host->lock, flags);
drivers/mmc/core/core.c:	add_wait_queue(&host->wq, &wait);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:		if (stop || !host->claimed || host->claimer == current)
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:		host->claimed = 1;
drivers/mmc/core/core.c:		host->claimer = current;
drivers/mmc/core/core.c:		host->claim_cnt += 1;
drivers/mmc/core/core.c:		wake_up(&host->wq);
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	remove_wait_queue(&host->wq, &wait);
drivers/mmc/core/core.c:	if (host->ops->enable && !stop && host->claim_cnt == 1)
drivers/mmc/core/core.c:		host->ops->enable(host);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	if (!host->claimed || host->claimer == current) {
drivers/mmc/core/core.c:		host->claimed = 1;
drivers/mmc/core/core.c:		host->claimer = current;
drivers/mmc/core/core.c:		host->claim_cnt += 1;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
drivers/mmc/core/core.c:		host->ops->enable(host);
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:	if (host->ops->disable && host->claim_cnt == 1)
drivers/mmc/core/core.c:		host->ops->disable(host);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	if (--host->claim_cnt) {
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		host->claimed = 0;
drivers/mmc/core/core.c:		host->claimer = NULL;
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		wake_up(&host->wq);
drivers/mmc/core/core.c:	struct mmc_ios *ios = &host->ios;
drivers/mmc/core/core.c:	if (host->card && ((host->card->type == MMC_TYPE_SDIO) || (host->card->type == MMC_TYPE_SDIO_WIFI))) {
drivers/mmc/core/core.c:	host->ops->set_ios(host, ios);
drivers/mmc/core/core.c:	host->ios.chip_select = mode;
drivers/mmc/core/core.c:	WARN_ON(hz < host->f_min);
drivers/mmc/core/core.c:	if (hz > host->f_max)
drivers/mmc/core/core.c:		hz = host->f_max;
drivers/mmc/core/core.c:	host->ios.clock = hz;
drivers/mmc/core/core.c:	WARN_ON(!host->ios.clock);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/core.c:	host->clk_old = host->ios.clock;
drivers/mmc/core/core.c:	host->ios.clock = 0;
drivers/mmc/core/core.c:	host->clk_gated = true;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/core.c:	if (host->clk_old) {
drivers/mmc/core/core.c:		WARN_ON(host->ios.clock);
drivers/mmc/core/core.c:		__mmc_set_clock(host, host->clk_old);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/core.c:	host->clk_gated = false;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/core.c:	host->ios.bus_mode = mode;
drivers/mmc/core/core.c:	host->ios.bus_width = width;
drivers/mmc/core/core.c:	ocr &= host->ocr_avail;
drivers/mmc/core/core.c:		host->ios.vdd = bit;
drivers/mmc/core/core.c:	host->ios.signal_voltage = signal_voltage;
drivers/mmc/core/core.c:	if (host->ops->start_signal_voltage_switch) {
drivers/mmc/core/core.c:		err = host->ops->start_signal_voltage_switch(host, &host->ios);
drivers/mmc/core/core.c:	host->ios.timing = timing;
drivers/mmc/core/core.c:	host->ios.drv_type = drv_type;
drivers/mmc/core/core.c:	if (host->ocr)
drivers/mmc/core/core.c:		bit = ffs(host->ocr) - 1;
drivers/mmc/core/core.c:		bit = fls(host->ocr_avail) - 1;
drivers/mmc/core/core.c:	host->ios.vdd = bit;
drivers/mmc/core/core.c:		host->ios.chip_select = MMC_CS_HIGH;
drivers/mmc/core/core.c:		host->ios.chip_select = MMC_CS_DONTCARE;
drivers/mmc/core/core.c:		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
drivers/mmc/core/core.c:	host->ios.power_mode = MMC_POWER_UP;
drivers/mmc/core/core.c:	host->ios.bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/core/core.c:	host->ios.timing = MMC_TIMING_LEGACY;
drivers/mmc/core/core.c:	host->ios.clock = host->f_init;
drivers/mmc/core/core.c:	host->ios.power_mode = MMC_POWER_ON;
drivers/mmc/core/core.c:	host->ios.clock = 0;
drivers/mmc/core/core.c:	host->ios.vdd = 0;
drivers/mmc/core/core.c:	host->ocr = 1 << (fls(host->ocr_avail) - 1);
drivers/mmc/core/core.c:		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
drivers/mmc/core/core.c:		host->ios.chip_select = MMC_CS_DONTCARE;
drivers/mmc/core/core.c:	host->ios.power_mode = MMC_POWER_OFF;
drivers/mmc/core/core.c:	host->ios.bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/core/core.c:	host->ios.timing = MMC_TIMING_LEGACY;
drivers/mmc/core/core.c:	BUG_ON(host->bus_refs);
drivers/mmc/core/core.c:	BUG_ON(!host->bus_dead);
drivers/mmc/core/core.c:	host->bus_ops = NULL;
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	host->bus_refs++;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	host->bus_refs--;
drivers/mmc/core/core.c:	if ((host->bus_refs == 0) && host->bus_ops)
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
drivers/mmc/core/core.c:	host->rescan_disable = 0;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:		if (host->bus_ops->awake && mmc_card_can_sleep(host)) {
drivers/mmc/core/core.c:			ret = host->bus_ops->awake(host);
drivers/mmc/core/core.c:				BUG_ON(!host->bus_ops->resume);
drivers/mmc/core/core.c:				ret = host->bus_ops->resume(host);
drivers/mmc/core/core.c:			BUG_ON(!host->bus_ops->resume);
drivers/mmc/core/core.c:			ret = host->bus_ops->resume(host);
drivers/mmc/core/core.c:	if (host->bus_ops->detect && !host->bus_dead)
drivers/mmc/core/core.c:		host->bus_ops->detect(host);
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	BUG_ON(host->bus_ops);
drivers/mmc/core/core.c:	BUG_ON(host->bus_refs);
drivers/mmc/core/core.c:	host->bus_ops = ops;
drivers/mmc/core/core.c:	host->bus_refs = 1;
drivers/mmc/core/core.c:	host->bus_dead = 0;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:	WARN_ON(!host->bus_ops);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	host->bus_dead = 1;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	WARN_ON(host->removed);
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	host->detect_change = 1;
drivers/mmc/core/core.c:	wake_lock(&host->detect_wake_lock);
drivers/mmc/core/core.c:	mmc_schedule_delayed_work(&host->detect, delay);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead &&
drivers/mmc/core/core.c:		host->bus_ops->resume) {
drivers/mmc/core/core.c:		if (host->card && mmc_card_sd(host->card)) {
drivers/mmc/core/core.c:		err = host->bus_ops->resume(host);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:		if (host->bus_ops->remove)
drivers/mmc/core/core.c:			host->bus_ops->remove(host);
drivers/mmc/core/core.c:	if (card->host->tp_enable)
drivers/mmc/core/core.c:		trace_mmc_request_done(&(card->host->class_dev), MMC_ERASE,
drivers/mmc/core/core.c:	if (!(card->host->caps & MMC_CAP_ERASE) ||
drivers/mmc/core/core.c:	if ((card->host->caps & MMC_CAP_ERASE) &&
drivers/mmc/core/core.c:		card->host->bus_ops->poweroff_notify &&
drivers/mmc/core/core.c:			if (timeout > host->max_discard_to)
drivers/mmc/core/core.c:	if (!host->max_discard_to)
drivers/mmc/core/core.c:		 mmc_hostname(host), max_discard, host->max_discard_to);
drivers/mmc/core/core.c:	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
drivers/mmc/core/core.c:	host->ops->hw_reset(host);
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	if (!host->bus_ops->power_restore)
drivers/mmc/core/core.c:	if (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->hw_reset)
drivers/mmc/core/core.c:	mmc_set_clock(host, host->f_init);
drivers/mmc/core/core.c:	host->ops->hw_reset(host);
drivers/mmc/core/core.c:	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
drivers/mmc/core/core.c:		host->ios.chip_select = MMC_CS_HIGH;
drivers/mmc/core/core.c:		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
drivers/mmc/core/core.c:		host->ios.chip_select = MMC_CS_DONTCARE;
drivers/mmc/core/core.c:		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
drivers/mmc/core/core.c:	host->ios.bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/core/core.c:	host->ios.timing = MMC_TIMING_LEGACY;
drivers/mmc/core/core.c:	return host->bus_ops->power_restore(host);
drivers/mmc/core/core.c:	host->clk_scaling.busy_time_us = 0;
drivers/mmc/core/core.c:	host->clk_scaling.window_time = jiffies;
drivers/mmc/core/core.c:	if (host->ops && host->ops->get_max_frequency) {
drivers/mmc/core/core.c:		freq = host->ops->get_max_frequency(host);
drivers/mmc/core/core.c:	switch (host->ios.timing) {
drivers/mmc/core/core.c:		freq = host->ios.clock;
drivers/mmc/core/core.c:	if (host->ops && host->ops->get_min_frequency) {
drivers/mmc/core/core.c:		freq = host->ops->get_min_frequency(host);
drivers/mmc/core/core.c:	switch (host->ios.timing) {
drivers/mmc/core/core.c:		freq = host->ios.clock;
drivers/mmc/core/core.c:	if (!host->card || !host->bus_ops ||
drivers/mmc/core/core.c:			!host->bus_ops->change_bus_speed ||
drivers/mmc/core/core.c:			!host->clk_scaling.enable || !host->ios.clock)
drivers/mmc/core/core.c:		queue_delayed_work(system_nrt_wq, &host->clk_scaling.work, 1);
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	if (host->ops->notify_load) {
drivers/mmc/core/core.c:		err = host->ops->notify_load(host, state);
drivers/mmc/core/core.c:	if (freq != host->clk_scaling.curr_freq) {
drivers/mmc/core/core.c:		err = host->bus_ops->change_bus_speed(host, &freq);
drivers/mmc/core/core.c:			host->clk_scaling.curr_freq = freq;
drivers/mmc/core/core.c:		if (host->ops->notify_load)
drivers/mmc/core/core.c:			host->ops->notify_load(host, host->clk_scaling.state);
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	unsigned int up_threshold = host->clk_scaling.up_threshold;
drivers/mmc/core/core.c:	unsigned int down_threshold = host->clk_scaling.down_threshold;
drivers/mmc/core/core.c:	if (!card || !host->bus_ops || !host->bus_ops->change_bus_speed) {
drivers/mmc/core/core.c:	if (!host->ios.clock)
drivers/mmc/core/core.c:	if (time_is_after_jiffies(host->clk_scaling.window_time +
drivers/mmc/core/core.c:			msecs_to_jiffies(host->clk_scaling.polling_delay_ms)))
drivers/mmc/core/core.c:			(long)host->clk_scaling.window_time);
drivers/mmc/core/core.c:	if (unlikely(host->clk_scaling.in_progress))
drivers/mmc/core/core.c:	host->clk_scaling.in_progress = true;
drivers/mmc/core/core.c:	busy_time_ms = host->clk_scaling.busy_time_us / USEC_PER_MSEC;
drivers/mmc/core/core.c:	freq = host->clk_scaling.curr_freq;
drivers/mmc/core/core.c:	state = host->clk_scaling.state;
drivers/mmc/core/core.c:	if (state != host->clk_scaling.state) {
drivers/mmc/core/core.c:						&host->clk_scaling.work);
drivers/mmc/core/core.c:				host->clk_scaling.state = state;
drivers/mmc/core/core.c:					&host->clk_scaling.work, 1);
drivers/mmc/core/core.c:	host->clk_scaling.in_progress = false;
drivers/mmc/core/core.c:	cancel_delayed_work_sync(&host->clk_scaling.work);
drivers/mmc/core/core.c:	host->clk_scaling.enable = false;
drivers/mmc/core/core.c:	return host->clk_scaling.initialized;
drivers/mmc/core/core.c:	if (!host->card || !(host->caps2 & MMC_CAP2_CLK_SCALE))
drivers/mmc/core/core.c:	INIT_DELAYED_WORK(&host->clk_scaling.work, mmc_clk_scale_work);
drivers/mmc/core/core.c:	host->clk_scaling.curr_freq = mmc_get_max_frequency(host);
drivers/mmc/core/core.c:	if (host->ops->notify_load)
drivers/mmc/core/core.c:		host->ops->notify_load(host, MMC_LOAD_HIGH);
drivers/mmc/core/core.c:	host->clk_scaling.state = MMC_LOAD_HIGH;
drivers/mmc/core/core.c:	host->clk_scaling.enable = true;
drivers/mmc/core/core.c:	host->clk_scaling.initialized = true;
drivers/mmc/core/core.c:	cancel_delayed_work_sync(&host->clk_scaling.work);
drivers/mmc/core/core.c:	memset(&host->clk_scaling, 0, sizeof(host->clk_scaling));
drivers/mmc/core/core.c:	host->f_init = freq;
drivers/mmc/core/core.c:		mmc_hostname(host), __func__, host->f_init);
drivers/mmc/core/core.c:	mmc_send_if_cond(host, host->ocr_avail);
drivers/mmc/core/core.c:	if (!host->ios.vdd)
drivers/mmc/core/core.c:	if (!host->ios.vdd)
drivers/mmc/core/core.c:	if ((host->caps & MMC_CAP_NONREMOVABLE) || !host->bus_ops->alive)
drivers/mmc/core/core.c:	if (!host->card || mmc_card_removed(host->card))
drivers/mmc/core/core.c:	ret = host->bus_ops->alive(host);
drivers/mmc/core/core.c:		if(mmc_card_sd(host->card))
drivers/mmc/core/core.c:			host->card->do_remove = 1;
drivers/mmc/core/core.c:			mmc_card_set_removed(host->card);
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	WARN_ON(!host->claimed);
drivers/mmc/core/core.c:	if (!host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL) &&
drivers/mmc/core/core.c:	    !(host->caps2 & MMC_CAP2_DETECT_ON_ERR))
drivers/mmc/core/core.c:	host->detect_change = 0;
drivers/mmc/core/core.c:		if (ret && (host->caps2 & MMC_CAP2_DETECT_ON_ERR)) {
drivers/mmc/core/core.c:			cancel_delayed_work(&host->detect);
drivers/mmc/core/core.c:	if (host->rescan_disable)
drivers/mmc/core/core.c:	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
drivers/mmc/core/core.c:	    && !(host->caps & MMC_CAP_NONREMOVABLE))
drivers/mmc/core/core.c:		host->bus_ops->detect(host);
drivers/mmc/core/core.c:	host->detect_change = 0;
drivers/mmc/core/core.c:	if (host->bus_dead)
drivers/mmc/core/core.c:	if (host->bus_dead)
drivers/mmc/core/core.c:	if (host->bus_ops != NULL) {
drivers/mmc/core/core.c:	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
drivers/mmc/core/core.c:	if (!mmc_rescan_try_freq(host, host->f_min))
drivers/mmc/core/core.c:		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
drivers/mmc/core/core.c:		wake_unlock(&host->detect_wake_lock);
drivers/mmc/core/core.c:	if (host->caps & MMC_CAP_NEEDS_POLL) {
drivers/mmc/core/core.c:		wake_lock(&host->detect_wake_lock);
drivers/mmc/core/core.c:		mmc_schedule_delayed_work(&host->detect, HZ);
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	host->removed = 1;
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	if (cancel_delayed_work_sync(&host->detect))
drivers/mmc/core/core.c:		wake_unlock(&host->detect_wake_lock);
drivers/mmc/core/core.c:	host->pm_flags = 0;
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:		if (mmc_can_poweroff_notify(host->card)) {
drivers/mmc/core/core.c:			int err = host->bus_ops->poweroff_notify(host,
drivers/mmc/core/core.c:		if (host->bus_ops->remove)
drivers/mmc/core/core.c:			host->bus_ops->remove(host);
drivers/mmc/core/core.c:	BUG_ON(host->card);
drivers/mmc/core/core.c:	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
drivers/mmc/core/core.c:	if (host->bus_ops->power_save)
drivers/mmc/core/core.c:		ret = host->bus_ops->power_save(host);
drivers/mmc/core/core.c:	if (mmc_can_poweroff_notify(host->card)) {
drivers/mmc/core/core.c:		int err = host->bus_ops->poweroff_notify(host,
drivers/mmc/core/core.c:	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
drivers/mmc/core/core.c:	ret = host->bus_ops->power_restore(host);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->housekeeping)
drivers/mmc/core/core.c:		err = host->bus_ops->housekeeping(host, 1);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->housekeeping)
drivers/mmc/core/core.c:		err = host->bus_ops->housekeeping(host, 0);
drivers/mmc/core/core.c:	if (card && mmc_card_mmc(card) && (card->ext_csd.rev >= 5 && card->ext_csd.bkops) && (card->host->caps & MMC_CAP_NONREMOVABLE)) {
drivers/mmc/core/core.c:	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake) {
drivers/mmc/core/core.c:		err = host->bus_ops->awake(host);
drivers/mmc/core/core.c:			mmc_card_clr_sleep(host->card);
drivers/mmc/core/core.c:	if (host->caps2 & MMC_CAP2_NO_SLEEP_CMD)
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead && host->bus_ops->sleep) {
drivers/mmc/core/core.c:		err = host->bus_ops->sleep(host);
drivers/mmc/core/core.c:			mmc_card_set_sleep(host->card);
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	if (card && mmc_card_mmc(card) && (card->ext_csd.rev >= 3) && (host->caps & MMC_CAP_NONREMOVABLE))
drivers/mmc/core/core.c:	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL))
drivers/mmc/core/core.c:	struct mmc_card *card = host->card;
drivers/mmc/core/core.c:	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
drivers/mmc/core/core.c:	if (cancel_delayed_work(&host->detect))
drivers/mmc/core/core.c:		wake_unlock(&host->detect_wake_lock);
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:		if (!(host->card && mmc_card_sdio(host->card)))
drivers/mmc/core/core.c:			if (host->bus_ops->suspend) {
drivers/mmc/core/core.c:				if (mmc_card_doing_bkops(host->card))
drivers/mmc/core/core.c:					mmc_interrupt_bkops(host->card);
drivers/mmc/core/core.c:				err = host->bus_ops->suspend(host);
drivers/mmc/core/core.c:			if (!(host->card && mmc_card_sdio(host->card)))
drivers/mmc/core/core.c:			if (err == -ENOSYS || !host->bus_ops->resume) {
drivers/mmc/core/core.c:				if (host->bus_ops->remove)
drivers/mmc/core/core.c:					host->bus_ops->remove(host);
drivers/mmc/core/core.c:				host->pm_flags = 0;
drivers/mmc/core/core.c:               host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
drivers/mmc/core/core.c:	if (!err && !mmc_card_keep_power(host) && !host->bkops_started)
drivers/mmc/core/core.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:	if (host->bkops_alarm_set) {
drivers/mmc/core/core.c:		alarm_cancel(&host->bkops_timer.bkops_alarm_timer);
drivers/mmc/core/core.c:		host->bkops_alarm_set = 0;
drivers/mmc/core/core.c:	if (host->bkops_timer.need_bkops) {
drivers/mmc/core/core.c:		time_bkops_start = host->bkops_timer.bkops_start;
drivers/mmc/core/core.c:			if (host->bkops_timer.need_bkops > time_diff) {
drivers/mmc/core/core.c:				host->bkops_timer.need_bkops -= time_diff;
drivers/mmc/core/core.c:				host->bkops_timer.need_bkops = 0;
drivers/mmc/core/core.c:			mmc_hostname(host), host->bkops_timer.need_bkops, (long unsigned int)time_diff);
drivers/mmc/core/core.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	err = mmc_send_status(host->card, &status);
drivers/mmc/core/core.c:			__func__, status, host->bkops_timer.need_bkops);
drivers/mmc/core/core.c:			err = host->bus_ops->housekeeping(host, 0);
drivers/mmc/core/core.c:					err = mmc_send_status(host->card, &status);
drivers/mmc/core/core.c:						__func__, status, err, host->bkops_timer.need_bkops);
drivers/mmc/core/core.c:					if (host->bkops_timer.need_bkops == 0)
drivers/mmc/core/core.c:						host->bkops_count++;
drivers/mmc/core/core.c:						__func__, status, host->bkops_timer.need_bkops, host->bkops_count);
drivers/mmc/core/core.c:			host->bkops_count++;
drivers/mmc/core/core.c:						__func__, host->bkops_timer.need_bkops, host->bkops_count);
drivers/mmc/core/core.c:			host->bkops_timer.need_bkops = 0;
drivers/mmc/core/core.c:		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
drivers/mmc/core/core.c:	if (host->bus_ops && !host->bus_dead) {
drivers/mmc/core/core.c:			mmc_select_voltage(host, host->ocr);
drivers/mmc/core/core.c:			if (mmc_card_sdio(host->card) &&
drivers/mmc/core/core.c:			    (host->caps & MMC_CAP_POWER_OFF_CARD)) {
drivers/mmc/core/core.c:				pm_runtime_disable(&host->card->dev);
drivers/mmc/core/core.c:				pm_runtime_set_active(&host->card->dev);
drivers/mmc/core/core.c:				pm_runtime_enable(&host->card->dev);
drivers/mmc/core/core.c:		BUG_ON(!host->bus_ops->resume);
drivers/mmc/core/core.c:		err = host->bus_ops->resume(host);
drivers/mmc/core/core.c:	host->pm_flags &= ~MMC_PM_KEEP_POWER;
drivers/mmc/core/core.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		host->rescan_disable = 1;
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		if (cancel_delayed_work_sync(&host->detect))
drivers/mmc/core/core.c:			wake_unlock(&host->detect_wake_lock);
drivers/mmc/core/core.c:		if (!host->bus_ops || host->bus_ops->suspend)
drivers/mmc/core/core.c:		if (mmc_can_poweroff_notify(host->card)) {
drivers/mmc/core/core.c:			int err = host->bus_ops->poweroff_notify(host,
drivers/mmc/core/core.c:		if (host->bus_ops->remove)
drivers/mmc/core/core.c:			host->bus_ops->remove(host);
drivers/mmc/core/core.c:		host->pm_flags = 0;
drivers/mmc/core/core.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/core/core.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:		host->rescan_disable = 0;
drivers/mmc/core/core.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/core/core.c:	host->embedded_sdio_data.cis = cis;
drivers/mmc/core/core.c:	host->embedded_sdio_data.cccr = cccr;
drivers/mmc/core/core.c:	host->embedded_sdio_data.funcs = funcs;
drivers/mmc/core/core.c:	host->embedded_sdio_data.num_funcs = num_funcs;
drivers/mmc/core/debugfs.c:	struct mmc_ios	*ios = &host->ios;
drivers/mmc/core/debugfs.c:	if (host->actual_clock)
drivers/mmc/core/debugfs.c:		seq_printf(s, "actual clock:\t%u Hz\n", host->actual_clock);
drivers/mmc/core/debugfs.c:	*val = host->ios.clock;
drivers/mmc/core/debugfs.c:	if (val > host->f_max)
drivers/mmc/core/debugfs.c:	host->debugfs_root = root;
drivers/mmc/core/debugfs.c:				root, &host->clk_delay))
drivers/mmc/core/debugfs.c:	host->fail_mmc_request = fail_default_attr;
drivers/mmc/core/debugfs.c:					     &host->fail_mmc_request)))
drivers/mmc/core/debugfs.c:	host->debugfs_root = NULL;
drivers/mmc/core/debugfs.c:	dev_err(&host->class_dev, "failed to initialize debugfs\n");
drivers/mmc/core/debugfs.c:	debugfs_remove_recursive(host->debugfs_root);
drivers/mmc/core/debugfs.c:	if (!host->debugfs_root)
drivers/mmc/core/debugfs.c:	root = debugfs_create_dir(mmc_card_id(card), host->debugfs_root);
drivers/mmc/core/debugfs.c:	    (card->host->caps2 & MMC_CAP2_PACKED_WR))
drivers/mmc/core/host.c:			host->clkgate_delay);
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	host->clkgate_delay = value;
drivers/mmc/core/host.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	unsigned long freq = host->ios.clock;
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	if (!host->clk_requests) {
drivers/mmc/core/host.c:		spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:		ndelay(host->clk_delay * tick_ns);
drivers/mmc/core/host.c:		spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	mutex_lock(&host->clk_gate_mutex);
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	if (!host->clk_requests) {
drivers/mmc/core/host.c:		spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:		spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	mutex_unlock(&host->clk_gate_mutex);
drivers/mmc/core/host.c:	cancel_delayed_work_sync(&host->clk_gate_work);
drivers/mmc/core/host.c:	mutex_lock(&host->clk_gate_mutex);
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	if (host->clk_gated) {
drivers/mmc/core/host.c:		spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:		spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	host->clk_requests++;
drivers/mmc/core/host.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	mutex_unlock(&host->clk_gate_mutex);
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	host->clk_requests--;
drivers/mmc/core/host.c:	if (mmc_host_may_gate_card(host->card) &&
drivers/mmc/core/host.c:	    !host->clk_requests)
drivers/mmc/core/host.c:		queue_delayed_work(system_nrt_wq, &host->clk_gate_work,
drivers/mmc/core/host.c:				msecs_to_jiffies(host->clkgate_delay));
drivers/mmc/core/host.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/core/host.c:	if (host->clk_gated)
drivers/mmc/core/host.c:		freq = host->clk_old;
drivers/mmc/core/host.c:		freq = host->ios.clock;
drivers/mmc/core/host.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/core/host.c:	host->clk_requests = 0;
drivers/mmc/core/host.c:	host->clk_delay = 8;
drivers/mmc/core/host.c:	host->clkgate_delay = 0;
drivers/mmc/core/host.c:	host->clk_gated = false;
drivers/mmc/core/host.c:	INIT_DELAYED_WORK(&host->clk_gate_work, mmc_host_clk_gate_work);
drivers/mmc/core/host.c:	spin_lock_init(&host->clk_lock);
drivers/mmc/core/host.c:	mutex_init(&host->clk_gate_mutex);
drivers/mmc/core/host.c:	if (cancel_delayed_work_sync(&host->clk_gate_work))
drivers/mmc/core/host.c:	if (host->clk_gated)
drivers/mmc/core/host.c:	WARN_ON(host->clk_requests > 1);
drivers/mmc/core/host.c:	host->clkgate_delay_attr.show = clkgate_delay_show;
drivers/mmc/core/host.c:	host->clkgate_delay_attr.store = clkgate_delay_store;
drivers/mmc/core/host.c:	sysfs_attr_init(&host->clkgate_delay_attr.attr);
drivers/mmc/core/host.c:	host->clkgate_delay_attr.attr.name = "clkgate_delay";
drivers/mmc/core/host.c:	host->clkgate_delay_attr.attr.mode = S_IRUGO | S_IWUSR;
drivers/mmc/core/host.c:	if (device_create_file(&host->class_dev, &host->clkgate_delay_attr))
drivers/mmc/core/host.c:	err = idr_get_new(&mmc_host_idr, host, &host->index);
drivers/mmc/core/host.c:	dev_set_name(&host->class_dev, "mmc%d", host->index);
drivers/mmc/core/host.c:	host->parent = dev;
drivers/mmc/core/host.c:	host->class_dev.parent = dev;
drivers/mmc/core/host.c:	host->class_dev.class = &mmc_host_class;
drivers/mmc/core/host.c:	device_initialize(&host->class_dev);
drivers/mmc/core/host.c:	spin_lock_init(&host->lock);
drivers/mmc/core/host.c:	init_waitqueue_head(&host->wq);
drivers/mmc/core/host.c:	wake_lock_init(&host->detect_wake_lock, WAKE_LOCK_SUSPEND,
drivers/mmc/core/host.c:	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
drivers/mmc/core/host.c:	INIT_DELAYED_WORK(&host->remove, mmc_remove_sd_card);
drivers/mmc/core/host.c:	host->pm_notify.notifier_call = mmc_pm_notify;
drivers/mmc/core/host.c:	host->max_segs = 1;
drivers/mmc/core/host.c:	host->max_seg_size = PAGE_CACHE_SIZE;
drivers/mmc/core/host.c:	host->max_req_size = PAGE_CACHE_SIZE;
drivers/mmc/core/host.c:	host->max_blk_size = 512;
drivers/mmc/core/host.c:	host->max_blk_count = PAGE_CACHE_SIZE / 512;
drivers/mmc/core/host.c:	if (!host->card || kstrtoul(buf, 0, &value))
drivers/mmc/core/host.c:		host->caps2 |= MMC_CAP2_CLK_SCALE;
drivers/mmc/core/host.c:			host->caps2 &= ~MMC_CAP2_CLK_SCALE;
drivers/mmc/core/host.c:		host->caps2 &= ~MMC_CAP2_CLK_SCALE;
drivers/mmc/core/host.c:		if (host->bus_ops && host->bus_ops->change_bus_speed) {
drivers/mmc/core/host.c:			if (host->bus_ops->change_bus_speed(host, &freq))
drivers/mmc/core/host.c:		if (host->ops->notify_load &&
drivers/mmc/core/host.c:				host->ops->notify_load(host, MMC_LOAD_HIGH))
drivers/mmc/core/host.c:		host->clk_scaling.state = MMC_LOAD_HIGH;
drivers/mmc/core/host.c:		host->clk_scaling.initialized = false;
drivers/mmc/core/host.c:	return snprintf(buf, PAGE_SIZE, "%d\n", host->clk_scaling.up_threshold);
drivers/mmc/core/host.c:	host->clk_scaling.up_threshold = value;
drivers/mmc/core/host.c:			host->clk_scaling.down_threshold);
drivers/mmc/core/host.c:	host->clk_scaling.down_threshold = value;
drivers/mmc/core/host.c:			host->clk_scaling.polling_delay_ms);
drivers/mmc/core/host.c:	host->clk_scaling.polling_delay_ms = value;
drivers/mmc/core/host.c:	spin_lock(&host->lock);
drivers/mmc/core/host.c:	rbytes_drv = host->perf.rbytes_drv;
drivers/mmc/core/host.c:	wbytes_drv = host->perf.wbytes_drv;
drivers/mmc/core/host.c:	rtime_drv = ktime_to_us(host->perf.rtime_drv);
drivers/mmc/core/host.c:	wtime_drv = ktime_to_us(host->perf.wtime_drv);
drivers/mmc/core/host.c:	spin_unlock(&host->lock);
drivers/mmc/core/host.c:	spin_lock(&host->lock);
drivers/mmc/core/host.c:		memset(&host->perf, 0, sizeof(host->perf));
drivers/mmc/core/host.c:		host->perf_enable = false;
drivers/mmc/core/host.c:		host->perf_enable = true;
drivers/mmc/core/host.c:	spin_unlock(&host->lock);
drivers/mmc/core/host.c:	return sprintf(buf, "%d", host->burst_mode);
drivers/mmc/core/host.c:	if (!host || !host->card || !host->card->mmcblk_dev)
drivers/mmc/core/host.c:	host->burst_mode = (buf[0] == '0') ? 0 : 1;
drivers/mmc/core/host.c:	pr_info("%s: %d\n", __func__, host->burst_mode);
drivers/mmc/core/host.c:	if (!host->burst_mode) {
drivers/mmc/core/host.c:	kobject_uevent_env(&host->card->mmcblk_dev->kobj, KOBJ_CHANGE, envp);
drivers/mmc/core/host.c:	WARN_ON((host->caps & MMC_CAP_SDIO_IRQ) &&
drivers/mmc/core/host.c:		!host->ops->enable_sdio_irq);
drivers/mmc/core/host.c:	err = device_add(&host->class_dev);
drivers/mmc/core/host.c:	host->clk_scaling.up_threshold = 35;
drivers/mmc/core/host.c:	host->clk_scaling.down_threshold = 5;
drivers/mmc/core/host.c:	host->clk_scaling.polling_delay_ms = 100;
drivers/mmc/core/host.c:	err = sysfs_create_group(&host->class_dev.kobj, &clk_scaling_attr_grp);
drivers/mmc/core/host.c:	err = sysfs_create_group(&host->parent->kobj, &dev_attr_grp);
drivers/mmc/core/host.c:	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
drivers/mmc/core/host.c:		register_pm_notifier(&host->pm_notify);
drivers/mmc/core/host.c:	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
drivers/mmc/core/host.c:		unregister_pm_notifier(&host->pm_notify);
drivers/mmc/core/host.c:	sysfs_remove_group(&host->parent->kobj, &dev_attr_grp);
drivers/mmc/core/host.c:	sysfs_remove_group(&host->class_dev.kobj, &clk_scaling_attr_grp);
drivers/mmc/core/host.c:	device_del(&host->class_dev);
drivers/mmc/core/host.c:	idr_remove(&mmc_host_idr, host->index);
drivers/mmc/core/host.c:	wake_lock_destroy(&host->detect_wake_lock);
drivers/mmc/core/host.c:	put_device(&host->class_dev);
drivers/mmc/core/mmc.c:	unsigned int caps = host->caps, caps2 = host->caps2;
drivers/mmc/core/mmc.c:					card->host->caps2 & MMC_CAP2_INIT_BKOPS) {
drivers/mmc/core/mmc.c:	switch (1 << host->ios.vdd) {
drivers/mmc/core/mmc.c:		if (host->ios.clock <= 26000000)
drivers/mmc/core/mmc.c:		else if	(host->ios.clock <= 52000000)
drivers/mmc/core/mmc.c:		else if (host->ios.clock <= 200000000)
drivers/mmc/core/mmc.c:		if (host->ios.clock <= 26000000)
drivers/mmc/core/mmc.c:		else if	(host->ios.clock <= 52000000)
drivers/mmc/core/mmc.c:		else if (host->ios.clock <= 200000000)
drivers/mmc/core/mmc.c:	    host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
drivers/mmc/core/mmc.c:	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
drivers/mmc/core/mmc.c:		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
drivers/mmc/core/mmc.c:	card = host->card;
drivers/mmc/core/mmc.c:	if (*freq < host->f_min)
drivers/mmc/core/mmc.c:		*freq = host->f_min;
drivers/mmc/core/mmc.c:	if (mmc_card_hs200(card) && card->host->ops->execute_tuning) {
drivers/mmc/core/mmc.c:		err = card->host->ops->execute_tuning(card->host,
drivers/mmc/core/mmc.c:	WARN_ON(!host->claimed);
drivers/mmc/core/mmc.c:	    (card->ext_csd.rev >= 3 && (host->caps2 & MMC_CAP2_HC_ERASE_SZ))) {
drivers/mmc/core/mmc.c:	if ((host->caps2 & MMC_CAP2_POWEROFF_NOTIFY) &&
drivers/mmc/core/mmc.c:		    host->caps2 & MMC_CAP2_HS200)
drivers/mmc/core/mmc.c:		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
drivers/mmc/core/mmc.c:			    host->caps2 & MMC_CAP2_HS200) {
drivers/mmc/core/mmc.c:			&& ((host->caps & (MMC_CAP_1_8V_DDR |
drivers/mmc/core/mmc.c:			&& ((host->caps & (MMC_CAP_1_2V_DDR |
drivers/mmc/core/mmc.c:		u32 bus_width = card->host->ios.bus_width;
drivers/mmc/core/mmc.c:		if ((host->caps2 & MMC_CAP2_HS200) &&
drivers/mmc/core/mmc.c:		    card->host->ops->execute_tuning) {
drivers/mmc/core/mmc.c:			err = card->host->ops->execute_tuning(card->host,
drivers/mmc/core/mmc.c:	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
drivers/mmc/core/mmc.c:		if (host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/mmc.c:				if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST)) {
drivers/mmc/core/mmc.c:	if ((host->caps2 & MMC_CAP2_CACHE_CTRL) &&
drivers/mmc/core/mmc.c:	if ((host->caps2 & MMC_CAP2_PACKED_CMD) &&
drivers/mmc/core/mmc.c:		if ((host->caps2 & MMC_CAP2_PACKED_CMD) &&
drivers/mmc/core/mmc.c:		host->card = card;
drivers/mmc/core/mmc.c:	card = host->card;
drivers/mmc/core/mmc.c:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:	mmc_remove_card(host->card);
drivers/mmc/core/mmc.c:	host->card = NULL;
drivers/mmc/core/mmc.c:	return mmc_send_status(host->card, NULL);
drivers/mmc/core/mmc.c:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:	memcpy(&host->saved_ios, &host->ios, sizeof(struct mmc_ios));
drivers/mmc/core/mmc.c:	memcpy(&host->ios, &host->saved_ios, sizeof(struct mmc_ios));
drivers/mmc/core/mmc.c:	return mmc_bkops(host->card, start);
drivers/mmc/core/mmc.c:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:	if (mmc_can_poweroff_notify(host->card) &&
drivers/mmc/core/mmc.c:		(host->caps2 & MMC_CAP2_POWER_OFF_VCCQ_DURING_SUSPEND)) {
drivers/mmc/core/mmc.c:		if (host->bkops_started) {
drivers/mmc/core/mmc.c:			host->bkops_trigger = 0;
drivers/mmc/core/mmc.c:		host->card->state &=
drivers/mmc/core/mmc.c:	BUG_ON(!host->card);
drivers/mmc/core/mmc.c:	if (mmc_card_is_sleep(host->card)) {
drivers/mmc/core/mmc.c:		err = mmc_init_card(host, host->ocr, host->card);
drivers/mmc/core/mmc.c:	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
drivers/mmc/core/mmc.c:	mmc_card_clr_sleep(host->card);
drivers/mmc/core/mmc.c:	ret = mmc_init_card(host, host->ocr, host->card);
drivers/mmc/core/mmc.c:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc.c:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc.c:			(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
drivers/mmc/core/mmc.c:				&& ((host->caps & (MMC_CAP_1_8V_DDR |
drivers/mmc/core/mmc.c:				&& ((host->caps & (MMC_CAP_1_2V_DDR |
drivers/mmc/core/mmc.c:			(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
drivers/mmc/core/mmc.c:			if (host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/mmc.c:	WARN_ON(!host->claimed);
drivers/mmc/core/mmc.c:	if (host->ocr_avail_mmc)
drivers/mmc/core/mmc.c:		host->ocr_avail = host->ocr_avail_mmc;
drivers/mmc/core/mmc.c:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/mmc.c:	if (!host->ocr) {
drivers/mmc/core/mmc.c:	err = mmc_init_card(host, host->ocr, NULL);
drivers/mmc/core/mmc.c:	err = mmc_add_card(host->card);
drivers/mmc/core/mmc.c:	mmc_remove_card(host->card);
drivers/mmc/core/mmc.c:	host->card = NULL;
drivers/mmc/core/mmc_ops.c:	struct mmc_card *card = host->card;
drivers/mmc/core/mmc_ops.c:	if (!(host->caps & MMC_CAP_WAIT_WHILE_BUSY))
drivers/mmc/core/mmc_ops.c:	host->use_spi_crc = 0;
drivers/mmc/core/mmc_ops.c:		if (!host->card)
drivers/mmc/core/mmc_ops.c:		return mmc_send_cxd_native(host, host->card->rca << 16,
drivers/mmc/core/mmc_ops.c:		host->use_spi_crc = use_crc;
drivers/mmc/core/mmc_ops.c:		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
drivers/mmc/core/mmc_ops.c:		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
drivers/mmc/core/sd.c:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
drivers/mmc/core/sd.c:	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
drivers/mmc/core/sd.c:	if (!card->host->ops->select_drive_strength)
drivers/mmc/core/sd.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
drivers/mmc/core/sd.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
drivers/mmc/core/sd.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
drivers/mmc/core/sd.c:	drive_strength = card->host->ops->select_drive_strength(
drivers/mmc/core/sd.c:	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
drivers/mmc/core/sd.c:	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
drivers/mmc/core/sd.c:	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sd.c:		if (card->host->caps & MMC_CAP_MAX_CURRENT_800) {
drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_600) {
drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_400) {
drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_200) {
drivers/mmc/core/sd.c:	card = host->card;
drivers/mmc/core/sd.c:	if (*freq < host->f_min)
drivers/mmc/core/sd.c:		*freq = host->f_min;
drivers/mmc/core/sd.c:			&& card->host->ops->execute_tuning) {
drivers/mmc/core/sd.c:		err = card->host->ops->execute_tuning(card->host,
drivers/mmc/core/sd.c:	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
drivers/mmc/core/sd.c:	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning) {
drivers/mmc/core/sd.c:		err = card->host->ops->execute_tuning(card->host,
drivers/mmc/core/sd.c:	if (host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
drivers/mmc/core/sd.c:	if (host->caps & (MMC_CAP_SET_XPC_330 | MMC_CAP_SET_XPC_300 |
drivers/mmc/core/sd.c:		if (host->ops->get_ro) {
drivers/mmc/core/sd.c:			ro = host->ops->get_ro(host);
drivers/mmc/core/sd.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sd.c:		if (host->ops->enable_preset_value) {
drivers/mmc/core/sd.c:			host->ops->enable_preset_value(host, true);
drivers/mmc/core/sd.c:		if ((host->caps & MMC_CAP_4_BIT_DATA) &&
drivers/mmc/core/sd.c:	host->card = card;
drivers/mmc/core/sd.c:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:	mmc_remove_card(host->card);
drivers/mmc/core/sd.c:	host->card = NULL;
drivers/mmc/core/sd.c:	return !host->ops->get_cd(host);
drivers/mmc/core/sd.c:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:		err = mmc_send_status(host->card, NULL);
drivers/mmc/core/sd.c:		host->card->do_remove = 1;
drivers/mmc/core/sd.c:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/sd.c:	BUG_ON(!host->card);
drivers/mmc/core/sd.c:		err = mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:			mmc_select_voltage(host, host->ocr);
drivers/mmc/core/sd.c:			if (host->ops->get_cd && host->ops->get_cd(host) == 0) {
drivers/mmc/core/sd.c:	err = mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
drivers/mmc/core/sd.c:	ret = mmc_sd_init_card(host, host->ocr, host->card);
drivers/mmc/core/sd.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sd.c:	if (host->ops->enable_preset_value) {
drivers/mmc/core/sd.c:		host->ops->enable_preset_value(host, false);
drivers/mmc/core/sd.c:	if (host->ocr_avail_sd)
drivers/mmc/core/sd.c:		host->ocr_avail = host->ocr_avail_sd;
drivers/mmc/core/sd.c:	    !(host->ocr_avail_sd & MMC_VDD_165_195)) {
drivers/mmc/core/sd.c:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sd.c:	if (!host->ocr) {
drivers/mmc/core/sd.c:		err = mmc_sd_init_card(host, host->ocr, NULL);
drivers/mmc/core/sd.c:			mmc_select_voltage(host, host->ocr);
drivers/mmc/core/sd.c:			if (host->ops->get_cd && host->ops->get_cd(host) == 0) {
drivers/mmc/core/sd.c:	err = mmc_sd_init_card(host, host->ocr, NULL);
drivers/mmc/core/sd.c:	err = mmc_add_card(host->card);
drivers/mmc/core/sd.c:	mmc_remove_card(host->card);
drivers/mmc/core/sd.c:	host->card = NULL;
drivers/mmc/core/sdio.c:			if (card->host->caps &
drivers/mmc/core/sdio.c:	if (!(card->host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
drivers/mmc/core/sdio.c:	if (card->host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/sdio.c:	else if (card->host->caps & MMC_CAP_4_BIT_DATA)
drivers/mmc/core/sdio.c:	if (!(card->host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
drivers/mmc/core/sdio.c:	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
drivers/mmc/core/sdio.c:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
drivers/mmc/core/sdio.c:	if (!(card->host->caps &
drivers/mmc/core/sdio.c:	if (!card->host->ops->select_drive_strength)
drivers/mmc/core/sdio.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
drivers/mmc/core/sdio.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
drivers/mmc/core/sdio.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
drivers/mmc/core/sdio.c:	drive_strength = card->host->ops->select_drive_strength(
drivers/mmc/core/sdio.c:	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
drivers/mmc/core/sdio.c:	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
drivers/mmc/core/sdio.c:	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
drivers/mmc/core/sdio.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sdio.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sdio.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
drivers/mmc/core/sdio.c:	if (card->host->caps & MMC_CAP_4_BIT_DATA) {
drivers/mmc/core/sdio.c:	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
drivers/mmc/core/sdio.c:		err = card->host->ops->execute_tuning(card->host,
drivers/mmc/core/sdio.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio.c:		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
drivers/mmc/core/sdio.c:	    mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {
drivers/mmc/core/sdio.c:	if (host->ops->init_card) {
drivers/mmc/core/sdio.c:		host->ops->init_card(host, card);
drivers/mmc/core/sdio.c:		(host->caps &
drivers/mmc/core/sdio.c:			host->ocr &= ~R4_18V_PRESENT;
drivers/mmc/core/sdio.c:		host->ocr &= ~R4_18V_PRESENT;
drivers/mmc/core/sdio.c:	if (host->embedded_sdio_data.cccr)
drivers/mmc/core/sdio.c:		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
drivers/mmc/core/sdio.c:	if (host->embedded_sdio_data.cis)
drivers/mmc/core/sdio.c:		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
drivers/mmc/core/sdio.c:			if (card->host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/sdio.c:			else if (card->host->caps & MMC_CAP_4_BIT_DATA)
drivers/mmc/core/sdio.c:		host->card = card;
drivers/mmc/core/sdio.c:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:	for (i = 0;i < host->card->sdio_funcs;i++) {
drivers/mmc/core/sdio.c:		if (host->card->sdio_func[i]) {
drivers/mmc/core/sdio.c:			sdio_remove_func(host->card->sdio_func[i]);
drivers/mmc/core/sdio.c:			host->card->sdio_func[i] = NULL;
drivers/mmc/core/sdio.c:	mmc_remove_card(host->card);
drivers/mmc/core/sdio.c:	host->card = NULL;
drivers/mmc/core/sdio.c:	return mmc_select_card(host->card);
drivers/mmc/core/sdio.c:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
drivers/mmc/core/sdio.c:		err = pm_runtime_get_sync(&host->card->dev);
drivers/mmc/core/sdio.c:	if (host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio.c:		pm_runtime_put_sync(&host->card->dev);
drivers/mmc/core/sdio.c:	for (i = 0; i < host->card->sdio_funcs; i++) {
drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:		sdio_disable_wide(host->card);
drivers/mmc/core/sdio.c:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:		err = mmc_sdio_init_card(host, host->ocr, host->card,
drivers/mmc/core/sdio.c:		err = sdio_enable_4bit_bus(host->card);
drivers/mmc/core/sdio.c:			if (host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/sdio.c:			else if (host->caps & MMC_CAP_4_BIT_DATA)
drivers/mmc/core/sdio.c:	if (!err && host->sdio_irqs)
drivers/mmc/core/sdio.c:		wake_up_process(host->sdio_irq_thread);
drivers/mmc/core/sdio.c:	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
drivers/mmc/core/sdio.c:	BUG_ON(!host->card);
drivers/mmc/core/sdio.c:	mmc_send_if_cond(host, host->ocr_avail);
drivers/mmc/core/sdio.c:	if (host->ocr_avail_sdio)
drivers/mmc/core/sdio.c:		host->ocr_avail = host->ocr_avail_sdio;
drivers/mmc/core/sdio.c:	host->ocr = mmc_select_voltage(host, ocr & ~0x7F);
drivers/mmc/core/sdio.c:	if (!host->ocr) {
drivers/mmc/core/sdio.c:	if (host->caps &
drivers/mmc/core/sdio.c:		 host->ocr |= R4_18V_PRESENT;
drivers/mmc/core/sdio.c:	ret = mmc_sdio_init_card(host, host->ocr, host->card,
drivers/mmc/core/sdio.c:	if (!ret && host->sdio_irqs)
drivers/mmc/core/sdio.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio.c:	if (host->ocr_avail_sdio)
drivers/mmc/core/sdio.c:		host->ocr_avail = host->ocr_avail_sdio;
drivers/mmc/core/sdio.c:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sdio.c:	if (!host->ocr) {
drivers/mmc/core/sdio.c:	if (host->caps & MMC_CAP_UHS_SDR104) {
drivers/mmc/core/sdio.c:		host->ocr |= R4_18V_PRESENT;
drivers/mmc/core/sdio.c:	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
drivers/mmc/core/sdio.c:			host->ocr &= ~R4_18V_PRESENT;
drivers/mmc/core/sdio.c:			err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
drivers/mmc/core/sdio.c:	card = host->card;
drivers/mmc/core/sdio.c:	if (host->caps & MMC_CAP_POWER_OFF_CARD) {
drivers/mmc/core/sdio.c:	if (host->embedded_sdio_data.funcs)
drivers/mmc/core/sdio.c:		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
drivers/mmc/core/sdio.c:		if (host->embedded_sdio_data.funcs) {
drivers/mmc/core/sdio.c:			tmp = sdio_alloc_func(host->card);
drivers/mmc/core/sdio.c:			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
drivers/mmc/core/sdio.c:			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
drivers/mmc/core/sdio.c:			err = sdio_init_func(host->card, i + 1);
drivers/mmc/core/sdio.c:		if (host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio.c:	err = mmc_add_card(host->card);
drivers/mmc/core/sdio.c:		err = sdio_add_func(host->card->sdio_func[i]);
drivers/mmc/core/sdio.c:	if (host->card)
drivers/mmc/core/sdio.c:	mmc_set_clock(host, host->f_min);
drivers/mmc/core/sdio.c:	host->ocr = mmc_select_voltage(host, ocr);
drivers/mmc/core/sdio.c:	if (!host->ocr) {
drivers/mmc/core/sdio.c:	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
drivers/mmc/core/sdio.c:		if (host->caps & MMC_CAP_8_BIT_DATA)
drivers/mmc/core/sdio.c:		else if (host->caps & MMC_CAP_4_BIT_DATA)
drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
drivers/mmc/core/sdio_bus.c:	if (!func->card->host->embedded_sdio_data.funcs)
drivers/mmc/core/sdio_io.c:	if (blksz > func->card->host->max_blk_size)
drivers/mmc/core/sdio_io.c:		blksz = min(func->max_blksize, func->card->host->max_blk_size);
drivers/mmc/core/sdio_io.c:	unsigned mval =	min(func->card->host->max_seg_size,
drivers/mmc/core/sdio_io.c:			    func->card->host->max_blk_size);
drivers/mmc/core/sdio_io.c:		max_blocks = min(func->card->host->max_blk_count,
drivers/mmc/core/sdio_io.c:			func->card->host->max_seg_size / func->cur_blksize);
drivers/mmc/core/sdio_io.c:	return func->card->host->pm_caps;
drivers/mmc/core/sdio_io.c:	if (flags & ~host->pm_caps)
drivers/mmc/core/sdio_io.c:	host->pm_flags |= flags;
drivers/mmc/core/sdio_irq.c:	struct mmc_card *card = host->card;
drivers/mmc/core/sdio_irq.c:	if (func && host->sdio_irq_pending) {
drivers/mmc/core/sdio_irq.c:	period = (host->caps & MMC_CAP_SDIO_IRQ) ?
drivers/mmc/core/sdio_irq.c:		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
drivers/mmc/core/sdio_irq.c:		host->sdio_irq_pending = false;
drivers/mmc/core/sdio_irq.c:		if (!(host->caps & MMC_CAP_SDIO_IRQ)) {
drivers/mmc/core/sdio_irq.c:		if (host->caps & MMC_CAP_SDIO_IRQ) {
drivers/mmc/core/sdio_irq.c:			host->ops->enable_sdio_irq(host, 1);
drivers/mmc/core/sdio_irq.c:	if (host->caps & MMC_CAP_SDIO_IRQ) {
drivers/mmc/core/sdio_irq.c:		host->ops->enable_sdio_irq(host, 0);
drivers/mmc/core/sdio_irq.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio_irq.c:	if (!host->sdio_irqs++) {
drivers/mmc/core/sdio_irq.c:		atomic_set(&host->sdio_irq_thread_abort, 0);
drivers/mmc/core/sdio_irq.c:		host->sdio_irq_thread =
drivers/mmc/core/sdio_irq.c:		if (IS_ERR(host->sdio_irq_thread)) {
drivers/mmc/core/sdio_irq.c:			int err = PTR_ERR(host->sdio_irq_thread);
drivers/mmc/core/sdio_irq.c:			host->sdio_irqs--;
drivers/mmc/core/sdio_irq.c:	WARN_ON(!host->claimed);
drivers/mmc/core/sdio_irq.c:	BUG_ON(host->sdio_irqs < 1);
drivers/mmc/core/sdio_irq.c:	if (!--host->sdio_irqs) {
drivers/mmc/core/sdio_irq.c:		atomic_set(&host->sdio_irq_thread_abort, 1);
drivers/mmc/core/sdio_irq.c:		kthread_stop(host->sdio_irq_thread);
drivers/mmc/core/sdio_irq.c:	if ((card->host->caps & MMC_CAP_SDIO_IRQ) &&
drivers/mmc/core/sdio_irq.c:			card->host->sdio_irqs == 1)
drivers/mmc/host/at91_mci.c:	if (host->request) {
drivers/mmc/host/at91_mci.c:		dev_err(host->mmc->parent, "Timeout waiting end of packet\n");
drivers/mmc/host/at91_mci.c:		if (host->cmd && host->cmd->data) {
drivers/mmc/host/at91_mci.c:			host->cmd->data->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:			if (host->cmd)
drivers/mmc/host/at91_mci.c:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:				host->request->cmd->error = -ETIMEDOUT;
drivers/mmc/host/at91_mci.c:		mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:	unsigned *dmabuf = host->buffer;
drivers/mmc/host/at91_mci.c:		if (host->total_length == 12)
drivers/mmc/host/at91_mci.c:	unsigned *dmabuf = host->buffer;
drivers/mmc/host/at91_mci.c:	cmd = host->cmd;
drivers/mmc/host/at91_mci.c:	cmd = host->cmd;
drivers/mmc/host/at91_mci.c:	if (host->request->cmd && host->request->cmd->error != 0)
drivers/mmc/host/at91_mci.c:	if (host->request->data) {
drivers/mmc/host/at91_mci.c:		data = host->request->data;
drivers/mmc/host/at91_mci.c:				data->bytes_xfered, host->total_length);
drivers/mmc/host/at91_mci.c:	if (!host->cmd)
drivers/mmc/host/at91_mci.c:	else if (!host->cmd->data) {
drivers/mmc/host/at91_mci.c:		if (host->flags & FL_SENT_STOP) {
drivers/mmc/host/at91_mci.c:	} else if (host->cmd->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/at91_mci.c:	at91_mci_write(host, AT91_MCI_SDCR, host->board->slot_b);
drivers/mmc/host/at91_mci.c:	host->cmd = cmd;
drivers/mmc/host/at91_mci.c:				mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:				mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:	if (host->flags & FL_SENT_STOP)
drivers/mmc/host/at91_mci.c:	if (host->bus_mode == MMC_BUSMODE_OPENDRAIN)
drivers/mmc/host/at91_mci.c:			host->transfer_index = 0;
drivers/mmc/host/at91_mci.c:			host->in_use_index = 0;
drivers/mmc/host/at91_mci.c:				host->total_length = 0;
drivers/mmc/host/at91_mci.c:				at91_mci_write(host, ATMEL_PDC_RPR, host->physical_address);
drivers/mmc/host/at91_mci.c:				host->total_length = block_length * blocks;
drivers/mmc/host/at91_mci.c:					if (host->total_length < 12)
drivers/mmc/host/at91_mci.c:						host->total_length = 12;
drivers/mmc/host/at91_mci.c:				pr_debug("Transmitting %d bytes\n", host->total_length);
drivers/mmc/host/at91_mci.c:				at91_mci_write(host, ATMEL_PDC_TPR, host->physical_address);
drivers/mmc/host/at91_mci.c:						host->total_length : host->total_length / 4);
drivers/mmc/host/at91_mci.c:	if (!(host->flags & FL_SENT_COMMAND)) {
drivers/mmc/host/at91_mci.c:		host->flags |= FL_SENT_COMMAND;
drivers/mmc/host/at91_mci.c:		at91_mci_send_command(host, host->request->cmd);
drivers/mmc/host/at91_mci.c:	else if ((!(host->flags & FL_SENT_STOP)) && host->request->stop) {
drivers/mmc/host/at91_mci.c:		host->flags |= FL_SENT_STOP;
drivers/mmc/host/at91_mci.c:		at91_mci_send_command(host, host->request->stop);
drivers/mmc/host/at91_mci.c:		del_timer(&host->timer);
drivers/mmc/host/at91_mci.c:		mmc_request_done(host->mmc, host->request);
drivers/mmc/host/at91_mci.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/at91_mci.c:	host->request = mrq;
drivers/mmc/host/at91_mci.c:	host->flags = 0;
drivers/mmc/host/at91_mci.c:	mod_timer(&host->timer, jiffies +  msecs_to_jiffies(2000));
drivers/mmc/host/at91_mci.c:	unsigned long at91_master_clock = clk_get_rate(host->mci_clk);
drivers/mmc/host/at91_mci.c:	host->bus_mode = ios->bus_mode;
drivers/mmc/host/at91_mci.c:	if (ios->bus_width == MMC_BUS_WIDTH_4 && host->board->wire4) {
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->vcc_pin)) {
drivers/mmc/host/at91_mci.c:				gpio_set_value(host->board->vcc_pin, 0);
drivers/mmc/host/at91_mci.c:				gpio_set_value(host->board->vcc_pin, 1);
drivers/mmc/host/at91_mci.c:			if (host->request->data && host->request->data->blocks > 1) {
drivers/mmc/host/at91_mci.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/at91_mci.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/at91_mci.c:	present = !gpio_get_value(host->board->det_pin);
drivers/mmc/host/at91_mci.c:	if (present != host->present) {
drivers/mmc/host/at91_mci.c:		host->present = present;
drivers/mmc/host/at91_mci.c:		pr_debug("%s: card %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/at91_mci.c:		mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->wp_pin))
drivers/mmc/host/at91_mci.c:		return !!gpio_get_value(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:	pr_debug("%s: sdio_irq %c : %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/at91_mci.c:		host->board->slot_b ? 'B':'A', enable ? "enable" : "disable");
drivers/mmc/host/at91_mci.c:		host->board->slot_b ? AT91_MCI_SDIOIRQB : AT91_MCI_SDIOIRQA);
drivers/mmc/host/at91_mci.c:	host->mmc = mmc;
drivers/mmc/host/at91_mci.c:	host->bus_mode = 0;
drivers/mmc/host/at91_mci.c:	host->board = pdev->dev.platform_data;
drivers/mmc/host/at91_mci.c:	if (host->board->wire4) {
drivers/mmc/host/at91_mci.c:	host->buffer = dma_alloc_coherent(&pdev->dev, MCI_BUFSIZE,
drivers/mmc/host/at91_mci.c:					&host->physical_address, GFP_KERNEL);
drivers/mmc/host/at91_mci.c:	if (!host->buffer) {
drivers/mmc/host/at91_mci.c:		if (host->board->wire4 || !host->board->slot_b)
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin)) {
drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->det_pin, "mmc_detect");
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->wp_pin)) {
drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->wp_pin, "mmc_wp");
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->vcc_pin)) {
drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->vcc_pin, "mmc_vcc");
drivers/mmc/host/at91_mci.c:	host->mci_clk = clk_get(&pdev->dev, "mci_clk");
drivers/mmc/host/at91_mci.c:	if (IS_ERR(host->mci_clk)) {
drivers/mmc/host/at91_mci.c:	host->baseaddr = ioremap(res->start, resource_size(res));
drivers/mmc/host/at91_mci.c:	if (!host->baseaddr) {
drivers/mmc/host/at91_mci.c:	clk_enable(host->mci_clk);		/* Enable the peripheral clock */
drivers/mmc/host/at91_mci.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/at91_mci.c:	ret = request_irq(host->irq, at91_mci_irq, IRQF_SHARED,
drivers/mmc/host/at91_mci.c:	setup_timer(&host->timer, at91_timeout_timer, (unsigned long)host);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin)) {
drivers/mmc/host/at91_mci.c:		host->present = !gpio_get_value(host->board->det_pin);
drivers/mmc/host/at91_mci.c:		host->present = -1;
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin)) {
drivers/mmc/host/at91_mci.c:		ret = request_irq(gpio_to_irq(host->board->det_pin),
drivers/mmc/host/at91_mci.c:	clk_disable(host->mci_clk);
drivers/mmc/host/at91_mci.c:	iounmap(host->baseaddr);
drivers/mmc/host/at91_mci.c:	clk_put(host->mci_clk);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->vcc_pin))
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->vcc_pin);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->wp_pin))
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin))
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->det_pin);
drivers/mmc/host/at91_mci.c:	if (host->buffer)
drivers/mmc/host/at91_mci.c:				host->buffer, host->physical_address);
drivers/mmc/host/at91_mci.c:	if (host->buffer)
drivers/mmc/host/at91_mci.c:				host->buffer, host->physical_address);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin)) {
drivers/mmc/host/at91_mci.c:			free_irq(gpio_to_irq(host->board->det_pin), host);
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->det_pin);
drivers/mmc/host/at91_mci.c:	del_timer_sync(&host->timer);
drivers/mmc/host/at91_mci.c:	free_irq(host->irq, host);
drivers/mmc/host/at91_mci.c:	clk_disable(host->mci_clk);			/* Disable the peripheral clock */
drivers/mmc/host/at91_mci.c:	clk_put(host->mci_clk);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->vcc_pin))
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->vcc_pin);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->wp_pin))
drivers/mmc/host/at91_mci.c:		gpio_free(host->board->wp_pin);
drivers/mmc/host/at91_mci.c:	iounmap(host->baseaddr);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin) && device_may_wakeup(&pdev->dev))
drivers/mmc/host/at91_mci.c:		enable_irq_wake(host->board->det_pin);
drivers/mmc/host/at91_mci.c:	if (gpio_is_valid(host->board->det_pin) && device_may_wakeup(&pdev->dev))
drivers/mmc/host/at91_mci.c:		disable_irq_wake(host->board->det_pin);
drivers/mmc/host/atmel-mci.c: * @clock: Clock rate configured by set_ios(). Protected by host->lock.
drivers/mmc/host/atmel-mci.c:	test_and_clear_bit(event, &host->pending_events)
drivers/mmc/host/atmel-mci.c:	set_bit(event, &host->completed_events)
drivers/mmc/host/atmel-mci.c:	set_bit(event, &host->pending_events)
drivers/mmc/host/atmel-mci.c:	spin_lock_bh(&slot->host->lock);
drivers/mmc/host/atmel-mci.c:	spin_unlock_bh(&slot->host->lock);
drivers/mmc/host/atmel-mci.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:	memcpy_fromio(buf, host->regs, ATMCI_REGS_SIZE);
drivers/mmc/host/atmel-mci.c:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_cstor_reg)
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_dma) {
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_cfg_reg) {
drivers/mmc/host/atmel-mci.c:	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
drivers/mmc/host/atmel-mci.c:				     (u32 *)&host->pending_events);
drivers/mmc/host/atmel-mci.c:				     (u32 *)&host->completed_events);
drivers/mmc/host/atmel-mci.c:	/* Maximum clock frequency is host->bus_hz/2 */
drivers/mmc/host/atmel-mci.c:	return us * (DIV_ROUND_UP(host->bus_hz, 2000000));
drivers/mmc/host/atmel-mci.c:	WARN_ON(host->cmd);
drivers/mmc/host/atmel-mci.c:	host->cmd = cmd;
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	atmci_send_command(host, data->stop, host->stop_cmdr);
drivers/mmc/host/atmel-mci.c: * Update host->data_size and host->sg.
drivers/mmc/host/atmel-mci.c:	atmci_writel(host, pointer_reg, sg_dma_address(host->sg));
drivers/mmc/host/atmel-mci.c:	if (host->data_size <= sg_dma_len(host->sg)) {
drivers/mmc/host/atmel-mci.c:		if (host->data_size & 0x3) {
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, counter_reg, host->data_size);
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCFBYTE);
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, counter_reg, host->data_size / 4);
drivers/mmc/host/atmel-mci.c:		host->data_size = 0;
drivers/mmc/host/atmel-mci.c:		atmci_writel(host, counter_reg, sg_dma_len(host->sg) / 4);
drivers/mmc/host/atmel-mci.c:		host->data_size -= sg_dma_len(host->sg);
drivers/mmc/host/atmel-mci.c:		if (host->data_size)
drivers/mmc/host/atmel-mci.c:			host->sg = sg_next(host->sg);
drivers/mmc/host/atmel-mci.c:	if (host->data_size)
drivers/mmc/host/atmel-mci.c:	struct mmc_data         *data = host->data;
drivers/mmc/host/atmel-mci.c:		dma_unmap_sg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	if (host->data) {
drivers/mmc/host/atmel-mci.c:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:	struct mmc_data                 *data = host->data;
drivers/mmc/host/atmel-mci.c:		dma_unmap_sg(host->dma.chan->device->dev,
drivers/mmc/host/atmel-mci.c:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev, "DMA complete\n");
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_dma)
drivers/mmc/host/atmel-mci.c:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:	host->sg = data->sg;
drivers/mmc/host/atmel-mci.c:	host->data = data;
drivers/mmc/host/atmel-mci.c:	host->data_chan = NULL;
drivers/mmc/host/atmel-mci.c:		host->need_reset = true;
drivers/mmc/host/atmel-mci.c:	host->pio_offset = 0;
drivers/mmc/host/atmel-mci.c:	host->data = data;
drivers/mmc/host/atmel-mci.c:	host->sg = data->sg;
drivers/mmc/host/atmel-mci.c:	atmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCMODE);
drivers/mmc/host/atmel-mci.c:	host->data_size = data->blocks * data->blksz;
drivers/mmc/host/atmel-mci.c:	sg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len, dir);
drivers/mmc/host/atmel-mci.c:	if (host->data_size)
drivers/mmc/host/atmel-mci.c:	WARN_ON(host->data);
drivers/mmc/host/atmel-mci.c:	host->sg = NULL;
drivers/mmc/host/atmel-mci.c:	host->data = data;
drivers/mmc/host/atmel-mci.c:	chan = host->dma.chan;
drivers/mmc/host/atmel-mci.c:		host->data_chan = chan;
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_dma)
drivers/mmc/host/atmel-mci.c:		host->dma_conf.direction = slave_dirn = DMA_DEV_TO_MEM;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.direction = slave_dirn = DMA_MEM_TO_DEV;
drivers/mmc/host/atmel-mci.c:	dmaengine_slave_config(chan, &host->dma_conf);
drivers/mmc/host/atmel-mci.c:	host->dma.data_desc = desc;
drivers/mmc/host/atmel-mci.c:	struct dma_chan			*chan = host->data_chan;
drivers/mmc/host/atmel-mci.c:	struct dma_async_tx_descriptor	*desc = host->dma.data_desc;
drivers/mmc/host/atmel-mci.c:	struct dma_chan *chan = host->data_chan;
drivers/mmc/host/atmel-mci.c:	host->cur_slot = slot;
drivers/mmc/host/atmel-mci.c:	host->mrq = mrq;
drivers/mmc/host/atmel-mci.c:	host->pending_events = 0;
drivers/mmc/host/atmel-mci.c:	host->completed_events = 0;
drivers/mmc/host/atmel-mci.c:	host->data_status = 0;
drivers/mmc/host/atmel-mci.c:	if (host->need_reset) {
drivers/mmc/host/atmel-mci.c:		atmci_writel(host, ATMCI_MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:		if (host->caps.has_cfg_reg)
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, ATMCI_CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:		host->need_reset = false;
drivers/mmc/host/atmel-mci.c:		iflags |= host->prepare_data(host, data);
drivers/mmc/host/atmel-mci.c:		host->submit_data(host, data);
drivers/mmc/host/atmel-mci.c:		host->stop_cmdr = atmci_prepare_command(slot->mmc, mrq->stop);
drivers/mmc/host/atmel-mci.c:		host->stop_cmdr |= ATMCI_CMDR_STOP_XFER;
drivers/mmc/host/atmel-mci.c:			host->stop_cmdr |= ATMCI_CMDR_TRDIR_READ;
drivers/mmc/host/atmel-mci.c:			host->stop_cmdr |= ATMCI_CMDR_STREAM;
drivers/mmc/host/atmel-mci.c:			host->stop_cmdr |= ATMCI_CMDR_MULTI_BLOCK;
drivers/mmc/host/atmel-mci.c:			host->state);
drivers/mmc/host/atmel-mci.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:	if (host->state == STATE_IDLE) {
drivers/mmc/host/atmel-mci.c:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/atmel-mci.c:		list_add_tail(&slot->queue_node, &host->queue);
drivers/mmc/host/atmel-mci.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:		spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:		if (!host->mode_reg) {
drivers/mmc/host/atmel-mci.c:			clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:			if (host->caps.has_cfg_reg)
drivers/mmc/host/atmel-mci.c:				atmci_writel(host, ATMCI_CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:			if (host->slot[i] && host->slot[i]->clock
drivers/mmc/host/atmel-mci.c:					&& host->slot[i]->clock < clock_min)
drivers/mmc/host/atmel-mci.c:				clock_min = host->slot[i]->clock;
drivers/mmc/host/atmel-mci.c:		if (host->caps.has_odd_clk_div) {
drivers/mmc/host/atmel-mci.c:			clkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2;
drivers/mmc/host/atmel-mci.c:				         clock_min, host->bus_hz / (511 + 2));
drivers/mmc/host/atmel-mci.c:			host->mode_reg = ATMCI_MR_CLKDIV(clkdiv >> 1)
drivers/mmc/host/atmel-mci.c:			clkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;
drivers/mmc/host/atmel-mci.c:				         clock_min, host->bus_hz / (2 * 256));
drivers/mmc/host/atmel-mci.c:			host->mode_reg = ATMCI_MR_CLKDIV(clkdiv);
drivers/mmc/host/atmel-mci.c:		if (host->caps.has_rwproof)
drivers/mmc/host/atmel-mci.c:			host->mode_reg |= (ATMCI_MR_WRPROOF | ATMCI_MR_RDPROOF);
drivers/mmc/host/atmel-mci.c:		if (host->caps.has_cfg_reg) {
drivers/mmc/host/atmel-mci.c:				host->cfg_reg |= ATMCI_CFG_HSMODE;
drivers/mmc/host/atmel-mci.c:				host->cfg_reg &= ~ATMCI_CFG_HSMODE;
drivers/mmc/host/atmel-mci.c:		if (list_empty(&host->queue)) {
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, ATMCI_MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:			if (host->caps.has_cfg_reg)
drivers/mmc/host/atmel-mci.c:				atmci_writel(host, ATMCI_CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:			host->need_clock_update = true;
drivers/mmc/host/atmel-mci.c:		spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:		spin_lock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:			if (host->slot[i] && host->slot[i]->clock) {
drivers/mmc/host/atmel-mci.c:			if (host->mode_reg) {
drivers/mmc/host/atmel-mci.c:				clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:			host->mode_reg = 0;
drivers/mmc/host/atmel-mci.c:		spin_unlock_bh(&host->lock);
drivers/mmc/host/atmel-mci.c:/* Called with host->lock held */
drivers/mmc/host/atmel-mci.c:	__releases(&host->lock)
drivers/mmc/host/atmel-mci.c:	__acquires(&host->lock)
drivers/mmc/host/atmel-mci.c:	struct mmc_host		*prev_mmc = host->cur_slot->mmc;
drivers/mmc/host/atmel-mci.c:	WARN_ON(host->cmd || host->data);
drivers/mmc/host/atmel-mci.c:	if (host->need_clock_update) {
drivers/mmc/host/atmel-mci.c:		atmci_writel(host, ATMCI_MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:		if (host->caps.has_cfg_reg)
drivers/mmc/host/atmel-mci.c:			atmci_writel(host, ATMCI_CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:	host->cur_slot->mrq = NULL;
drivers/mmc/host/atmel-mci.c:	host->mrq = NULL;
drivers/mmc/host/atmel-mci.c:	if (!list_empty(&host->queue)) {
drivers/mmc/host/atmel-mci.c:		slot = list_entry(host->queue.next,
drivers/mmc/host/atmel-mci.c:		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
drivers/mmc/host/atmel-mci.c:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/atmel-mci.c:		dev_vdbg(&host->pdev->dev, "list empty\n");
drivers/mmc/host/atmel-mci.c:		host->state = STATE_IDLE;
drivers/mmc/host/atmel-mci.c:	spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:	spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:	u32		status = host->cmd_status;
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:			host->stop_transfer(host);
drivers/mmc/host/atmel-mci.c:			host->data = NULL;
drivers/mmc/host/atmel-mci.c:		spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:			if (mrq == host->mrq) {
drivers/mmc/host/atmel-mci.c:				atmci_writel(host, ATMCI_MR, host->mode_reg);
drivers/mmc/host/atmel-mci.c:				if (host->caps.has_cfg_reg)
drivers/mmc/host/atmel-mci.c:					atmci_writel(host, ATMCI_CFG, host->cfg_reg);
drivers/mmc/host/atmel-mci.c:				host->data = NULL;
drivers/mmc/host/atmel-mci.c:				host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:				switch (host->state) {
drivers/mmc/host/atmel-mci.c:					host->stop_transfer(host);
drivers/mmc/host/atmel-mci.c:				spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:				spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:		spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:	struct mmc_request	*mrq = host->mrq;
drivers/mmc/host/atmel-mci.c:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:	struct mmc_command	*cmd = host->cmd;
drivers/mmc/host/atmel-mci.c:	enum atmel_mci_state	state = host->state;
drivers/mmc/host/atmel-mci.c:	spin_lock(&host->lock);
drivers/mmc/host/atmel-mci.c:	state = host->state;
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		state, host->pending_events, host->completed_events,
drivers/mmc/host/atmel-mci.c:			host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:				atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:				host->stop_transfer(host);
drivers/mmc/host/atmel-mci.c:			host->data = NULL;
drivers/mmc/host/atmel-mci.c:			status = host->data_status;
drivers/mmc/host/atmel-mci.c:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:					dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:				atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:			host->cmd = NULL;
drivers/mmc/host/atmel-mci.c:			atmci_request_end(host, host->mrq);
drivers/mmc/host/atmel-mci.c:	host->state = state;
drivers/mmc/host/atmel-mci.c:	spin_unlock(&host->lock);
drivers/mmc/host/atmel-mci.c:	struct scatterlist	*sg = host->sg;
drivers/mmc/host/atmel-mci.c:	unsigned int		offset = host->pio_offset;
drivers/mmc/host/atmel-mci.c:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:				host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:			host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:	host->pio_offset = offset;
drivers/mmc/host/atmel-mci.c:	struct scatterlist	*sg = host->sg;
drivers/mmc/host/atmel-mci.c:	unsigned int		offset = host->pio_offset;
drivers/mmc/host/atmel-mci.c:	struct mmc_data		*data = host->data;
drivers/mmc/host/atmel-mci.c:				host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:			host->sg = sg = sg_next(sg);
drivers/mmc/host/atmel-mci.c:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:	host->pio_offset = offset;
drivers/mmc/host/atmel-mci.c:	host->cmd_status = status;
drivers/mmc/host/atmel-mci.c:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:		struct atmel_mci_slot *slot = host->slot[i];
drivers/mmc/host/atmel-mci.c:			host->data_status = status;
drivers/mmc/host/atmel-mci.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:			if (host->data_size) {
drivers/mmc/host/atmel-mci.c:			if (host->data_size) {
drivers/mmc/host/atmel-mci.c:			if (host->data_size) {
drivers/mmc/host/atmel-mci.c:			if (host->data_size) {
drivers/mmc/host/atmel-mci.c:			if (!host->data_status)
drivers/mmc/host/atmel-mci.c:				host->data_status = status;
drivers/mmc/host/atmel-mci.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/atmel-mci.c:	mmc = mmc_alloc_host(sizeof(struct atmel_mci_slot), &host->pdev->dev);
drivers/mmc/host/atmel-mci.c:	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 512);
drivers/mmc/host/atmel-mci.c:	mmc->f_max = host->bus_hz / 2;
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_highspeed)
drivers/mmc/host/atmel-mci.c:	host->slot[id] = slot;
drivers/mmc/host/atmel-mci.c:	slot->host->slot[id] = NULL;
drivers/mmc/host/atmel-mci.c:	pdata = host->pdev->dev.platform_data;
drivers/mmc/host/atmel-mci.c:		host->dma.chan =
drivers/mmc/host/atmel-mci.c:	if (!host->dma.chan) {
drivers/mmc/host/atmel-mci.c:		dev_warn(&host->pdev->dev, "no DMA channel available\n");
drivers/mmc/host/atmel-mci.c:		dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:					dma_chan_name(host->dma.chan));
drivers/mmc/host/atmel-mci.c:		host->dma_conf.src_addr = host->mapbase + ATMCI_RDR;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.src_maxburst = 1;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.dst_addr = host->mapbase + ATMCI_TDR;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.dst_maxburst = 1;
drivers/mmc/host/atmel-mci.c:		host->dma_conf.device_fc = false;
drivers/mmc/host/atmel-mci.c:	dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	host->caps.has_dma = 0;
drivers/mmc/host/atmel-mci.c:	host->caps.has_pdc = 1;
drivers/mmc/host/atmel-mci.c:	host->caps.has_cfg_reg = 0;
drivers/mmc/host/atmel-mci.c:	host->caps.has_cstor_reg = 0;
drivers/mmc/host/atmel-mci.c:	host->caps.has_highspeed = 0;
drivers/mmc/host/atmel-mci.c:	host->caps.has_rwproof = 0;
drivers/mmc/host/atmel-mci.c:	host->caps.has_odd_clk_div = 0;
drivers/mmc/host/atmel-mci.c:		host->caps.has_odd_clk_div = 1;
drivers/mmc/host/atmel-mci.c:		host->caps.has_dma = 1;
drivers/mmc/host/atmel-mci.c:		dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		host->caps.has_pdc = 0;
drivers/mmc/host/atmel-mci.c:		host->caps.has_cfg_reg = 1;
drivers/mmc/host/atmel-mci.c:		host->caps.has_cstor_reg = 1;
drivers/mmc/host/atmel-mci.c:		host->caps.has_highspeed = 1;
drivers/mmc/host/atmel-mci.c:		host->caps.has_rwproof = 1;
drivers/mmc/host/atmel-mci.c:		host->caps.has_pdc = 0;
drivers/mmc/host/atmel-mci.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	host->pdev = pdev;
drivers/mmc/host/atmel-mci.c:	spin_lock_init(&host->lock);
drivers/mmc/host/atmel-mci.c:	INIT_LIST_HEAD(&host->queue);
drivers/mmc/host/atmel-mci.c:	host->mck = clk_get(&pdev->dev, "mci_clk");
drivers/mmc/host/atmel-mci.c:	if (IS_ERR(host->mck)) {
drivers/mmc/host/atmel-mci.c:		ret = PTR_ERR(host->mck);
drivers/mmc/host/atmel-mci.c:	host->regs = ioremap(regs->start, resource_size(regs));
drivers/mmc/host/atmel-mci.c:	if (!host->regs)
drivers/mmc/host/atmel-mci.c:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:	host->bus_hz = clk_get_rate(host->mck);
drivers/mmc/host/atmel-mci.c:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:	host->mapbase = regs->start;
drivers/mmc/host/atmel-mci.c:	tasklet_init(&host->tasklet, atmci_tasklet_func, (unsigned long)host);
drivers/mmc/host/atmel-mci.c:	if (host->caps.has_dma && atmci_configure_dma(host)) {
drivers/mmc/host/atmel-mci.c:		host->prepare_data = &atmci_prepare_data_dma;
drivers/mmc/host/atmel-mci.c:		host->submit_data = &atmci_submit_data_dma;
drivers/mmc/host/atmel-mci.c:		host->stop_transfer = &atmci_stop_transfer_dma;
drivers/mmc/host/atmel-mci.c:	} else if (host->caps.has_pdc) {
drivers/mmc/host/atmel-mci.c:		host->prepare_data = &atmci_prepare_data_pdc;
drivers/mmc/host/atmel-mci.c:		host->submit_data = &atmci_submit_data_pdc;
drivers/mmc/host/atmel-mci.c:		host->stop_transfer = &atmci_stop_transfer_pdc;
drivers/mmc/host/atmel-mci.c:		host->prepare_data = &atmci_prepare_data;
drivers/mmc/host/atmel-mci.c:		host->submit_data = &atmci_submit_data;
drivers/mmc/host/atmel-mci.c:		host->stop_transfer = &atmci_stop_transfer;
drivers/mmc/host/atmel-mci.c:			host->mapbase, irq, nr_slots);
drivers/mmc/host/atmel-mci.c:	if (host->dma.chan)
drivers/mmc/host/atmel-mci.c:		dma_release_channel(host->dma.chan);
drivers/mmc/host/atmel-mci.c:	iounmap(host->regs);
drivers/mmc/host/atmel-mci.c:	clk_put(host->mck);
drivers/mmc/host/atmel-mci.c:		if (host->slot[i])
drivers/mmc/host/atmel-mci.c:			atmci_cleanup_slot(host->slot[i], i);
drivers/mmc/host/atmel-mci.c:	clk_enable(host->mck);
drivers/mmc/host/atmel-mci.c:	clk_disable(host->mck);
drivers/mmc/host/atmel-mci.c:	if (host->dma.chan)
drivers/mmc/host/atmel-mci.c:		dma_release_channel(host->dma.chan);
drivers/mmc/host/atmel-mci.c:	iounmap(host->regs);
drivers/mmc/host/atmel-mci.c:	clk_put(host->mck);
drivers/mmc/host/atmel-mci.c:		struct atmel_mci_slot *slot = host->slot[i];
drivers/mmc/host/atmel-mci.c:				slot = host->slot[i];
drivers/mmc/host/atmel-mci.c:					mmc_resume_host(host->slot[i]->mmc);
drivers/mmc/host/atmel-mci.c:		struct atmel_mci_slot *slot = host->slot[i];
drivers/mmc/host/atmel-mci.c:		slot = host->slot[i];
drivers/mmc/host/au1xmmc.c:	WARN_ON(host->status != HOST_S_DATA);
drivers/mmc/host/au1xmmc.c:	host->status = HOST_S_STOP;
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->set_power)
drivers/mmc/host/au1xmmc.c:		host->platdata->set_power(host->mmc, state);
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->card_inserted)
drivers/mmc/host/au1xmmc.c:		return !!host->platdata->card_inserted(host->mmc);
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->card_readonly)
drivers/mmc/host/au1xmmc.c:		return !!host->platdata->card_readonly(mmc);
drivers/mmc/host/au1xmmc.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:	host->mrq = NULL;
drivers/mmc/host/au1xmmc.c:	host->flags &= HOST_F_ACTIVE | HOST_F_DMA;
drivers/mmc/host/au1xmmc.c:	host->dma.len = 0;
drivers/mmc/host/au1xmmc.c:	host->dma.dir = 0;
drivers/mmc/host/au1xmmc.c:	host->pio.index  = 0;
drivers/mmc/host/au1xmmc.c:	host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:	host->pio.len = 0;
drivers/mmc/host/au1xmmc.c:	host->status = HOST_S_IDLE;
drivers/mmc/host/au1xmmc.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/au1xmmc.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:	WARN_ON((host->status != HOST_S_DATA) && (host->status != HOST_S_STOP));
drivers/mmc/host/au1xmmc.c:	if (host->mrq == NULL)
drivers/mmc/host/au1xmmc.c:	while ((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB))
drivers/mmc/host/au1xmmc.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
drivers/mmc/host/au1xmmc.c:	if (host->flags & HOST_F_XMIT)
drivers/mmc/host/au1xmmc.c:		if (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {
drivers/mmc/host/au1xmmc.c:				(data->blocks * data->blksz) - host->pio.len;
drivers/mmc/host/au1xmmc.c:	data = host->mrq->data;
drivers/mmc/host/au1xmmc.c:	if (!(host->flags & HOST_F_XMIT))
drivers/mmc/host/au1xmmc.c:	sg = &data->sg[host->pio.index];
drivers/mmc/host/au1xmmc.c:	sg_ptr = sg_virt(sg) + host->pio.offset;
drivers/mmc/host/au1xmmc.c:	sg_len = data->sg[host->pio.index].length - host->pio.offset;
drivers/mmc/host/au1xmmc.c:	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
drivers/mmc/host/au1xmmc.c:	host->pio.len -= count;
drivers/mmc/host/au1xmmc.c:	host->pio.offset += count;
drivers/mmc/host/au1xmmc.c:		host->pio.index++;
drivers/mmc/host/au1xmmc.c:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:	if (host->pio.len == 0) {
drivers/mmc/host/au1xmmc.c:		if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:		tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:	data = host->mrq->data;
drivers/mmc/host/au1xmmc.c:	if (!(host->flags & HOST_F_RECV))
drivers/mmc/host/au1xmmc.c:	max = host->pio.len;
drivers/mmc/host/au1xmmc.c:	if (host->pio.index < host->dma.len) {
drivers/mmc/host/au1xmmc.c:		sg = &data->sg[host->pio.index];
drivers/mmc/host/au1xmmc.c:		sg_ptr = sg_virt(sg) + host->pio.offset;
drivers/mmc/host/au1xmmc.c:		sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
drivers/mmc/host/au1xmmc.c:			DBG("RX CRC Error [%d + %d].\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:					host->pio.len, count);
drivers/mmc/host/au1xmmc.c:			DBG("RX Overrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:					host->pio.len, count);
drivers/mmc/host/au1xmmc.c:			DBG("RX Underrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:					host->pio.len,	count);
drivers/mmc/host/au1xmmc.c:	host->pio.len -= count;
drivers/mmc/host/au1xmmc.c:	host->pio.offset += count;
drivers/mmc/host/au1xmmc.c:		host->pio.index++;
drivers/mmc/host/au1xmmc.c:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:	if (host->pio.len == 0) {
drivers/mmc/host/au1xmmc.c:		if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:		tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/au1xmmc.c:	if (!host->mrq)
drivers/mmc/host/au1xmmc.c:			r[0] = au_readl(host->iobase + SD_RESP3);
drivers/mmc/host/au1xmmc.c:			r[1] = au_readl(host->iobase + SD_RESP2);
drivers/mmc/host/au1xmmc.c:			r[2] = au_readl(host->iobase + SD_RESP1);
drivers/mmc/host/au1xmmc.c:			r[3] = au_readl(host->iobase + SD_RESP0);
drivers/mmc/host/au1xmmc.c:			cmd->resp[0] = au_readl(host->iobase + SD_RESP0);
drivers/mmc/host/au1xmmc.c:	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
drivers/mmc/host/au1xmmc.c:		tasklet_schedule(&host->finish_task);
drivers/mmc/host/au1xmmc.c:	host->status = HOST_S_DATA;
drivers/mmc/host/au1xmmc.c:	if ((host->flags & (HOST_F_DMA | HOST_F_DBDMA))) {
drivers/mmc/host/au1xmmc.c:		if (host->flags & HOST_F_RECV) {
drivers/mmc/host/au1xmmc.c:		host->flags |= HOST_F_RECV;
drivers/mmc/host/au1xmmc.c:		host->flags |= HOST_F_XMIT;
drivers/mmc/host/au1xmmc.c:	if (host->mrq->stop)
drivers/mmc/host/au1xmmc.c:		host->flags |= HOST_F_STOP;
drivers/mmc/host/au1xmmc.c:	host->dma.dir = DMA_BIDIRECTIONAL;
drivers/mmc/host/au1xmmc.c:	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/au1xmmc.c:				   data->sg_len, host->dma.dir);
drivers/mmc/host/au1xmmc.c:	if (host->dma.len == 0)
drivers/mmc/host/au1xmmc.c:	if (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {
drivers/mmc/host/au1xmmc.c:		for (i = 0; i < host->dma.len; i++) {
drivers/mmc/host/au1xmmc.c:			if (i == host->dma.len - 1)
drivers/mmc/host/au1xmmc.c:			if (host->flags & HOST_F_XMIT) {
drivers/mmc/host/au1xmmc.c:		host->pio.index = 0;
drivers/mmc/host/au1xmmc.c:		host->pio.offset = 0;
drivers/mmc/host/au1xmmc.c:		host->pio.len = datalen;
drivers/mmc/host/au1xmmc.c:		if (host->flags & HOST_F_XMIT)
drivers/mmc/host/au1xmmc.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/au1xmmc.c:			host->dma.dir);
drivers/mmc/host/au1xmmc.c:	WARN_ON(host->status != HOST_S_IDLE);
drivers/mmc/host/au1xmmc.c:	host->mrq = mrq;
drivers/mmc/host/au1xmmc.c:	host->status = HOST_S_CMD;
drivers/mmc/host/au1xmmc.c:	if (ios->clock && ios->clock != host->clock) {
drivers/mmc/host/au1xmmc.c:		host->clock = ios->clock;
drivers/mmc/host/au1xmmc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/au1xmmc.c:	if (host->mrq && (status & STATUS_TIMEOUT)) {
drivers/mmc/host/au1xmmc.c:			host->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/au1xmmc.c:			host->mrq->data->error = -ETIMEDOUT;
drivers/mmc/host/au1xmmc.c:		tasklet_schedule(&host->finish_task);
drivers/mmc/host/au1xmmc.c:		if (!(host->flags & HOST_F_DMA) && (status & SD_STATUS_NE))
drivers/mmc/host/au1xmmc.c:			/* tasklet_schedule(&host->data_task); */
drivers/mmc/host/au1xmmc.c:		if (host->status == HOST_S_CMD)
drivers/mmc/host/au1xmmc.c:	} else if (!(host->flags & HOST_F_DMA)) {
drivers/mmc/host/au1xmmc.c:		if ((host->flags & HOST_F_XMIT) && (status & STATUS_DATA_OUT))
drivers/mmc/host/au1xmmc.c:		else if ((host->flags & HOST_F_RECV) && (status & STATUS_DATA_IN))
drivers/mmc/host/au1xmmc.c:			DBG("Unhandled status %8.8x\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:	if (!host->mrq)
drivers/mmc/host/au1xmmc.c:	if (host->flags & HOST_F_STOP)
drivers/mmc/host/au1xmmc.c:	tasklet_schedule(&host->data_task);
drivers/mmc/host/au1xmmc.c:	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 0);
drivers/mmc/host/au1xmmc.c:	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 1);
drivers/mmc/host/au1xmmc.c:	host->tx_chan = au1xxx_dbdma_chan_alloc(memid, txid,
drivers/mmc/host/au1xmmc.c:	if (!host->tx_chan) {
drivers/mmc/host/au1xmmc.c:		dev_err(&host->pdev->dev, "cannot allocate TX DMA\n");
drivers/mmc/host/au1xmmc.c:	host->rx_chan = au1xxx_dbdma_chan_alloc(rxid, memid,
drivers/mmc/host/au1xmmc.c:	if (!host->rx_chan) {
drivers/mmc/host/au1xmmc.c:		dev_err(&host->pdev->dev, "cannot allocate RX DMA\n");
drivers/mmc/host/au1xmmc.c:		au1xxx_dbdma_chan_free(host->tx_chan);
drivers/mmc/host/au1xmmc.c:	au1xxx_dbdma_set_devwidth(host->tx_chan, 8);
drivers/mmc/host/au1xmmc.c:	au1xxx_dbdma_set_devwidth(host->rx_chan, 8);
drivers/mmc/host/au1xmmc.c:	au1xxx_dbdma_ring_alloc(host->tx_chan, AU1XMMC_DESCRIPTOR_COUNT);
drivers/mmc/host/au1xmmc.c:	au1xxx_dbdma_ring_alloc(host->rx_chan, AU1XMMC_DESCRIPTOR_COUNT);
drivers/mmc/host/au1xmmc.c:	host->flags |= HOST_F_DMA | HOST_F_DBDMA;
drivers/mmc/host/au1xmmc.c:	if (host->flags & HOST_F_DMA) {
drivers/mmc/host/au1xmmc.c:		host->flags &= ~HOST_F_DMA;
drivers/mmc/host/au1xmmc.c:		au1xxx_dbdma_chan_free(host->tx_chan);
drivers/mmc/host/au1xmmc.c:		au1xxx_dbdma_chan_free(host->rx_chan);
drivers/mmc/host/au1xmmc.c:	host->mmc = mmc;
drivers/mmc/host/au1xmmc.c:	host->platdata = pdev->dev.platform_data;
drivers/mmc/host/au1xmmc.c:	host->pdev = pdev;
drivers/mmc/host/au1xmmc.c:	host->ioarea = request_mem_region(r->start, resource_size(r),
drivers/mmc/host/au1xmmc.c:	if (!host->ioarea) {
drivers/mmc/host/au1xmmc.c:	host->iobase = (unsigned long)ioremap(r->start, 0x3c);
drivers/mmc/host/au1xmmc.c:	if (!host->iobase) {
drivers/mmc/host/au1xmmc.c:	host->irq = r->start;
drivers/mmc/host/au1xmmc.c:		if (host->ioarea->start == AU1100_SD0_PHYS_ADDR)
drivers/mmc/host/au1xmmc.c:	ret = request_irq(host->irq, au1xmmc_irq, iflag, DRIVER_NAME, host);
drivers/mmc/host/au1xmmc.c:	host->status = HOST_S_IDLE;
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->cd_setup) {
drivers/mmc/host/au1xmmc.c:		ret = host->platdata->cd_setup(mmc, 1);
drivers/mmc/host/au1xmmc.c:	if (host->platdata)
drivers/mmc/host/au1xmmc.c:		mmc->caps &= ~(host->platdata->mask_host_caps);
drivers/mmc/host/au1xmmc.c:	tasklet_init(&host->data_task, au1xmmc_tasklet_data,
drivers/mmc/host/au1xmmc.c:	tasklet_init(&host->finish_task, au1xmmc_tasklet_finish,
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->led) {
drivers/mmc/host/au1xmmc.c:		struct led_classdev *led = host->platdata->led;
drivers/mmc/host/au1xmmc.c:		" (mode=%s)\n", pdev->id, host->iobase,
drivers/mmc/host/au1xmmc.c:		host->flags & HOST_F_DMA ? "dma" : "pio");
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->led)
drivers/mmc/host/au1xmmc.c:		led_classdev_unregister(host->platdata->led);
drivers/mmc/host/au1xmmc.c:	if (host->flags & HOST_F_DBDMA)
drivers/mmc/host/au1xmmc.c:	tasklet_kill(&host->data_task);
drivers/mmc/host/au1xmmc.c:	tasklet_kill(&host->finish_task);
drivers/mmc/host/au1xmmc.c:	if (host->platdata && host->platdata->cd_setup &&
drivers/mmc/host/au1xmmc.c:		host->platdata->cd_setup(mmc, 0);
drivers/mmc/host/au1xmmc.c:	free_irq(host->irq, host);
drivers/mmc/host/au1xmmc.c:	iounmap((void *)host->iobase);
drivers/mmc/host/au1xmmc.c:	release_resource(host->ioarea);
drivers/mmc/host/au1xmmc.c:	kfree(host->ioarea);
drivers/mmc/host/au1xmmc.c:		mmc_remove_host(host->mmc);
drivers/mmc/host/au1xmmc.c:		if (host->platdata && host->platdata->led)
drivers/mmc/host/au1xmmc.c:			led_classdev_unregister(host->platdata->led);
drivers/mmc/host/au1xmmc.c:		if (host->platdata && host->platdata->cd_setup &&
drivers/mmc/host/au1xmmc.c:		    !(host->mmc->caps & MMC_CAP_NEEDS_POLL))
drivers/mmc/host/au1xmmc.c:			host->platdata->cd_setup(host->mmc, 0);
drivers/mmc/host/au1xmmc.c:		tasklet_kill(&host->data_task);
drivers/mmc/host/au1xmmc.c:		tasklet_kill(&host->finish_task);
drivers/mmc/host/au1xmmc.c:		if (host->flags & HOST_F_DBDMA)
drivers/mmc/host/au1xmmc.c:		free_irq(host->irq, host);
drivers/mmc/host/au1xmmc.c:		iounmap((void *)host->iobase);
drivers/mmc/host/au1xmmc.c:		release_resource(host->ioarea);
drivers/mmc/host/au1xmmc.c:		kfree(host->ioarea);
drivers/mmc/host/au1xmmc.c:		mmc_free_host(host->mmc);
drivers/mmc/host/au1xmmc.c:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/au1xmmc.c:	return mmc_resume_host(host->mmc);
drivers/mmc/host/bfin_sdh.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:	host->imask |= mask;
drivers/mmc/host/bfin_sdh.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:	host->imask &= ~mask;
drivers/mmc/host/bfin_sdh.c:	bfin_write_SDH_MASK0(host->imask);
drivers/mmc/host/bfin_sdh.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter flags: 0x%x\n", __func__, data->flags);
drivers/mmc/host/bfin_sdh.c:	host->data = data;
drivers/mmc/host/bfin_sdh.c:	cycle_ns = 1000000000 / (get_sclk() / (2 * (host->clk_div + 1)));
drivers/mmc/host/bfin_sdh.c:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/bfin_sdh.c:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/bfin_sdh.c:	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma_dir);
drivers/mmc/host/bfin_sdh.c:		for_each_sg(data->sg, sg, host->dma_len, i) {
drivers/mmc/host/bfin_sdh.c:			host->sg_cpu[i].start_addr = sg_dma_address(sg);
drivers/mmc/host/bfin_sdh.c:			host->sg_cpu[i].cfg = dma_cfg;
drivers/mmc/host/bfin_sdh.c:			host->sg_cpu[i].x_count = sg_dma_len(sg) / 4;
drivers/mmc/host/bfin_sdh.c:			host->sg_cpu[i].x_modify = 4;
drivers/mmc/host/bfin_sdh.c:			dev_dbg(mmc_dev(host->mmc), "%d: start_addr:0x%lx, "
drivers/mmc/host/bfin_sdh.c:				i, host->sg_cpu[i].start_addr,
drivers/mmc/host/bfin_sdh.c:				host->sg_cpu[i].cfg, host->sg_cpu[i].x_count,
drivers/mmc/host/bfin_sdh.c:				host->sg_cpu[i].x_modify);
drivers/mmc/host/bfin_sdh.c:	flush_dcache_range((unsigned int)host->sg_cpu,
drivers/mmc/host/bfin_sdh.c:		(unsigned int)host->sg_cpu +
drivers/mmc/host/bfin_sdh.c:			host->dma_len * sizeof(struct dma_desc_array));
drivers/mmc/host/bfin_sdh.c:	host->sg_cpu[host->dma_len - 1].cfg &= ~(DMAFLOW | NDSIZE);
drivers/mmc/host/bfin_sdh.c:	host->sg_cpu[host->dma_len - 1].cfg |= DI_EN;
drivers/mmc/host/bfin_sdh.c:	set_dma_curr_desc_addr(host->dma_ch, (unsigned long *)host->sg_dma);
drivers/mmc/host/bfin_sdh.c:	set_dma_x_count(host->dma_ch, 0);
drivers/mmc/host/bfin_sdh.c:	set_dma_x_modify(host->dma_ch, 0);
drivers/mmc/host/bfin_sdh.c:	set_dma_config(host->dma_ch, dma_cfg);
drivers/mmc/host/bfin_sdh.c:	set_dma_start_addr(host->dma_ch, sg_dma_address(&data->sg[0]));
drivers/mmc/host/bfin_sdh.c:	set_dma_x_count(host->dma_ch, length / 4);
drivers/mmc/host/bfin_sdh.c:	set_dma_x_modify(host->dma_ch, 4);
drivers/mmc/host/bfin_sdh.c:	set_dma_config(host->dma_ch, dma_cfg);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s exit\n", __func__);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter cmd: 0x%p\n", __func__, cmd);
drivers/mmc/host/bfin_sdh.c:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/bfin_sdh.c:	host->cmd = cmd;
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);
drivers/mmc/host/bfin_sdh.c:	host->mrq = NULL;
drivers/mmc/host/bfin_sdh.c:	host->cmd = NULL;
drivers/mmc/host/bfin_sdh.c:	host->data = NULL;
drivers/mmc/host/bfin_sdh.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/bfin_sdh.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter cmd: %p\n", __func__, cmd);
drivers/mmc/host/bfin_sdh.c:	host->cmd = NULL;
drivers/mmc/host/bfin_sdh.c:	if (host->data && !cmd->error) {
drivers/mmc/host/bfin_sdh.c:		if (host->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/bfin_sdh.c:			ret = sdh_setup_data(host, host->data);
drivers/mmc/host/bfin_sdh.c:		sdh_finish_request(host, host->mrq);
drivers/mmc/host/bfin_sdh.c:	struct mmc_data *data = host->data;
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter stat: 0x%x\n", __func__, stat);
drivers/mmc/host/bfin_sdh.c:	disable_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/bfin_sdh.c:		     host->dma_dir);
drivers/mmc/host/bfin_sdh.c:	host->data = NULL;
drivers/mmc/host/bfin_sdh.c:	if (host->mrq->stop) {
drivers/mmc/host/bfin_sdh.c:		sdh_start_cmd(host, host->mrq->stop);
drivers/mmc/host/bfin_sdh.c:		sdh_finish_request(host, host->mrq);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter, mrp:%p, cmd:%p\n", __func__, mrq, mrq->cmd);
drivers/mmc/host/bfin_sdh.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/bfin_sdh.c:	host->mrq = mrq;
drivers/mmc/host/bfin_sdh.c:	host->data = mrq->data;
drivers/mmc/host/bfin_sdh.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:		host->clk_div = clk_div;
drivers/mmc/host/bfin_sdh.c:	host->power_mode = ios->power_mode;
drivers/mmc/host/bfin_sdh.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "SDH: clk_div = 0x%x actual clock:%ld expected clock:%d\n",
drivers/mmc/host/bfin_sdh.c:		host->clk_div,
drivers/mmc/host/bfin_sdh.c:		host->clk_div ? get_sclk() / (2 * (host->clk_div + 1)) : 0,
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter, irq_stat: 0x%04x\n", __func__,
drivers/mmc/host/bfin_sdh.c:		get_dma_curr_irqstat(host->dma_ch));
drivers/mmc/host/bfin_sdh.c:	clear_dma_irqstat(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);
drivers/mmc/host/bfin_sdh.c:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/bfin_sdh.c:	dev_dbg(mmc_dev(host->mmc), "%s exit\n\n", __func__);
drivers/mmc/host/bfin_sdh.c:	host->mmc = mmc;
drivers/mmc/host/bfin_sdh.c:	spin_lock_init(&host->lock);
drivers/mmc/host/bfin_sdh.c:	host->irq = drv_data->irq_int0;
drivers/mmc/host/bfin_sdh.c:	host->dma_ch = drv_data->dma_chan;
drivers/mmc/host/bfin_sdh.c:	ret = request_dma(host->dma_ch, DRIVER_NAME "DMA");
drivers/mmc/host/bfin_sdh.c:	ret = set_dma_callback(host->dma_ch, sdh_dma_irq, host);
drivers/mmc/host/bfin_sdh.c:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/bfin_sdh.c:	if (host->sg_cpu == NULL) {
drivers/mmc/host/bfin_sdh.c:	ret = request_irq(host->irq, sdh_stat_irq, 0, "SDH Status IRQ", host);
drivers/mmc/host/bfin_sdh.c:	free_irq(host->irq, host);
drivers/mmc/host/bfin_sdh.c:	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/bfin_sdh.c:	free_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:		free_irq(host->irq, host);
drivers/mmc/host/bfin_sdh.c:		free_dma(host->dma_ch);
drivers/mmc/host/bfin_sdh.c:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/davinci_mmc.c:	host->buffer_bytes_left = sg_dma_len(host->sg);
drivers/mmc/host/davinci_mmc.c:	host->buffer = sg_virt(host->sg);
drivers/mmc/host/davinci_mmc.c:	if (host->buffer_bytes_left > host->bytes_left)
drivers/mmc/host/davinci_mmc.c:		host->buffer_bytes_left = host->bytes_left;
drivers/mmc/host/davinci_mmc.c:	if (host->buffer_bytes_left == 0) {
drivers/mmc/host/davinci_mmc.c:		host->sg = sg_next(host->data->sg);
drivers/mmc/host/davinci_mmc.c:	p = host->buffer;
drivers/mmc/host/davinci_mmc.c:	if (n > host->buffer_bytes_left)
drivers/mmc/host/davinci_mmc.c:		n = host->buffer_bytes_left;
drivers/mmc/host/davinci_mmc.c:	host->buffer_bytes_left -= n;
drivers/mmc/host/davinci_mmc.c:	host->bytes_left -= n;
drivers/mmc/host/davinci_mmc.c:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:			writel(*((u32 *)p), host->base + DAVINCI_MMCDXR);
drivers/mmc/host/davinci_mmc.c:			iowrite8_rep(host->base + DAVINCI_MMCDXR, p, (n & 3));
drivers/mmc/host/davinci_mmc.c:			*((u32 *)p) = readl(host->base + DAVINCI_MMCDRR);
drivers/mmc/host/davinci_mmc.c:			ioread8_rep(host->base + DAVINCI_MMCDRR, p, (n & 3));
drivers/mmc/host/davinci_mmc.c:	host->buffer = p;
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "CMD%d, arg 0x%08x%s\n",
drivers/mmc/host/davinci_mmc.c:	host->cmd = cmd;
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "unknown resp_type %04x\n",
drivers/mmc/host/davinci_mmc.c:	if (host->do_dma)
drivers/mmc/host/davinci_mmc.c:	if (host->version == MMC_CTLR_VERSION_2 && host->data != NULL &&
drivers/mmc/host/davinci_mmc.c:			host->data_dir == DAVINCI_MMC_DATADIR_READ)
drivers/mmc/host/davinci_mmc.c:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
drivers/mmc/host/davinci_mmc.c:	if (host->bus_mode == MMC_BUSMODE_PUSHPULL)
drivers/mmc/host/davinci_mmc.c:	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
drivers/mmc/host/davinci_mmc.c:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:		if (!host->do_dma)
drivers/mmc/host/davinci_mmc.c:	} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {
drivers/mmc/host/davinci_mmc.c:		if (!host->do_dma)
drivers/mmc/host/davinci_mmc.c:	if (!host->do_dma && (host->data_dir == DAVINCI_MMC_DATADIR_WRITE))
drivers/mmc/host/davinci_mmc.c:	writel(cmd->arg, host->base + DAVINCI_MMCARGHL);
drivers/mmc/host/davinci_mmc.c:	writel(cmd_reg,  host->base + DAVINCI_MMCCMD);
drivers/mmc/host/davinci_mmc.c:	host->active_request = true;
drivers/mmc/host/davinci_mmc.c:	if (!host->do_dma && host->bytes_left <= poll_threshold) {
drivers/mmc/host/davinci_mmc.c:		while (host->active_request && count--) {
drivers/mmc/host/davinci_mmc.c:	if (host->active_request)
drivers/mmc/host/davinci_mmc.c:		writel(im_val, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:	if (host->data_dir == DAVINCI_MMC_DATADIR_READ)
drivers/mmc/host/davinci_mmc.c:		sync_dev = host->rxdma;
drivers/mmc/host/davinci_mmc.c:		sync_dev = host->txdma;
drivers/mmc/host/davinci_mmc.c:		dev_warn(mmc_dev(host->mmc), "DMA %s error\n",
drivers/mmc/host/davinci_mmc.c:			(host->data->flags & MMC_DATA_WRITE)
drivers/mmc/host/davinci_mmc.c:		host->data->error = -EIO;
drivers/mmc/host/davinci_mmc.c:		mmc_davinci_xfer_done(host, host->data);
drivers/mmc/host/davinci_mmc.c:		sync_dev = host->txdma;
drivers/mmc/host/davinci_mmc.c:		dst_port = host->mem_res->start + DAVINCI_MMCDXR;
drivers/mmc/host/davinci_mmc.c:		sync_dev = host->rxdma;
drivers/mmc/host/davinci_mmc.c:		src_port = host->mem_res->start + DAVINCI_MMCDRR;
drivers/mmc/host/davinci_mmc.c:	unsigned		bytes_left = host->bytes_left;
drivers/mmc/host/davinci_mmc.c:	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
drivers/mmc/host/davinci_mmc.c:		template = &host->tx_template;
drivers/mmc/host/davinci_mmc.c:		channel = host->txdma;
drivers/mmc/host/davinci_mmc.c:		template = &host->rx_template;
drivers/mmc/host/davinci_mmc.c:		channel = host->rxdma;
drivers/mmc/host/davinci_mmc.c:	for (slot = channel, link = 0, sg = data->sg, sg_len = host->sg_len;
drivers/mmc/host/davinci_mmc.c:			sg = sg_next(sg), slot = host->links[link++]) {
drivers/mmc/host/davinci_mmc.c:				? (EDMA_CHAN_SLOT(host->links[link]) << 5)
drivers/mmc/host/davinci_mmc.c:		if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)
drivers/mmc/host/davinci_mmc.c:	if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:	host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/davinci_mmc.c:	for (i = 0; i < host->sg_len; i++) {
drivers/mmc/host/davinci_mmc.c:			dma_unmap_sg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:	host->do_dma = 1;
drivers/mmc/host/davinci_mmc.c:	if (!host->use_dma)
drivers/mmc/host/davinci_mmc.c:	for (i = 0; i < host->n_link; i++)
drivers/mmc/host/davinci_mmc.c:		edma_free_slot(host->links[i]);
drivers/mmc/host/davinci_mmc.c:	edma_free_channel(host->txdma);
drivers/mmc/host/davinci_mmc.c:	edma_free_channel(host->rxdma);
drivers/mmc/host/davinci_mmc.c:	r = edma_alloc_channel(host->txdma, mmc_davinci_dma_cb, host,
drivers/mmc/host/davinci_mmc.c:		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
drivers/mmc/host/davinci_mmc.c:	mmc_davinci_dma_setup(host, true, &host->tx_template);
drivers/mmc/host/davinci_mmc.c:	r = edma_alloc_channel(host->rxdma, mmc_davinci_dma_cb, host,
drivers/mmc/host/davinci_mmc.c:		dev_warn(mmc_dev(host->mmc), "alloc %s channel err %d\n",
drivers/mmc/host/davinci_mmc.c:	mmc_davinci_dma_setup(host, false, &host->rx_template);
drivers/mmc/host/davinci_mmc.c:	link_size = min_t(unsigned, host->nr_sg, ARRAY_SIZE(host->links));
drivers/mmc/host/davinci_mmc.c:		r = edma_alloc_slot(EDMA_CTLR(host->txdma), EDMA_SLOT_ANY);
drivers/mmc/host/davinci_mmc.c:			dev_dbg(mmc_dev(host->mmc), "dma PaRAM alloc --> %d\n",
drivers/mmc/host/davinci_mmc.c:		host->links[i] = r;
drivers/mmc/host/davinci_mmc.c:	host->n_link = i;
drivers/mmc/host/davinci_mmc.c:	edma_free_channel(host->txdma);
drivers/mmc/host/davinci_mmc.c:	if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:	host->data = data;
drivers/mmc/host/davinci_mmc.c:		host->data_dir = DAVINCI_MMC_DATADIR_NONE;
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCBLEN);
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCNBLK);
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "%s %s, %d blocks of %d bytes\n",
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "  DTO %d cycles + %d ns\n",
drivers/mmc/host/davinci_mmc.c:		(data->timeout_ns / host->ns_in_one_cycle);
drivers/mmc/host/davinci_mmc.c:	writel(timeout, host->base + DAVINCI_MMCTOD);
drivers/mmc/host/davinci_mmc.c:	writel(data->blocks, host->base + DAVINCI_MMCNBLK);
drivers/mmc/host/davinci_mmc.c:	writel(data->blksz, host->base + DAVINCI_MMCBLEN);
drivers/mmc/host/davinci_mmc.c:		host->data_dir = DAVINCI_MMC_DATADIR_WRITE;
drivers/mmc/host/davinci_mmc.c:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:		host->data_dir = DAVINCI_MMC_DATADIR_READ;
drivers/mmc/host/davinci_mmc.c:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:			host->base + DAVINCI_MMCFIFOCTL);
drivers/mmc/host/davinci_mmc.c:	host->buffer = NULL;
drivers/mmc/host/davinci_mmc.c:	host->bytes_left = data->blocks * data->blksz;
drivers/mmc/host/davinci_mmc.c:	if (host->use_dma && (host->bytes_left & (rw_threshold - 1)) == 0
drivers/mmc/host/davinci_mmc.c:		host->bytes_left = 0;
drivers/mmc/host/davinci_mmc.c:		host->sg_len = data->sg_len;
drivers/mmc/host/davinci_mmc.c:		host->sg = host->data->sg;
drivers/mmc/host/davinci_mmc.c:		mmcst1  = readl(host->base + DAVINCI_MMCST1);
drivers/mmc/host/davinci_mmc.c:		dev_err(mmc_dev(host->mmc), "still BUSY? bad ... \n");
drivers/mmc/host/davinci_mmc.c:	host->do_dma = 0;
drivers/mmc/host/davinci_mmc.c:	mmc_pclk = host->mmc_input_clk;
drivers/mmc/host/davinci_mmc.c:		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
drivers/mmc/host/davinci_mmc.c:		host->ns_in_one_cycle = (1000000) / (((mmc_pclk
drivers/mmc/host/davinci_mmc.c:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
drivers/mmc/host/davinci_mmc.c:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:		host->ns_in_one_cycle = (1000000) / (MMCSD_INIT_CLOCK/1000);
drivers/mmc/host/davinci_mmc.c:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN;
drivers/mmc/host/davinci_mmc.c:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:		temp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;
drivers/mmc/host/davinci_mmc.c:		writel(temp, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:		writel(temp | MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "Enabling 8 bit mode\n");
drivers/mmc/host/davinci_mmc.c:		writel((readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:			host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "Enabling 4 bit mode\n");
drivers/mmc/host/davinci_mmc.c:		if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:			writel((readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:			writel(readl(host->base + DAVINCI_MMCCTL) |
drivers/mmc/host/davinci_mmc.c:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "Enabling 1 bit mode\n");
drivers/mmc/host/davinci_mmc.c:		if (host->version == MMC_CTLR_VERSION_2)
drivers/mmc/host/davinci_mmc.c:			writel(readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:			writel(readl(host->base + DAVINCI_MMCCTL) &
drivers/mmc/host/davinci_mmc.c:				host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:	host->bus_mode = ios->bus_mode;
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCARGHL);
drivers/mmc/host/davinci_mmc.c:		writel(MMCCMD_INITCK, host->base + DAVINCI_MMCCMD);
drivers/mmc/host/davinci_mmc.c:			u32 tmp = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:			dev_warn(mmc_dev(host->mmc), "powerup timeout\n");
drivers/mmc/host/davinci_mmc.c:	host->data = NULL;
drivers/mmc/host/davinci_mmc.c:	if (host->mmc->caps & MMC_CAP_SDIO_IRQ) {
drivers/mmc/host/davinci_mmc.c:		if (host->sdio_int && !(readl(host->base + DAVINCI_SDIOST0) &
drivers/mmc/host/davinci_mmc.c:			writel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);
drivers/mmc/host/davinci_mmc.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/davinci_mmc.c:	if (host->do_dma) {
drivers/mmc/host/davinci_mmc.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/davinci_mmc.c:		host->do_dma = false;
drivers/mmc/host/davinci_mmc.c:	host->data_dir = DAVINCI_MMC_DATADIR_NONE;
drivers/mmc/host/davinci_mmc.c:	if (!data->stop || (host->cmd && host->cmd->error)) {
drivers/mmc/host/davinci_mmc.c:		mmc_request_done(host->mmc, data->mrq);
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:		host->active_request = false;
drivers/mmc/host/davinci_mmc.c:	host->cmd = NULL;
drivers/mmc/host/davinci_mmc.c:			cmd->resp[3] = readl(host->base + DAVINCI_MMCRSP01);
drivers/mmc/host/davinci_mmc.c:			cmd->resp[2] = readl(host->base + DAVINCI_MMCRSP23);
drivers/mmc/host/davinci_mmc.c:			cmd->resp[1] = readl(host->base + DAVINCI_MMCRSP45);
drivers/mmc/host/davinci_mmc.c:			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
drivers/mmc/host/davinci_mmc.c:			cmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);
drivers/mmc/host/davinci_mmc.c:	if (host->data == NULL || cmd->error) {
drivers/mmc/host/davinci_mmc.c:		mmc_request_done(host->mmc, cmd->mrq);
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:		host->active_request = false;
drivers/mmc/host/davinci_mmc.c:	temp = readl(host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:	writel(temp, host->base + DAVINCI_MMCCTL);
drivers/mmc/host/davinci_mmc.c:	status = readl(host->base + DAVINCI_SDIOIST);
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:		writel(status | SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);
drivers/mmc/host/davinci_mmc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/davinci_mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/davinci_mmc.c:	if (host->cmd == NULL && host->data == NULL) {
drivers/mmc/host/davinci_mmc.c:		status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:	status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:	if (host->bytes_left && (status & (MMCST0_DXRDY | MMCST0_DRRDY))) {
drivers/mmc/host/davinci_mmc.c:		im_val = readl(host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:			status = readl(host->base + DAVINCI_MMCST0);
drivers/mmc/host/davinci_mmc.c:		} while (host->bytes_left &&
drivers/mmc/host/davinci_mmc.c:		writel(im_val, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:			if ((host->do_dma == 0) && (host->bytes_left > 0)) {
drivers/mmc/host/davinci_mmc.c:				davinci_fifo_data_trans(host, host->bytes_left);
drivers/mmc/host/davinci_mmc.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:					"DATDNE with no host->data\n");
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:			u32 temp = readb(host->base + DAVINCI_MMCDRSP);
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "data %s %s error\n",
drivers/mmc/host/davinci_mmc.c:		if (host->cmd) {
drivers/mmc/host/davinci_mmc.c:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/davinci_mmc.c:				host->cmd->opcode, qstatus);
drivers/mmc/host/davinci_mmc.c:			host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/davinci_mmc.c:		dev_dbg(mmc_dev(host->mmc), "Command CRC error\n");
drivers/mmc/host/davinci_mmc.c:		if (host->cmd) {
drivers/mmc/host/davinci_mmc.c:			host->cmd->error = -EILSEQ;
drivers/mmc/host/davinci_mmc.c:		end_command = (int) host->cmd;
drivers/mmc/host/davinci_mmc.c:		mmc_davinci_cmd_done(host, host->cmd);
drivers/mmc/host/davinci_mmc.c:		if (!(readl(host->base + DAVINCI_SDIOST0) & SDIOST0_DAT1_HI)) {
drivers/mmc/host/davinci_mmc.c:			writel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);
drivers/mmc/host/davinci_mmc.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/davinci_mmc.c:			host->sdio_int = true;
drivers/mmc/host/davinci_mmc.c:			writel(readl(host->base + DAVINCI_SDIOIEN) |
drivers/mmc/host/davinci_mmc.c:			       SDIOIEN_IOINTEN, host->base + DAVINCI_SDIOIEN);
drivers/mmc/host/davinci_mmc.c:		host->sdio_int = false;
drivers/mmc/host/davinci_mmc.c:		writel(readl(host->base + DAVINCI_SDIOIEN) & ~SDIOIEN_IOINTEN,
drivers/mmc/host/davinci_mmc.c:		       host->base + DAVINCI_SDIOIEN);
drivers/mmc/host/davinci_mmc.c:	mmc = host->mmc;
drivers/mmc/host/davinci_mmc.c:	mmc_pclk = clk_get_rate(host->clk);
drivers/mmc/host/davinci_mmc.c:		host->mmc_input_clk = mmc_pclk;
drivers/mmc/host/davinci_mmc.c:	host->freq_transition.notifier_call = mmc_davinci_cpufreq_transition;
drivers/mmc/host/davinci_mmc.c:	return cpufreq_register_notifier(&host->freq_transition,
drivers/mmc/host/davinci_mmc.c:	cpufreq_unregister_notifier(&host->freq_transition,
drivers/mmc/host/davinci_mmc.c:	writel(0, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:	writel(MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);
drivers/mmc/host/davinci_mmc.c:	writel(0x1FFF, host->base + DAVINCI_MMCTOR);
drivers/mmc/host/davinci_mmc.c:	writel(0xFFFF, host->base + DAVINCI_MMCTOD);
drivers/mmc/host/davinci_mmc.c:	host->mmc = mmc;	/* Important */
drivers/mmc/host/davinci_mmc.c:	host->rxdma = r->start;
drivers/mmc/host/davinci_mmc.c:	host->txdma = r->start;
drivers/mmc/host/davinci_mmc.c:	host->mem_res = mem;
drivers/mmc/host/davinci_mmc.c:	host->base = ioremap(mem->start, mem_size);
drivers/mmc/host/davinci_mmc.c:	if (!host->base)
drivers/mmc/host/davinci_mmc.c:	host->clk = clk_get(&pdev->dev, "MMCSDCLK");
drivers/mmc/host/davinci_mmc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/davinci_mmc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/davinci_mmc.c:	clk_enable(host->clk);
drivers/mmc/host/davinci_mmc.c:	host->mmc_input_clk = clk_get_rate(host->clk);
drivers/mmc/host/davinci_mmc.c:		host->nr_sg = pdata->nr_sg - 1;
drivers/mmc/host/davinci_mmc.c:	if (host->nr_sg > MAX_NR_SG || !host->nr_sg)
drivers/mmc/host/davinci_mmc.c:		host->nr_sg = MAX_NR_SG;
drivers/mmc/host/davinci_mmc.c:	host->use_dma = use_dma;
drivers/mmc/host/davinci_mmc.c:	host->mmc_irq = irq;
drivers/mmc/host/davinci_mmc.c:	host->sdio_irq = platform_get_irq(pdev, 1);
drivers/mmc/host/davinci_mmc.c:	if (host->use_dma && davinci_acquire_dma_channels(host) != 0)
drivers/mmc/host/davinci_mmc.c:		host->use_dma = 0;
drivers/mmc/host/davinci_mmc.c:	host->version = pdata->version;
drivers/mmc/host/davinci_mmc.c:	mmc->max_segs		= 1 + host->n_link;
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "max_segs=%d\n", mmc->max_segs);
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "max_blk_size=%d\n", mmc->max_blk_size);
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "max_req_size=%d\n", mmc->max_req_size);
drivers/mmc/host/davinci_mmc.c:	dev_dbg(mmc_dev(host->mmc), "max_seg_size=%d\n", mmc->max_seg_size);
drivers/mmc/host/davinci_mmc.c:	if (host->sdio_irq >= 0) {
drivers/mmc/host/davinci_mmc.c:		ret = request_irq(host->sdio_irq, mmc_davinci_sdio_irq, 0,
drivers/mmc/host/davinci_mmc.c:	dev_info(mmc_dev(host->mmc), "Using %s, %d-bit mode\n",
drivers/mmc/host/davinci_mmc.c:		host->use_dma ? "DMA" : "PIO",
drivers/mmc/host/davinci_mmc.c:		if (host->clk) {
drivers/mmc/host/davinci_mmc.c:			clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:			clk_put(host->clk);
drivers/mmc/host/davinci_mmc.c:		if (host->base)
drivers/mmc/host/davinci_mmc.c:			iounmap(host->base);
drivers/mmc/host/davinci_mmc.c:		mmc_remove_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:		free_irq(host->mmc_irq, host);
drivers/mmc/host/davinci_mmc.c:		if (host->mmc->caps & MMC_CAP_SDIO_IRQ)
drivers/mmc/host/davinci_mmc.c:			free_irq(host->sdio_irq, host);
drivers/mmc/host/davinci_mmc.c:		clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:		clk_put(host->clk);
drivers/mmc/host/davinci_mmc.c:		iounmap(host->base);
drivers/mmc/host/davinci_mmc.c:		release_resource(host->mem_res);
drivers/mmc/host/davinci_mmc.c:		mmc_free_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:		writel(0, host->base + DAVINCI_MMCIM);
drivers/mmc/host/davinci_mmc.c:		clk_disable(host->clk);
drivers/mmc/host/davinci_mmc.c:		host->suspended = 1;
drivers/mmc/host/davinci_mmc.c:		host->suspended = 0;
drivers/mmc/host/davinci_mmc.c:	if (!host->suspended)
drivers/mmc/host/davinci_mmc.c:	clk_enable(host->clk);
drivers/mmc/host/davinci_mmc.c:	ret = mmc_resume_host(host->mmc);
drivers/mmc/host/davinci_mmc.c:		host->suspended = 0;
drivers/mmc/host/dw_mmc-pci.c:	host->irq = pdev->irq;
drivers/mmc/host/dw_mmc-pci.c:	host->irq_flags = IRQF_SHARED;
drivers/mmc/host/dw_mmc-pci.c:	host->dev = pdev->dev;
drivers/mmc/host/dw_mmc-pci.c:	host->pdata = &pci_board_data;
drivers/mmc/host/dw_mmc-pci.c:	host->regs = pci_iomap(pdev, PCI_BAR_NO, COMPLETE_BAR);
drivers/mmc/host/dw_mmc-pci.c:	if (!host->regs) {
drivers/mmc/host/dw_mmc-pci.c:	pci_iounmap(pdev, host->regs);
drivers/mmc/host/dw_mmc-pci.c:	pci_iounmap(pdev, host->regs);
drivers/mmc/host/dw_mmc-pltfm.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/dw_mmc-pltfm.c:	if (host->irq < 0) {
drivers/mmc/host/dw_mmc-pltfm.c:		ret = host->irq;
drivers/mmc/host/dw_mmc-pltfm.c:	host->dev = pdev->dev;
drivers/mmc/host/dw_mmc-pltfm.c:	host->irq_flags = 0;
drivers/mmc/host/dw_mmc-pltfm.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/dw_mmc-pltfm.c:	host->regs = ioremap(regs->start, resource_size(regs));
drivers/mmc/host/dw_mmc-pltfm.c:	if (!host->regs)
drivers/mmc/host/dw_mmc-pltfm.c:	iounmap(host->regs);
drivers/mmc/host/dw_mmc-pltfm.c:	iounmap(host->regs);
drivers/mmc/host/dw_mmc.c: * @clock: Clock rate configured by set_ios(). Protected by host->lock.
drivers/mmc/host/dw_mmc.c:	spin_lock_bh(&slot->host->lock);
drivers/mmc/host/dw_mmc.c:	spin_unlock_bh(&slot->host->lock);
drivers/mmc/host/dw_mmc.c:	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
drivers/mmc/host/dw_mmc.c:				  (u32 *)&host->pending_events);
drivers/mmc/host/dw_mmc.c:				  (u32 *)&host->completed_events);
drivers/mmc/host/dw_mmc.c:	host->cmd = cmd;
drivers/mmc/host/dw_mmc.c:	dev_vdbg(&host->dev,
drivers/mmc/host/dw_mmc.c:	dw_mci_start_command(host, data->stop, host->stop_cmdr);
drivers/mmc/host/dw_mmc.c:	if (host->using_dma) {
drivers/mmc/host/dw_mmc.c:		host->dma_ops->stop(host);
drivers/mmc/host/dw_mmc.c:		host->dma_ops->cleanup(host);
drivers/mmc/host/dw_mmc.c:		set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/dw_mmc.c:			dma_unmap_sg(&host->dev,
drivers/mmc/host/dw_mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/dw_mmc.c:	dev_vdbg(&host->dev, "DMA complete\n");
drivers/mmc/host/dw_mmc.c:	host->dma_ops->cleanup(host);
drivers/mmc/host/dw_mmc.c:		set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:	struct idmac_desc *desc = host->sg_cpu;
drivers/mmc/host/dw_mmc.c:	desc = host->sg_cpu;
drivers/mmc/host/dw_mmc.c:	desc = host->sg_cpu + (i - 1) * sizeof(struct idmac_desc);
drivers/mmc/host/dw_mmc.c:	dw_mci_translate_sglist(host, host->data, sg_len);
drivers/mmc/host/dw_mmc.c:	host->ring_size = PAGE_SIZE / sizeof(struct idmac_desc);
drivers/mmc/host/dw_mmc.c:	for (i = 0, p = host->sg_cpu; i < host->ring_size - 1; i++, p++)
drivers/mmc/host/dw_mmc.c:		p->des3 = host->sg_dma + (sizeof(struct idmac_desc) * (i + 1));
drivers/mmc/host/dw_mmc.c:	p->des3 = host->sg_dma;
drivers/mmc/host/dw_mmc.c:	mci_writel(host, DBADDR, host->sg_dma);
drivers/mmc/host/dw_mmc.c:	sg_len = dma_map_sg(&host->dev,
drivers/mmc/host/dw_mmc.c:	if (!slot->host->use_dma || !data)
drivers/mmc/host/dw_mmc.c:	if (!slot->host->use_dma || !data)
drivers/mmc/host/dw_mmc.c:		dma_unmap_sg(&slot->host->dev,
drivers/mmc/host/dw_mmc.c:	host->using_dma = 0;
drivers/mmc/host/dw_mmc.c:	if (!host->use_dma)
drivers/mmc/host/dw_mmc.c:		host->dma_ops->stop(host);
drivers/mmc/host/dw_mmc.c:	host->using_dma = 1;
drivers/mmc/host/dw_mmc.c:	dev_vdbg(&host->dev,
drivers/mmc/host/dw_mmc.c:		 (unsigned long)host->sg_cpu, (unsigned long)host->sg_dma,
drivers/mmc/host/dw_mmc.c:	host->dma_ops->start(host, sg_len);
drivers/mmc/host/dw_mmc.c:	WARN_ON(host->data);
drivers/mmc/host/dw_mmc.c:	host->sg = NULL;
drivers/mmc/host/dw_mmc.c:	host->data = data;
drivers/mmc/host/dw_mmc.c:		host->dir_status = DW_MCI_RECV_STATUS;
drivers/mmc/host/dw_mmc.c:		host->dir_status = DW_MCI_SEND_STATUS;
drivers/mmc/host/dw_mmc.c:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/dw_mmc.c:		sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
drivers/mmc/host/dw_mmc.c:		host->sg = data->sg;
drivers/mmc/host/dw_mmc.c:		host->part_buf_start = 0;
drivers/mmc/host/dw_mmc.c:		host->part_buf_count = 0;
drivers/mmc/host/dw_mmc.c:	if (slot->clock != host->current_speed) {
drivers/mmc/host/dw_mmc.c:		if (host->bus_hz % slot->clock)
drivers/mmc/host/dw_mmc.c:			div = ((host->bus_hz / slot->clock) >> 1) + 1;
drivers/mmc/host/dw_mmc.c:			div = (host->bus_hz  / slot->clock) >> 1;
drivers/mmc/host/dw_mmc.c:			 " div = %d)\n", slot->id, host->bus_hz, slot->clock,
drivers/mmc/host/dw_mmc.c:			 div ? ((host->bus_hz / div) >> 1) : host->bus_hz, div);
drivers/mmc/host/dw_mmc.c:		host->current_speed = slot->clock;
drivers/mmc/host/dw_mmc.c:	if (host->pdata->select_slot)
drivers/mmc/host/dw_mmc.c:		host->pdata->select_slot(slot->id);
drivers/mmc/host/dw_mmc.c:	host->cur_slot = slot;
drivers/mmc/host/dw_mmc.c:	host->mrq = mrq;
drivers/mmc/host/dw_mmc.c:	host->pending_events = 0;
drivers/mmc/host/dw_mmc.c:	host->completed_events = 0;
drivers/mmc/host/dw_mmc.c:	host->data_status = 0;
drivers/mmc/host/dw_mmc.c:		host->stop_cmdr = dw_mci_prepare_command(slot->mmc, mrq->stop);
drivers/mmc/host/dw_mmc.c:/* must be called with host->lock held */
drivers/mmc/host/dw_mmc.c:		 host->state);
drivers/mmc/host/dw_mmc.c:	if (host->state == STATE_IDLE) {
drivers/mmc/host/dw_mmc.c:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/dw_mmc.c:		list_add_tail(&slot->queue_node, &host->queue);
drivers/mmc/host/dw_mmc.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/dw_mmc.c:		spin_unlock_bh(&host->lock);
drivers/mmc/host/dw_mmc.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/dw_mmc.c:	struct dw_mci_board *brd = slot->host->pdata;
drivers/mmc/host/dw_mmc.c:	struct dw_mci_board *brd = slot->host->pdata;
drivers/mmc/host/dw_mmc.c:	__releases(&host->lock)
drivers/mmc/host/dw_mmc.c:	__acquires(&host->lock)
drivers/mmc/host/dw_mmc.c:	struct mmc_host	*prev_mmc = host->cur_slot->mmc;
drivers/mmc/host/dw_mmc.c:	WARN_ON(host->cmd || host->data);
drivers/mmc/host/dw_mmc.c:	host->cur_slot->mrq = NULL;
drivers/mmc/host/dw_mmc.c:	host->mrq = NULL;
drivers/mmc/host/dw_mmc.c:	if (!list_empty(&host->queue)) {
drivers/mmc/host/dw_mmc.c:		slot = list_entry(host->queue.next,
drivers/mmc/host/dw_mmc.c:		dev_vdbg(&host->dev, "list not empty: %s is next\n",
drivers/mmc/host/dw_mmc.c:		host->state = STATE_SENDING_CMD;
drivers/mmc/host/dw_mmc.c:		dev_vdbg(&host->dev, "list empty\n");
drivers/mmc/host/dw_mmc.c:		host->state = STATE_IDLE;
drivers/mmc/host/dw_mmc.c:	spin_unlock(&host->lock);
drivers/mmc/host/dw_mmc.c:	spin_lock(&host->lock);
drivers/mmc/host/dw_mmc.c:	u32 status = host->cmd_status;
drivers/mmc/host/dw_mmc.c:	host->cmd_status = 0;
drivers/mmc/host/dw_mmc.c:		if (host->quirks & DW_MCI_QUIRK_RETRY_DELAY)
drivers/mmc/host/dw_mmc.c:			host->data = NULL;
drivers/mmc/host/dw_mmc.c:	spin_lock(&host->lock);
drivers/mmc/host/dw_mmc.c:	state = host->state;
drivers/mmc/host/dw_mmc.c:	data = host->data;
drivers/mmc/host/dw_mmc.c:						&host->pending_events))
drivers/mmc/host/dw_mmc.c:			cmd = host->cmd;
drivers/mmc/host/dw_mmc.c:			host->cmd = NULL;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
drivers/mmc/host/dw_mmc.c:			if (cmd == host->mrq->sbc && !cmd->error) {
drivers/mmc/host/dw_mmc.c:				__dw_mci_start_request(host, host->cur_slot,
drivers/mmc/host/dw_mmc.c:						       host->mrq->cmd);
drivers/mmc/host/dw_mmc.c:			if (!host->mrq->data || cmd->error) {
drivers/mmc/host/dw_mmc.c:				dw_mci_request_end(host, host->mrq);
drivers/mmc/host/dw_mmc.c:					       &host->pending_events)) {
drivers/mmc/host/dw_mmc.c:						&host->pending_events))
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
drivers/mmc/host/dw_mmc.c:						&host->pending_events))
drivers/mmc/host/dw_mmc.c:			host->data = NULL;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
drivers/mmc/host/dw_mmc.c:			status = host->data_status;
drivers/mmc/host/dw_mmc.c:					   host->dir_status ==
drivers/mmc/host/dw_mmc.c:					dev_err(&host->dev,
drivers/mmc/host/dw_mmc.c:				sg_miter_stop(&host->sg_miter);
drivers/mmc/host/dw_mmc.c:				host->sg = NULL;
drivers/mmc/host/dw_mmc.c:				dw_mci_request_end(host, host->mrq);
drivers/mmc/host/dw_mmc.c:			if (host->mrq->sbc && !data->error) {
drivers/mmc/host/dw_mmc.c:				dw_mci_request_end(host, host->mrq);
drivers/mmc/host/dw_mmc.c:						&host->pending_events))
drivers/mmc/host/dw_mmc.c:			host->cmd = NULL;
drivers/mmc/host/dw_mmc.c:			dw_mci_command_complete(host, host->mrq->stop);
drivers/mmc/host/dw_mmc.c:			dw_mci_request_end(host, host->mrq);
drivers/mmc/host/dw_mmc.c:						&host->pending_events))
drivers/mmc/host/dw_mmc.c:	host->state = state;
drivers/mmc/host/dw_mmc.c:	spin_unlock(&host->lock);
drivers/mmc/host/dw_mmc.c:	memcpy((void *)&host->part_buf, buf, cnt);
drivers/mmc/host/dw_mmc.c:	host->part_buf_count = cnt;
drivers/mmc/host/dw_mmc.c:	cnt = min(cnt, (1 << host->data_shift) - host->part_buf_count);
drivers/mmc/host/dw_mmc.c:	memcpy((void *)&host->part_buf + host->part_buf_count, buf, cnt);
drivers/mmc/host/dw_mmc.c:	host->part_buf_count += cnt;
drivers/mmc/host/dw_mmc.c:	cnt = min(cnt, (int)host->part_buf_count);
drivers/mmc/host/dw_mmc.c:		memcpy(buf, (void *)&host->part_buf + host->part_buf_start,
drivers/mmc/host/dw_mmc.c:		host->part_buf_count -= cnt;
drivers/mmc/host/dw_mmc.c:		host->part_buf_start += cnt;
drivers/mmc/host/dw_mmc.c:	memcpy(buf, &host->part_buf, cnt);
drivers/mmc/host/dw_mmc.c:	host->part_buf_start = cnt;
drivers/mmc/host/dw_mmc.c:	host->part_buf_count = (1 << host->data_shift) - cnt;
drivers/mmc/host/dw_mmc.c:	if (unlikely(host->part_buf_count)) {
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg) || host->part_buf_count == 2) {
drivers/mmc/host/dw_mmc.c:			mci_writew(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:					host->part_buf16);
drivers/mmc/host/dw_mmc.c:			host->part_buf_count = 0;
drivers/mmc/host/dw_mmc.c:				mci_writew(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:			mci_writew(host, DATA(host->data_offset), *pdata++);
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg))
drivers/mmc/host/dw_mmc.c:			mci_writew(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:					host->part_buf16);
drivers/mmc/host/dw_mmc.c:						DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:			*pdata++ = mci_readw(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:		host->part_buf16 = mci_readw(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:	if (unlikely(host->part_buf_count)) {
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg) || host->part_buf_count == 4) {
drivers/mmc/host/dw_mmc.c:			mci_writel(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:					host->part_buf32);
drivers/mmc/host/dw_mmc.c:			host->part_buf_count = 0;
drivers/mmc/host/dw_mmc.c:				mci_writel(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:			mci_writel(host, DATA(host->data_offset), *pdata++);
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg))
drivers/mmc/host/dw_mmc.c:			mci_writel(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:						host->part_buf32);
drivers/mmc/host/dw_mmc.c:						DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:			*pdata++ = mci_readl(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:		host->part_buf32 = mci_readl(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:	if (unlikely(host->part_buf_count)) {
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg) || host->part_buf_count == 8) {
drivers/mmc/host/dw_mmc.c:			mci_writew(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:					host->part_buf);
drivers/mmc/host/dw_mmc.c:			host->part_buf_count = 0;
drivers/mmc/host/dw_mmc.c:				mci_writeq(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:			mci_writeq(host, DATA(host->data_offset), *pdata++);
drivers/mmc/host/dw_mmc.c:		if (!sg_next(host->sg))
drivers/mmc/host/dw_mmc.c:			mci_writeq(host, DATA(host->data_offset),
drivers/mmc/host/dw_mmc.c:					host->part_buf);
drivers/mmc/host/dw_mmc.c:						DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:			*pdata++ = mci_readq(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:		host->part_buf = mci_readq(host, DATA(host->data_offset));
drivers/mmc/host/dw_mmc.c:	host->pull_data(host, buf, cnt);
drivers/mmc/host/dw_mmc.c:	struct sg_mapping_iter *sg_miter = &host->sg_miter;
drivers/mmc/host/dw_mmc.c:	struct mmc_data	*data = host->data;
drivers/mmc/host/dw_mmc.c:	int shift = host->data_shift;
drivers/mmc/host/dw_mmc.c:		host->sg = sg_miter->__sg;
drivers/mmc/host/dw_mmc.c:					<< shift) + host->part_buf_count;
drivers/mmc/host/dw_mmc.c:			host->data_status = status;
drivers/mmc/host/dw_mmc.c:			host->sg = NULL;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_DATA_ERROR, &host->pending_events);
drivers/mmc/host/dw_mmc.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:	host->sg = NULL;
drivers/mmc/host/dw_mmc.c:	set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:	struct sg_mapping_iter *sg_miter = &host->sg_miter;
drivers/mmc/host/dw_mmc.c:	struct mmc_data	*data = host->data;
drivers/mmc/host/dw_mmc.c:	int shift = host->data_shift;
drivers/mmc/host/dw_mmc.c:	unsigned int fifo_depth = host->fifo_depth;
drivers/mmc/host/dw_mmc.c:		host->sg = sg_miter->__sg;
drivers/mmc/host/dw_mmc.c:					<< shift) - host->part_buf_count;
drivers/mmc/host/dw_mmc.c:			host->push_data(host, (void *)(buf + offset), len);
drivers/mmc/host/dw_mmc.c:			host->data_status = status;
drivers/mmc/host/dw_mmc.c:			host->sg = NULL;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_DATA_ERROR, &host->pending_events);
drivers/mmc/host/dw_mmc.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:	host->sg = NULL;
drivers/mmc/host/dw_mmc.c:	set_bit(EVENT_XFER_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:	if (!host->cmd_status)
drivers/mmc/host/dw_mmc.c:		host->cmd_status = status;
drivers/mmc/host/dw_mmc.c:	set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:		if (host->quirks & DW_MCI_QUIRK_IDMAC_DTO) {
drivers/mmc/host/dw_mmc.c:			host->cmd_status = status;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:			host->data_status = status;
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_DATA_ERROR, &host->pending_events);
drivers/mmc/host/dw_mmc.c:				tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:			if (!host->data_status)
drivers/mmc/host/dw_mmc.c:				host->data_status = status;
drivers/mmc/host/dw_mmc.c:			if (host->dir_status == DW_MCI_RECV_STATUS) {
drivers/mmc/host/dw_mmc.c:				if (host->sg != NULL)
drivers/mmc/host/dw_mmc.c:			set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/dw_mmc.c:			if (host->dir_status == DW_MCI_RECV_STATUS && host->sg)
drivers/mmc/host/dw_mmc.c:			if (host->dir_status == DW_MCI_SEND_STATUS && host->sg)
drivers/mmc/host/dw_mmc.c:			queue_work(dw_mci_card_workqueue, &host->card_work);
drivers/mmc/host/dw_mmc.c:		for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:			struct dw_mci_slot *slot = host->slot[i];
drivers/mmc/host/dw_mmc.c:		set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
drivers/mmc/host/dw_mmc.c:		host->dma_ops->complete(host);
drivers/mmc/host/dw_mmc.c:	for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:		struct dw_mci_slot *slot = host->slot[i];
drivers/mmc/host/dw_mmc.c:			if (present != 0 && host->pdata->setpower)
drivers/mmc/host/dw_mmc.c:				host->pdata->setpower(slot->id, mmc->ocr_avail);
drivers/mmc/host/dw_mmc.c:			spin_lock_bh(&host->lock);
drivers/mmc/host/dw_mmc.c:				if (mrq == host->mrq) {
drivers/mmc/host/dw_mmc.c:					host->data = NULL;
drivers/mmc/host/dw_mmc.c:					host->cmd = NULL;
drivers/mmc/host/dw_mmc.c:					switch (host->state) {
drivers/mmc/host/dw_mmc.c:					spin_unlock(&host->lock);
drivers/mmc/host/dw_mmc.c:					spin_lock(&host->lock);
drivers/mmc/host/dw_mmc.c:				sg_miter_stop(&host->sg_miter);
drivers/mmc/host/dw_mmc.c:				host->sg = NULL;
drivers/mmc/host/dw_mmc.c:			spin_unlock_bh(&host->lock);
drivers/mmc/host/dw_mmc.c:			if (present == 0 && host->pdata->setpower)
drivers/mmc/host/dw_mmc.c:				host->pdata->setpower(slot->id, 0);
drivers/mmc/host/dw_mmc.c:			msecs_to_jiffies(host->pdata->detect_delay_ms));
drivers/mmc/host/dw_mmc.c:	mmc = mmc_alloc_host(sizeof(struct dw_mci_slot), &host->dev);
drivers/mmc/host/dw_mmc.c:	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
drivers/mmc/host/dw_mmc.c:	mmc->f_max = host->bus_hz;
drivers/mmc/host/dw_mmc.c:	if (host->pdata->get_ocr)
drivers/mmc/host/dw_mmc.c:		mmc->ocr_avail = host->pdata->get_ocr(id);
drivers/mmc/host/dw_mmc.c:	if (host->pdata->setpower)
drivers/mmc/host/dw_mmc.c:		host->pdata->setpower(id, 0);
drivers/mmc/host/dw_mmc.c:	if (host->pdata->caps)
drivers/mmc/host/dw_mmc.c:		mmc->caps = host->pdata->caps;
drivers/mmc/host/dw_mmc.c:	if (host->pdata->caps2)
drivers/mmc/host/dw_mmc.c:		mmc->caps2 = host->pdata->caps2;
drivers/mmc/host/dw_mmc.c:	if (host->pdata->get_bus_wd)
drivers/mmc/host/dw_mmc.c:		if (host->pdata->get_bus_wd(slot->id) >= 4)
drivers/mmc/host/dw_mmc.c:	if (host->pdata->quirks & DW_MCI_QUIRK_HIGHSPEED)
drivers/mmc/host/dw_mmc.c:	if (host->pdata->blk_settings) {
drivers/mmc/host/dw_mmc.c:		mmc->max_segs = host->pdata->blk_settings->max_segs;
drivers/mmc/host/dw_mmc.c:		mmc->max_blk_size = host->pdata->blk_settings->max_blk_size;
drivers/mmc/host/dw_mmc.c:		mmc->max_blk_count = host->pdata->blk_settings->max_blk_count;
drivers/mmc/host/dw_mmc.c:		mmc->max_req_size = host->pdata->blk_settings->max_req_size;
drivers/mmc/host/dw_mmc.c:		mmc->max_seg_size = host->pdata->blk_settings->max_seg_size;
drivers/mmc/host/dw_mmc.c:		mmc->max_segs = host->ring_size;
drivers/mmc/host/dw_mmc.c:		mmc->max_blk_count = host->ring_size;
drivers/mmc/host/dw_mmc.c:	host->vmmc = regulator_get(mmc_dev(mmc), "vmmc");
drivers/mmc/host/dw_mmc.c:	if (IS_ERR(host->vmmc)) {
drivers/mmc/host/dw_mmc.c:		host->vmmc = NULL;
drivers/mmc/host/dw_mmc.c:		regulator_enable(host->vmmc);
drivers/mmc/host/dw_mmc.c:	host->slot[id] = slot;
drivers/mmc/host/dw_mmc.c:	queue_work(dw_mci_card_workqueue, &host->card_work);
drivers/mmc/host/dw_mmc.c:	if (slot->host->pdata->exit)
drivers/mmc/host/dw_mmc.c:		slot->host->pdata->exit(id);
drivers/mmc/host/dw_mmc.c:	slot->host->slot[id] = NULL;
drivers/mmc/host/dw_mmc.c:	host->sg_cpu = dma_alloc_coherent(&host->dev, PAGE_SIZE,
drivers/mmc/host/dw_mmc.c:					  &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/dw_mmc.c:	if (!host->sg_cpu) {
drivers/mmc/host/dw_mmc.c:		dev_err(&host->dev, "%s: could not alloc DMA memory\n",
drivers/mmc/host/dw_mmc.c:	host->dma_ops = &dw_mci_idmac_ops;
drivers/mmc/host/dw_mmc.c:	dev_info(&host->dev, "Using internal DMA controller.\n");
drivers/mmc/host/dw_mmc.c:	if (!host->dma_ops)
drivers/mmc/host/dw_mmc.c:	if (host->dma_ops->init && host->dma_ops->start &&
drivers/mmc/host/dw_mmc.c:	    host->dma_ops->stop && host->dma_ops->cleanup) {
drivers/mmc/host/dw_mmc.c:		if (host->dma_ops->init(host)) {
drivers/mmc/host/dw_mmc.c:			dev_err(&host->dev, "%s: Unable to initialize "
drivers/mmc/host/dw_mmc.c:		dev_err(&host->dev, "DMA initialization not found.\n");
drivers/mmc/host/dw_mmc.c:	host->use_dma = 1;
drivers/mmc/host/dw_mmc.c:	dev_info(&host->dev, "Using PIO mode.\n");
drivers/mmc/host/dw_mmc.c:	host->use_dma = 0;
drivers/mmc/host/dw_mmc.c:	if (!host->pdata || !host->pdata->init) {
drivers/mmc/host/dw_mmc.c:		dev_err(&host->dev,
drivers/mmc/host/dw_mmc.c:	if (!host->pdata->select_slot && host->pdata->num_slots > 1) {
drivers/mmc/host/dw_mmc.c:		dev_err(&host->dev,
drivers/mmc/host/dw_mmc.c:	if (!host->pdata->bus_hz) {
drivers/mmc/host/dw_mmc.c:		dev_err(&host->dev,
drivers/mmc/host/dw_mmc.c:	host->bus_hz = host->pdata->bus_hz;
drivers/mmc/host/dw_mmc.c:	host->quirks = host->pdata->quirks;
drivers/mmc/host/dw_mmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/dw_mmc.c:	INIT_LIST_HEAD(&host->queue);
drivers/mmc/host/dw_mmc.c:	host->dma_ops = host->pdata->dma_ops;
drivers/mmc/host/dw_mmc.c:		host->push_data = dw_mci_push_data16;
drivers/mmc/host/dw_mmc.c:		host->pull_data = dw_mci_pull_data16;
drivers/mmc/host/dw_mmc.c:		host->data_shift = 1;
drivers/mmc/host/dw_mmc.c:		host->push_data = dw_mci_push_data64;
drivers/mmc/host/dw_mmc.c:		host->pull_data = dw_mci_pull_data64;
drivers/mmc/host/dw_mmc.c:		host->data_shift = 3;
drivers/mmc/host/dw_mmc.c:		host->push_data = dw_mci_push_data32;
drivers/mmc/host/dw_mmc.c:		host->pull_data = dw_mci_pull_data32;
drivers/mmc/host/dw_mmc.c:		host->data_shift = 2;
drivers/mmc/host/dw_mmc.c:	if (!mci_wait_reset(&host->dev, host)) {
drivers/mmc/host/dw_mmc.c:	if (!host->pdata->fifo_depth) {
drivers/mmc/host/dw_mmc.c:		fifo_size = host->pdata->fifo_depth;
drivers/mmc/host/dw_mmc.c:	host->fifo_depth = fifo_size;
drivers/mmc/host/dw_mmc.c:	host->fifoth_val = ((0x2 << 28) | ((fifo_size/2 - 1) << 16) |
drivers/mmc/host/dw_mmc.c:	mci_writel(host, FIFOTH, host->fifoth_val);
drivers/mmc/host/dw_mmc.c:	tasklet_init(&host->tasklet, dw_mci_tasklet_func, (unsigned long)host);
drivers/mmc/host/dw_mmc.c:	INIT_WORK(&host->card_work, dw_mci_work_routine_card);
drivers/mmc/host/dw_mmc.c:	ret = request_irq(host->irq, dw_mci_interrupt, host->irq_flags, "dw-mci", host);
drivers/mmc/host/dw_mmc.c:	if (host->pdata->num_slots)
drivers/mmc/host/dw_mmc.c:		host->num_slots = host->pdata->num_slots;
drivers/mmc/host/dw_mmc.c:		host->num_slots = ((mci_readl(host, HCON) >> 1) & 0x1F) + 1;
drivers/mmc/host/dw_mmc.c:	for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:	host->verid = SDMMC_GET_VERID(mci_readl(host, VERID));
drivers/mmc/host/dw_mmc.c:	dev_info(&host->dev, "Version ID is %04x\n", host->verid);
drivers/mmc/host/dw_mmc.c:	if (host->verid < DW_MMC_240A)
drivers/mmc/host/dw_mmc.c:		host->data_offset = DATA_OFFSET;
drivers/mmc/host/dw_mmc.c:		host->data_offset = DATA_240A_OFFSET;
drivers/mmc/host/dw_mmc.c:	dev_info(&host->dev, "DW MMC controller at irq %d, "
drivers/mmc/host/dw_mmc.c:		 host->irq, width, fifo_size);
drivers/mmc/host/dw_mmc.c:	if (host->quirks & DW_MCI_QUIRK_IDMAC_DTO)
drivers/mmc/host/dw_mmc.c:		dev_info(&host->dev, "Internal DMAC interrupt fix enabled.\n");
drivers/mmc/host/dw_mmc.c:		if (host->slot[i])
drivers/mmc/host/dw_mmc.c:			dw_mci_cleanup_slot(host->slot[i], i);
drivers/mmc/host/dw_mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/dw_mmc.c:	if (host->use_dma && host->dma_ops->exit)
drivers/mmc/host/dw_mmc.c:		host->dma_ops->exit(host);
drivers/mmc/host/dw_mmc.c:	dma_free_coherent(&host->dev, PAGE_SIZE,
drivers/mmc/host/dw_mmc.c:			  host->sg_cpu, host->sg_dma);
drivers/mmc/host/dw_mmc.c:	if (host->vmmc) {
drivers/mmc/host/dw_mmc.c:		regulator_disable(host->vmmc);
drivers/mmc/host/dw_mmc.c:		regulator_put(host->vmmc);
drivers/mmc/host/dw_mmc.c:	for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:		dev_dbg(&host->dev, "remove slot %d\n", i);
drivers/mmc/host/dw_mmc.c:		if (host->slot[i])
drivers/mmc/host/dw_mmc.c:			dw_mci_cleanup_slot(host->slot[i], i);
drivers/mmc/host/dw_mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/dw_mmc.c:	dma_free_coherent(&host->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/dw_mmc.c:	if (host->use_dma && host->dma_ops->exit)
drivers/mmc/host/dw_mmc.c:		host->dma_ops->exit(host);
drivers/mmc/host/dw_mmc.c:	if (host->vmmc) {
drivers/mmc/host/dw_mmc.c:		regulator_disable(host->vmmc);
drivers/mmc/host/dw_mmc.c:		regulator_put(host->vmmc);
drivers/mmc/host/dw_mmc.c:	for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:		struct dw_mci_slot *slot = host->slot[i];
drivers/mmc/host/dw_mmc.c:				slot = host->slot[i];
drivers/mmc/host/dw_mmc.c:					mmc_resume_host(host->slot[i]->mmc);
drivers/mmc/host/dw_mmc.c:	if (host->vmmc)
drivers/mmc/host/dw_mmc.c:		regulator_disable(host->vmmc);
drivers/mmc/host/dw_mmc.c:	if (host->vmmc)
drivers/mmc/host/dw_mmc.c:		regulator_enable(host->vmmc);
drivers/mmc/host/dw_mmc.c:	if (host->dma_ops->init)
drivers/mmc/host/dw_mmc.c:		host->dma_ops->init(host);
drivers/mmc/host/dw_mmc.c:	if (!mci_wait_reset(&host->dev, host)) {
drivers/mmc/host/dw_mmc.c:	mci_writel(host, FIFOTH, host->fifoth_val);
drivers/mmc/host/dw_mmc.c:	for (i = 0; i < host->num_slots; i++) {
drivers/mmc/host/dw_mmc.c:		struct dw_mci_slot *slot = host->slot[i];
drivers/mmc/host/dw_mmc.c:		ret = mmc_resume_host(host->slot[i]->mmc);
drivers/mmc/host/imxmmc.c:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	writew(reg & ~STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:			reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:					host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:		reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:			reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:	dev_dbg(mmc_dev(host->mmc), "imxmci_stop_clock blocked, no luck\n");
drivers/mmc/host/imxmmc.c:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	writew(reg & ~STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	clear_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	writew(reg | STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:			reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:				reg = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:			if (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:		if (!test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:			reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:					host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	dev_err(mmc_dev(host->mmc), "imxmci_start_clock blocked, no luck\n");
drivers/mmc/host/imxmmc.c:	writew(0x08, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	writew(0x0D, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:		writew(0x05, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:	writew(0xff, host->base + MMC_REG_RES_TO);
drivers/mmc/host/imxmmc.c:	writew(512, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:	writew(1, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
drivers/mmc/host/imxmmc.c:		*pstat |= readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:	if (!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock >= 8000000))
drivers/mmc/host/imxmmc.c:		dev_info(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",
drivers/mmc/host/imxmmc.c:	host->data = data;
drivers/mmc/host/imxmmc.c:	writew(nob, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:	writew(blksz, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:		host->dma_size = datasz;
drivers/mmc/host/imxmmc.c:			host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/imxmmc.c:			writew(1, host->base + MMC_REG_NOB);
drivers/mmc/host/imxmmc.c:			writew(512, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/imxmmc.c:			host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/imxmmc.c:		host->data_ptr = (u16 *)sg_virt(data->sg);
drivers/mmc/host/imxmmc.c:		host->data_cnt = 0;
drivers/mmc/host/imxmmc.c:		clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		set_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/imxmmc.c:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/imxmmc.c:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/imxmmc.c:		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
drivers/mmc/host/imxmmc.c:				 host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/imxmmc.c:		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_READ, IMX_DMA_WIDTH_16, CCR_REN);*/
drivers/mmc/host/imxmmc.c:		CCR(host->dma) = CCR_DMOD_LINEAR | CCR_DSIZ_32 | CCR_SMOD_FIFO | CCR_SSIZ_16 | CCR_REN;
drivers/mmc/host/imxmmc.c:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/imxmmc.c:		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/imxmmc.c:					     data->sg_len,  host->dma_dir);
drivers/mmc/host/imxmmc.c:		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
drivers/mmc/host/imxmmc.c:				 host->res->start + MMC_REG_BUFFER_ACCESS,
drivers/mmc/host/imxmmc.c:		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_WRITE, IMX_DMA_WIDTH_16, CCR_REN);*/
drivers/mmc/host/imxmmc.c:		CCR(host->dma) = CCR_SMOD_LINEAR | CCR_SSIZ_32 | CCR_DMOD_FIFO | CCR_DSIZ_16 | CCR_REN;
drivers/mmc/host/imxmmc.c:	host->dma_size = 0;
drivers/mmc/host/imxmmc.c:	for (i = 0; i < host->dma_nents; i++)
drivers/mmc/host/imxmmc.c:		host->dma_size += data->sg[i].length;
drivers/mmc/host/imxmmc.c:	if (datasz > host->dma_size) {
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc), "imxmci_setup_data datasz 0x%x > 0x%x dm_size\n",
drivers/mmc/host/imxmmc.c:			datasz, host->dma_size);
drivers/mmc/host/imxmmc.c:	host->dma_size = datasz;
drivers/mmc/host/imxmmc.c:	set_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	clear_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	if (host->dma_dir == DMA_FROM_DEVICE)
drivers/mmc/host/imxmmc.c:		imx_dma_enable(host->dma);
drivers/mmc/host/imxmmc.c:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/imxmmc.c:	host->cmd = cmd;
drivers/mmc/host/imxmmc.c:	if (test_and_clear_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:	if (host->actual_bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/imxmmc.c:	writew(cmd->opcode, host->base + MMC_REG_CMD);
drivers/mmc/host/imxmmc.c:	writew(cmd->arg >> 16, host->base + MMC_REG_ARGH);
drivers/mmc/host/imxmmc.c:	writew(cmd->arg & 0xffff, host->base + MMC_REG_ARGL);
drivers/mmc/host/imxmmc.c:	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
drivers/mmc/host/imxmmc.c:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:	set_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/imxmmc.c:	host->imask = imask;
drivers/mmc/host/imxmmc.c:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/imxmmc.c:	dev_dbg(mmc_dev(host->mmc), "CMD%02d (0x%02x) mask set to 0x%04x\n",
drivers/mmc/host/imxmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/imxmmc.c:	host->pending_events &= ~(IMXMCI_PEND_WAIT_RESP_m | IMXMCI_PEND_DMA_END_m |
drivers/mmc/host/imxmmc.c:	host->imask = IMXMCI_INT_MASK_DEFAULT;
drivers/mmc/host/imxmmc.c:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/imxmmc.c:		host->prev_cmd_code = req->cmd->opcode;
drivers/mmc/host/imxmmc.c:	host->req = NULL;
drivers/mmc/host/imxmmc.c:	host->cmd = NULL;
drivers/mmc/host/imxmmc.c:	host->data = NULL;
drivers/mmc/host/imxmmc.c:	mmc_request_done(host->mmc, req);
drivers/mmc/host/imxmmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:	if (test_and_clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:		imx_dma_disable(host->dma);
drivers/mmc/host/imxmmc.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,
drivers/mmc/host/imxmmc.c:			     host->dma_dir);
drivers/mmc/host/imxmmc.c:		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n", stat);
drivers/mmc/host/imxmmc.c:		data->bytes_xfered = host->dma_size;
drivers/mmc/host/imxmmc.c:	host->data = NULL;
drivers/mmc/host/imxmmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/imxmmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:	host->cmd = NULL;
drivers/mmc/host/imxmmc.c:		dev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");
drivers/mmc/host/imxmmc.c:		dev_dbg(mmc_dev(host->mmc), "cmd crc error\n");
drivers/mmc/host/imxmmc.c:				a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:				b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:			a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:			b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:			c = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/imxmmc.c:	dev_dbg(mmc_dev(host->mmc), "RESP 0x%08x, 0x%08x, 0x%08x, 0x%08x, error %d\n",
drivers/mmc/host/imxmmc.c:		if (host->req->data->flags & MMC_DATA_WRITE) {
drivers/mmc/host/imxmmc.c:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:				if (host->req)
drivers/mmc/host/imxmmc.c:					imxmci_finish_request(host, host->req);
drivers/mmc/host/imxmmc.c:				dev_warn(mmc_dev(host->mmc), "STATUS = 0x%04x\n",
drivers/mmc/host/imxmmc.c:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:				imx_dma_enable(host->dma);
drivers/mmc/host/imxmmc.c:		req = host->req;
drivers/mmc/host/imxmmc.c:			dev_warn(mmc_dev(host->mmc), "imxmci_cmd_done: no request to finish\n");
drivers/mmc/host/imxmmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/imxmmc.c:	if (host->req->stop) {
drivers/mmc/host/imxmmc.c:		imxmci_start_cmd(host, host->req->stop, 0);
drivers/mmc/host/imxmmc.c:		req = host->req;
drivers/mmc/host/imxmmc.c:			dev_warn(mmc_dev(host->mmc), "imxmci_data_done: no request to finish\n");
drivers/mmc/host/imxmmc.c:	if (host->actual_bus_width != MMC_BUS_WIDTH_4)
drivers/mmc/host/imxmmc.c:	dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data running STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:	if (host->dma_dir == DMA_FROM_DEVICE) {
drivers/mmc/host/imxmmc.c:		       (host->data_cnt < 512)) {
drivers/mmc/host/imxmmc.c:				data = readw(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/imxmmc.c:				if (host->data_cnt+2 <= host->dma_size) {
drivers/mmc/host/imxmmc.c:					*(host->data_ptr++) = data;
drivers/mmc/host/imxmmc.c:					if (host->data_cnt < host->dma_size)
drivers/mmc/host/imxmmc.c:						*(u8 *)(host->data_ptr) = data;
drivers/mmc/host/imxmmc.c:				host->data_cnt += 2;
drivers/mmc/host/imxmmc.c:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read %d burst %d STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:				host->data_cnt, burst_len, stat);
drivers/mmc/host/imxmmc.c:		if ((stat & STATUS_DATA_TRANS_DONE) && (host->data_cnt >= 512))
drivers/mmc/host/imxmmc.c:		if (host->dma_size & 0x1ff)
drivers/mmc/host/imxmmc.c:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read timeout STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:		       (host->data_cnt < host->dma_size)) {
drivers/mmc/host/imxmmc.c:			if (burst_len >= host->dma_size - host->data_cnt) {
drivers/mmc/host/imxmmc.c:				burst_len = host->dma_size - host->data_cnt;
drivers/mmc/host/imxmmc.c:				host->data_cnt = host->dma_size;
drivers/mmc/host/imxmmc.c:				host->data_cnt += burst_len;
drivers/mmc/host/imxmmc.c:				writew(*(host->data_ptr++), host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/imxmmc.c:			stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
drivers/mmc/host/imxmmc.c:	u32 stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:	host->status_reg = stat;
drivers/mmc/host/imxmmc.c:	set_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:	u32 stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:	writew(host->imask | INT_MASK_SDIO | INT_MASK_AUTO_CARD_DETECT,
drivers/mmc/host/imxmmc.c:			host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:	atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:	host->status_reg = stat;
drivers/mmc/host/imxmmc.c:	set_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	set_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:	if (atomic_read(&host->stuck_timeout) > 4) {
drivers/mmc/host/imxmmc.c:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:		host->status_reg = stat;
drivers/mmc/host/imxmmc.c:		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:				if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_INT_MASK));
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_CMD_DAT_CONT),
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_BLK_LEN),
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_NOB),
drivers/mmc/host/imxmmc.c:			CCR(host->dma));
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc), "CMD%d, prevCMD%d, bus %d-bit, dma_size = 0x%x\n",
drivers/mmc/host/imxmmc.c:			host->cmd ? host->cmd->opcode : 0,
drivers/mmc/host/imxmmc.c:			host->prev_cmd_code,
drivers/mmc/host/imxmmc.c:			1 << host->actual_bus_width, host->dma_size);
drivers/mmc/host/imxmmc.c:	if (!host->present || timeout)
drivers/mmc/host/imxmmc.c:		host->status_reg = STATUS_TIME_OUT_RESP | STATUS_TIME_OUT_READ |
drivers/mmc/host/imxmmc.c:	if (test_bit(IMXMCI_PEND_IRQ_b, &host->pending_events) || timeout) {
drivers/mmc/host/imxmmc.c:		clear_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:		stat |= host->status_reg;
drivers/mmc/host/imxmmc.c:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:			if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:			if (host->data && (stat & STATUS_ERR_MASK))
drivers/mmc/host/imxmmc.c:		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:			stat |= readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:				if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
drivers/mmc/host/imxmmc.c:						  &host->pending_events);
drivers/mmc/host/imxmmc.c:	if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events) &&
drivers/mmc/host/imxmmc.c:	    !test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:		stat = readw(host->base + MMC_REG_STATUS);
drivers/mmc/host/imxmmc.c:		stat |= host->status_reg;
drivers/mmc/host/imxmmc.c:		if (host->dma_dir == DMA_TO_DEVICE)
drivers/mmc/host/imxmmc.c:			clear_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:	if (test_and_clear_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:		if (host->cmd)
drivers/mmc/host/imxmmc.c:		if (host->data)
drivers/mmc/host/imxmmc.c:		if (host->req)
drivers/mmc/host/imxmmc.c:			imxmci_finish_request(host, host->req);
drivers/mmc/host/imxmmc.c:		mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/imxmmc.c:	WARN_ON(host->req != NULL);
drivers/mmc/host/imxmmc.c:	host->req = req;
drivers/mmc/host/imxmmc.c:		host->actual_bus_width = MMC_BUS_WIDTH_4;
drivers/mmc/host/imxmmc.c:		BLR(host->dma) = 0;	/* burst 64 byte read/write */
drivers/mmc/host/imxmmc.c:		host->actual_bus_width = MMC_BUS_WIDTH_1;
drivers/mmc/host/imxmmc.c:		BLR(host->dma) = 16;	/* burst 16 byte read/write */
drivers/mmc/host/imxmmc.c:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/imxmmc.c:			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		host->power_mode = ios->power_mode;
drivers/mmc/host/imxmmc.c:		clk = clk_get_rate(host->clk);
drivers/mmc/host/imxmmc.c:		dev_dbg(mmc_dev(host->mmc), "PERCLK2 %d MHz -> prescaler %d\n",
drivers/mmc/host/imxmmc.c:		reg = readw(host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:				host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/imxmmc.c:		writew((prescaler << 3) | clk, host->base + MMC_REG_CLK_RATE);
drivers/mmc/host/imxmmc.c:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_CLK_RATE));
drivers/mmc/host/imxmmc.c:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/imxmmc.c:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/imxmmc.c:	if (host->pdata && host->pdata->card_present &&
drivers/mmc/host/imxmmc.c:	    host->pdata->card_present(mmc_dev(host->mmc)) != host->present) {
drivers/mmc/host/imxmmc.c:		host->present ^= 1;
drivers/mmc/host/imxmmc.c:		dev_info(mmc_dev(host->mmc), "card %s\n",
drivers/mmc/host/imxmmc.c:		      host->present ? "inserted" : "removed");
drivers/mmc/host/imxmmc.c:		set_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events);
drivers/mmc/host/imxmmc.c:		tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:	if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events) ||
drivers/mmc/host/imxmmc.c:	    test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
drivers/mmc/host/imxmmc.c:		atomic_inc(&host->stuck_timeout);
drivers/mmc/host/imxmmc.c:		if (atomic_read(&host->stuck_timeout) > 4)
drivers/mmc/host/imxmmc.c:			tasklet_schedule(&host->tasklet);
drivers/mmc/host/imxmmc.c:		atomic_set(&host->stuck_timeout, 0);
drivers/mmc/host/imxmmc.c:	mod_timer(&host->timer, jiffies + (HZ>>1));
drivers/mmc/host/imxmmc.c:	host->base = ioremap(r->start, resource_size(r));
drivers/mmc/host/imxmmc.c:	if (!host->base) {
drivers/mmc/host/imxmmc.c:	host->mmc = mmc;
drivers/mmc/host/imxmmc.c:	host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/imxmmc.c:	if (!host->pdata)
drivers/mmc/host/imxmmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/imxmmc.c:	host->res = r;
drivers/mmc/host/imxmmc.c:	host->irq = irq;
drivers/mmc/host/imxmmc.c:	host->clk = clk_get(&pdev->dev, "perclk2");
drivers/mmc/host/imxmmc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/imxmmc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/imxmmc.c:	clk_enable(host->clk);
drivers/mmc/host/imxmmc.c:	rev_no = readw(host->base + MMC_REG_REV_NO);
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
drivers/mmc/host/imxmmc.c:			readw(host->base + MMC_REG_REV_NO));
drivers/mmc/host/imxmmc.c:	writew(0x2db4, host->base + MMC_REG_READ_TO);
drivers/mmc/host/imxmmc.c:	host->imask = IMXMCI_INT_MASK_DEFAULT;
drivers/mmc/host/imxmmc.c:	writew(host->imask, host->base + MMC_REG_INT_MASK);
drivers/mmc/host/imxmmc.c:	host->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);
drivers/mmc/host/imxmmc.c:	if(host->dma < 0) {
drivers/mmc/host/imxmmc.c:		dev_err(mmc_dev(host->mmc), "imx_dma_request_by_prio failed\n");
drivers/mmc/host/imxmmc.c:	host->dma_allocated = 1;
drivers/mmc/host/imxmmc.c:	imx_dma_setup_handlers(host->dma, imxmci_dma_irq, NULL, host);
drivers/mmc/host/imxmmc.c:	RSSR(host->dma) = DMA_REQ_SDHC;
drivers/mmc/host/imxmmc.c:	tasklet_init(&host->tasklet, imxmci_tasklet_fnc, (unsigned long)host);
drivers/mmc/host/imxmmc.c:	host->status_reg=0;
drivers/mmc/host/imxmmc.c:	host->pending_events=0;
drivers/mmc/host/imxmmc.c:	ret = request_irq(host->irq, imxmci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/imxmmc.c:	if (host->pdata && host->pdata->card_present)
drivers/mmc/host/imxmmc.c:		host->present = host->pdata->card_present(mmc_dev(mmc));
drivers/mmc/host/imxmmc.c:		host->present = 1;
drivers/mmc/host/imxmmc.c:	init_timer(&host->timer);
drivers/mmc/host/imxmmc.c:	host->timer.data = (unsigned long)host;
drivers/mmc/host/imxmmc.c:	host->timer.function = imxmci_check_status;
drivers/mmc/host/imxmmc.c:	add_timer(&host->timer);
drivers/mmc/host/imxmmc.c:	mod_timer(&host->timer, jiffies + (HZ >> 1));
drivers/mmc/host/imxmmc.c:		if (host->dma_allocated) {
drivers/mmc/host/imxmmc.c:			imx_dma_free(host->dma);
drivers/mmc/host/imxmmc.c:			host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:		if (host->clk) {
drivers/mmc/host/imxmmc.c:			clk_disable(host->clk);
drivers/mmc/host/imxmmc.c:			clk_put(host->clk);
drivers/mmc/host/imxmmc.c:		if (host->base)
drivers/mmc/host/imxmmc.c:			iounmap(host->base);
drivers/mmc/host/imxmmc.c:		tasklet_disable(&host->tasklet);
drivers/mmc/host/imxmmc.c:		del_timer_sync(&host->timer);
drivers/mmc/host/imxmmc.c:		free_irq(host->irq, host);
drivers/mmc/host/imxmmc.c:		iounmap(host->base);
drivers/mmc/host/imxmmc.c:		if (host->dma_allocated) {
drivers/mmc/host/imxmmc.c:			imx_dma_free(host->dma);
drivers/mmc/host/imxmmc.c:			host->dma_allocated = 0;
drivers/mmc/host/imxmmc.c:		tasklet_kill(&host->tasklet);
drivers/mmc/host/imxmmc.c:		clk_disable(host->clk);
drivers/mmc/host/imxmmc.c:		clk_put(host->clk);
drivers/mmc/host/imxmmc.c:		release_mem_region(host->res->start, resource_size(host->res));
drivers/mmc/host/imxmmc.c:			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
drivers/mmc/host/jz4740_mmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/jz4740_mmc.c:		host->irq_mask &= ~irq;
drivers/mmc/host/jz4740_mmc.c:		host->irq_mask |= irq;
drivers/mmc/host/jz4740_mmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/jz4740_mmc.c:	writew(host->irq_mask, host->base + JZ_REG_MMC_IMASK);
drivers/mmc/host/jz4740_mmc.c:	writew(val, host->base + JZ_REG_MMC_STRPCL);
drivers/mmc/host/jz4740_mmc.c:	writew(JZ_MMC_STRPCL_CLOCK_STOP, host->base + JZ_REG_MMC_STRPCL);
drivers/mmc/host/jz4740_mmc.c:		status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:	writew(JZ_MMC_STRPCL_RESET, host->base + JZ_REG_MMC_STRPCL);
drivers/mmc/host/jz4740_mmc.c:		status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:	req = host->req;
drivers/mmc/host/jz4740_mmc.c:	host->req = NULL;
drivers/mmc/host/jz4740_mmc.c:	mmc_request_done(host->mmc, req);
drivers/mmc/host/jz4740_mmc.c:		status = readw(host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:		set_bit(0, &host->waiting);
drivers/mmc/host/jz4740_mmc.c:		mod_timer(&host->timeout_timer, jiffies + 5*HZ);
drivers/mmc/host/jz4740_mmc.c:	status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:			host->req->cmd->error = -ETIMEDOUT;
drivers/mmc/host/jz4740_mmc.c:			host->req->cmd->error = -EIO;
drivers/mmc/host/jz4740_mmc.c:	struct sg_mapping_iter *miter = &host->miter;
drivers/mmc/host/jz4740_mmc.c:	void __iomem *fifo_addr = host->base + JZ_REG_MMC_TXFIFO;
drivers/mmc/host/jz4740_mmc.c:	struct sg_mapping_iter *miter = &host->miter;
drivers/mmc/host/jz4740_mmc.c:	void __iomem *fifo_addr = host->base + JZ_REG_MMC_RXFIFO;
drivers/mmc/host/jz4740_mmc.c:	status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:		status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:	if (!test_and_clear_bit(0, &host->waiting))
drivers/mmc/host/jz4740_mmc.c:	host->req->cmd->error = -ETIMEDOUT;
drivers/mmc/host/jz4740_mmc.c:	void __iomem *fifo_addr = host->base + JZ_REG_MMC_RESP_FIFO;
drivers/mmc/host/jz4740_mmc.c:	uint32_t cmdat = host->cmdat;
drivers/mmc/host/jz4740_mmc.c:	host->cmdat &= ~JZ_MMC_CMDAT_INIT;
drivers/mmc/host/jz4740_mmc.c:	host->cmd = cmd;
drivers/mmc/host/jz4740_mmc.c:		writew(cmd->data->blksz, host->base + JZ_REG_MMC_BLKLEN);
drivers/mmc/host/jz4740_mmc.c:		writew(cmd->data->blocks, host->base + JZ_REG_MMC_NOB);
drivers/mmc/host/jz4740_mmc.c:	writeb(cmd->opcode, host->base + JZ_REG_MMC_CMD);
drivers/mmc/host/jz4740_mmc.c:	writel(cmd->arg, host->base + JZ_REG_MMC_ARG);
drivers/mmc/host/jz4740_mmc.c:	writel(cmdat, host->base + JZ_REG_MMC_CMDAT);
drivers/mmc/host/jz4740_mmc.c:	struct mmc_command *cmd = host->req->cmd;
drivers/mmc/host/jz4740_mmc.c:	sg_miter_start(&host->miter, data->sg, data->sg_len, direction);
drivers/mmc/host/jz4740_mmc.c:	struct mmc_command *cmd = host->req->cmd;
drivers/mmc/host/jz4740_mmc.c:	struct mmc_request *req = host->req;
drivers/mmc/host/jz4740_mmc.c:		host->state = JZ4740_MMC_STATE_DONE;
drivers/mmc/host/jz4740_mmc.c:	switch (host->state) {
drivers/mmc/host/jz4740_mmc.c:			host->state = JZ4740_MMC_STATE_TRANSFER_DATA;
drivers/mmc/host/jz4740_mmc.c:			host->state = JZ4740_MMC_STATE_SEND_STOP;
drivers/mmc/host/jz4740_mmc.c:		writew(JZ_MMC_IRQ_DATA_TRAN_DONE, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:			host->state = JZ4740_MMC_STATE_DONE;
drivers/mmc/host/jz4740_mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/jz4740_mmc.c:	irq_reg = readw(host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:	irq_reg &= ~host->irq_mask;
drivers/mmc/host/jz4740_mmc.c:		writew(tmp & ~irq_reg, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:		writew(JZ_MMC_IRQ_SDIO, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/jz4740_mmc.c:	if (host->req && cmd && irq_reg) {
drivers/mmc/host/jz4740_mmc.c:		if (test_and_clear_bit(0, &host->waiting)) {
drivers/mmc/host/jz4740_mmc.c:			del_timer(&host->timeout_timer);
drivers/mmc/host/jz4740_mmc.c:			status = readl(host->base + JZ_REG_MMC_STATUS);
drivers/mmc/host/jz4740_mmc.c:			writew(irq_reg, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:	clk_set_rate(host->clk, JZ_MMC_CLK_RATE);
drivers/mmc/host/jz4740_mmc.c:	real_rate = clk_get_rate(host->clk);
drivers/mmc/host/jz4740_mmc.c:	writew(div, host->base + JZ_REG_MMC_CLKRT);
drivers/mmc/host/jz4740_mmc.c:	host->req = req;
drivers/mmc/host/jz4740_mmc.c:	writew(0xffff, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:	writew(JZ_MMC_IRQ_END_CMD_RES, host->base + JZ_REG_MMC_IREG);
drivers/mmc/host/jz4740_mmc.c:	host->state = JZ4740_MMC_STATE_READ_RESPONSE;
drivers/mmc/host/jz4740_mmc.c:	set_bit(0, &host->waiting);
drivers/mmc/host/jz4740_mmc.c:	mod_timer(&host->timeout_timer, jiffies + 5*HZ);
drivers/mmc/host/jz4740_mmc.c:		if (gpio_is_valid(host->pdata->gpio_power))
drivers/mmc/host/jz4740_mmc.c:			gpio_set_value(host->pdata->gpio_power,
drivers/mmc/host/jz4740_mmc.c:					!host->pdata->power_active_low);
drivers/mmc/host/jz4740_mmc.c:		host->cmdat |= JZ_MMC_CMDAT_INIT;
drivers/mmc/host/jz4740_mmc.c:		clk_enable(host->clk);
drivers/mmc/host/jz4740_mmc.c:		if (gpio_is_valid(host->pdata->gpio_power))
drivers/mmc/host/jz4740_mmc.c:			gpio_set_value(host->pdata->gpio_power,
drivers/mmc/host/jz4740_mmc.c:					host->pdata->power_active_low);
drivers/mmc/host/jz4740_mmc.c:		clk_disable(host->clk);
drivers/mmc/host/jz4740_mmc.c:		host->cmdat &= ~JZ_MMC_CMDAT_BUS_WIDTH_4BIT;
drivers/mmc/host/jz4740_mmc.c:		host->cmdat |= JZ_MMC_CMDAT_BUS_WIDTH_4BIT;
drivers/mmc/host/jz4740_mmc.c:	if (!gpio_is_valid(host->pdata->gpio_read_only))
drivers/mmc/host/jz4740_mmc.c:	return gpio_get_value(host->pdata->gpio_read_only) ^
drivers/mmc/host/jz4740_mmc.c:		host->pdata->read_only_active_low;
drivers/mmc/host/jz4740_mmc.c:	if (!gpio_is_valid(host->pdata->gpio_card_detect))
drivers/mmc/host/jz4740_mmc.c:	return gpio_get_value(host->pdata->gpio_card_detect) ^
drivers/mmc/host/jz4740_mmc.c:			host->pdata->card_detect_active_low;
drivers/mmc/host/jz4740_mmc.c:	mmc_detect_change(host->mmc, HZ / 2);
drivers/mmc/host/jz4740_mmc.c:	host->card_detect_irq = gpio_to_irq(pdata->gpio_card_detect);
drivers/mmc/host/jz4740_mmc.c:	if (host->card_detect_irq < 0) {
drivers/mmc/host/jz4740_mmc.c:	return request_irq(host->card_detect_irq, jz4740_mmc_card_detect_irq,
drivers/mmc/host/jz4740_mmc.c:	if (host->pdata && host->pdata->data_1bit)
drivers/mmc/host/jz4740_mmc.c:	host->pdata = pdata;
drivers/mmc/host/jz4740_mmc.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/jz4740_mmc.c:	if (host->irq < 0) {
drivers/mmc/host/jz4740_mmc.c:		ret = host->irq;
drivers/mmc/host/jz4740_mmc.c:	host->clk = clk_get(&pdev->dev, "mmc");
drivers/mmc/host/jz4740_mmc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/jz4740_mmc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/jz4740_mmc.c:	host->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/jz4740_mmc.c:	if (!host->mem) {
drivers/mmc/host/jz4740_mmc.c:	host->mem = request_mem_region(host->mem->start,
drivers/mmc/host/jz4740_mmc.c:					resource_size(host->mem), pdev->name);
drivers/mmc/host/jz4740_mmc.c:	if (!host->mem) {
drivers/mmc/host/jz4740_mmc.c:	host->base = ioremap_nocache(host->mem->start, resource_size(host->mem));
drivers/mmc/host/jz4740_mmc.c:	if (!host->base) {
drivers/mmc/host/jz4740_mmc.c:	host->mmc = mmc;
drivers/mmc/host/jz4740_mmc.c:	host->pdev = pdev;
drivers/mmc/host/jz4740_mmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/jz4740_mmc.c:	host->irq_mask = 0xffff;
drivers/mmc/host/jz4740_mmc.c:	ret = request_threaded_irq(host->irq, jz_mmc_irq, jz_mmc_irq_worker, 0,
drivers/mmc/host/jz4740_mmc.c:	setup_timer(&host->timeout_timer, jz4740_mmc_timeout,
drivers/mmc/host/jz4740_mmc.c:	set_timer_slack(&host->timeout_timer, HZ);
drivers/mmc/host/jz4740_mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/jz4740_mmc.c:	if (host->card_detect_irq >= 0)
drivers/mmc/host/jz4740_mmc.c:		free_irq(host->card_detect_irq, host);
drivers/mmc/host/jz4740_mmc.c:	iounmap(host->base);
drivers/mmc/host/jz4740_mmc.c:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/jz4740_mmc.c:	clk_put(host->clk);
drivers/mmc/host/jz4740_mmc.c:	del_timer_sync(&host->timeout_timer);
drivers/mmc/host/jz4740_mmc.c:	mmc_remove_host(host->mmc);
drivers/mmc/host/jz4740_mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/jz4740_mmc.c:	if (host->card_detect_irq >= 0)
drivers/mmc/host/jz4740_mmc.c:		free_irq(host->card_detect_irq, host);
drivers/mmc/host/jz4740_mmc.c:	iounmap(host->base);
drivers/mmc/host/jz4740_mmc.c:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/jz4740_mmc.c:	clk_put(host->clk);
drivers/mmc/host/jz4740_mmc.c:	mmc_free_host(host->mmc);
drivers/mmc/host/jz4740_mmc.c:	mmc_suspend_host(host->mmc);
drivers/mmc/host/jz4740_mmc.c:	mmc_resume_host(host->mmc);
drivers/mmc/host/mmc_spi.c:	return spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:	if (len > sizeof(*host->data)) {
drivers/mmc/host/mmc_spi.c:	host->status.len = len;
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:	status = spi_sync_locked(host->spi, &host->readback);
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:	u8		*cp = host->data->status;
drivers/mmc/host/mmc_spi.c:	return mmc_spi_skip(host, timeout, sizeof(host->data->status), 0);
drivers/mmc/host/mmc_spi.c:	u8	*cp = host->data->status;
drivers/mmc/host/mmc_spi.c:	u8	*end = cp + host->t.len;
drivers/mmc/host/mmc_spi.c:		cp = host->data->status;
drivers/mmc/host/mmc_spi.c:			cp = host->data->status;
drivers/mmc/host/mmc_spi.c:			cp = host->data->status;
drivers/mmc/host/mmc_spi.c:				cp = host->data->status;
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "bad response type %04x\n",
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "%s: resp %04x %08x\n",
drivers/mmc/host/mmc_spi.c:	struct scratch		*data = host->data;
drivers/mmc/host/mmc_spi.c:	dev_dbg(&host->spi->dev, "  mmc_spi: CMD%d, resp %s\n",
drivers/mmc/host/mmc_spi.c:	spi_message_init(&host->m);
drivers/mmc/host/mmc_spi.c:	t = &host->t;
drivers/mmc/host/mmc_spi.c:	t->tx_dma = t->rx_dma = host->data_dma;
drivers/mmc/host/mmc_spi.c:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:		host->m.is_dma_mapped = 1;
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:	status = spi_sync_locked(host->spi, &host->m);
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "  ... write returned %d\n", status);
drivers/mmc/host/mmc_spi.c:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:	dma_addr_t		dma = host->data_dma;
drivers/mmc/host/mmc_spi.c:	spi_message_init(&host->m);
drivers/mmc/host/mmc_spi.c:		host->m.is_dma_mapped = 1;
drivers/mmc/host/mmc_spi.c:		t = &host->token;
drivers/mmc/host/mmc_spi.c:		spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:	t = &host->t;
drivers/mmc/host/mmc_spi.c:	t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:	t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:	t = &host->crc;
drivers/mmc/host/mmc_spi.c:		t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:		t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:	spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:		t = &host->early_status;
drivers/mmc/host/mmc_spi.c:		t->tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:		t->tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:		spi_message_add_tail(t, &host->m);
drivers/mmc/host/mmc_spi.c:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:	if (host->mmc->use_spi_crc)
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:	status = spi_sync_locked(spi, &host->m);
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:	struct scratch		*scratch = host->data;
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:	status = spi_sync_locked(spi, &host->m);
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:	if (host->mmc->use_spi_crc) {
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:	struct spi_device	*spi = host->spi;
drivers/mmc/host/mmc_spi.c:	struct device		*dma_dev = host->dma_dev;
drivers/mmc/host/mmc_spi.c:	t = &host->t;
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:		struct scratch	*scratch = host->data;
drivers/mmc/host/mmc_spi.c:		INIT_LIST_HEAD(&host->m.transfers);
drivers/mmc/host/mmc_spi.c:		list_add(&host->early_status.transfer_list,
drivers/mmc/host/mmc_spi.c:				&host->m.transfers);
drivers/mmc/host/mmc_spi.c:		host->early_status.tx_buf = host->early_status.rx_buf;
drivers/mmc/host/mmc_spi.c:		host->early_status.tx_dma = host->early_status.rx_dma;
drivers/mmc/host/mmc_spi.c:		host->early_status.len = statlen;
drivers/mmc/host/mmc_spi.c:		if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:			dma_sync_single_for_device(host->dma_dev,
drivers/mmc/host/mmc_spi.c:					host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:		tmp = spi_sync_locked(spi, &host->m);
drivers/mmc/host/mmc_spi.c:		if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:			dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:					host->data_dma, sizeof(*scratch),
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev, "bogus command\n");
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev, "bogus STOP command\n");
drivers/mmc/host/mmc_spi.c:			mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmc_spi.c:	spi_bus_lock(host->spi->master);
drivers/mmc/host/mmc_spi.c:	spi_bus_unlock(host->spi->master);
drivers/mmc/host/mmc_spi.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmc_spi.c:	host->spi->mode |= SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:	if (spi_setup(host->spi) != 0) {
drivers/mmc/host/mmc_spi.c:		dev_warn(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:		if (spi_setup(host->spi) != 0) {
drivers/mmc/host/mmc_spi.c:			dev_err(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/mmc_spi.c:		canpower = host->pdata && host->pdata->setpower;
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "mmc_spi: power %s (%d)%s\n",
drivers/mmc/host/mmc_spi.c:				host->pdata->setpower(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:					msleep(host->powerup_msecs);
drivers/mmc/host/mmc_spi.c:			host->spi->mode &= ~(SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:			mres = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:			if (spi_write(host->spi, &nullbyte, 1) < 0)
drivers/mmc/host/mmc_spi.c:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:				host->spi->mode |= (SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:				mres = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:					dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:		host->power_mode = ios->power_mode;
drivers/mmc/host/mmc_spi.c:	if (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {
drivers/mmc/host/mmc_spi.c:		host->spi->max_speed_hz = ios->clock;
drivers/mmc/host/mmc_spi.c:		status = spi_setup(host->spi);
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:			host->spi->max_speed_hz, status);
drivers/mmc/host/mmc_spi.c:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/mmc_spi.c:		return !!host->pdata->get_ro(mmc->parent);
drivers/mmc/host/mmc_spi.c:	if (host->pdata && host->pdata->get_cd)
drivers/mmc/host/mmc_spi.c:		return !!host->pdata->get_cd(mmc->parent);
drivers/mmc/host/mmc_spi.c:	u16 delay_msec = max(host->pdata->detect_delay, (u16)100);
drivers/mmc/host/mmc_spi.c:	host->mmc = mmc;
drivers/mmc/host/mmc_spi.c:	host->spi = spi;
drivers/mmc/host/mmc_spi.c:	host->ones = ones;
drivers/mmc/host/mmc_spi.c:	host->pdata = mmc_spi_get_pdata(spi);
drivers/mmc/host/mmc_spi.c:	if (host->pdata)
drivers/mmc/host/mmc_spi.c:		mmc->ocr_avail = host->pdata->ocr_mask;
drivers/mmc/host/mmc_spi.c:	if (host->pdata && host->pdata->setpower) {
drivers/mmc/host/mmc_spi.c:		host->powerup_msecs = host->pdata->powerup_msecs;
drivers/mmc/host/mmc_spi.c:		if (!host->powerup_msecs || host->powerup_msecs > 250)
drivers/mmc/host/mmc_spi.c:			host->powerup_msecs = 250;
drivers/mmc/host/mmc_spi.c:	host->data = kmalloc(sizeof(*host->data), GFP_KERNEL);
drivers/mmc/host/mmc_spi.c:	if (!host->data)
drivers/mmc/host/mmc_spi.c:		host->dma_dev = dev;
drivers/mmc/host/mmc_spi.c:		host->ones_dma = dma_map_single(dev, ones,
drivers/mmc/host/mmc_spi.c:		host->data_dma = dma_map_single(dev, host->data,
drivers/mmc/host/mmc_spi.c:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:		dma_sync_single_for_cpu(host->dma_dev,
drivers/mmc/host/mmc_spi.c:				host->data_dma, sizeof(*host->data),
drivers/mmc/host/mmc_spi.c:	spi_message_init(&host->readback);
drivers/mmc/host/mmc_spi.c:	host->readback.is_dma_mapped = (host->dma_dev != NULL);
drivers/mmc/host/mmc_spi.c:	spi_message_add_tail(&host->status, &host->readback);
drivers/mmc/host/mmc_spi.c:	host->status.tx_buf = host->ones;
drivers/mmc/host/mmc_spi.c:	host->status.tx_dma = host->ones_dma;
drivers/mmc/host/mmc_spi.c:	host->status.rx_buf = &host->data->status;
drivers/mmc/host/mmc_spi.c:	host->status.rx_dma = host->data_dma + offsetof(struct scratch, status);
drivers/mmc/host/mmc_spi.c:	host->status.cs_change = 1;
drivers/mmc/host/mmc_spi.c:	if (host->pdata && host->pdata->init) {
drivers/mmc/host/mmc_spi.c:		status = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);
drivers/mmc/host/mmc_spi.c:	if (host->pdata)
drivers/mmc/host/mmc_spi.c:		mmc->caps |= host->pdata->caps;
drivers/mmc/host/mmc_spi.c:			host->dma_dev ? "" : ", no DMA",
drivers/mmc/host/mmc_spi.c:			(host->pdata && host->pdata->get_ro)
drivers/mmc/host/mmc_spi.c:			(host->pdata && host->pdata->setpower)
drivers/mmc/host/mmc_spi.c:	if (host->dma_dev)
drivers/mmc/host/mmc_spi.c:		dma_unmap_single(host->dma_dev, host->data_dma,
drivers/mmc/host/mmc_spi.c:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:	kfree(host->data);
drivers/mmc/host/mmc_spi.c:		if (host->pdata && host->pdata->exit)
drivers/mmc/host/mmc_spi.c:			host->pdata->exit(&spi->dev, mmc);
drivers/mmc/host/mmc_spi.c:		if (host->dma_dev) {
drivers/mmc/host/mmc_spi.c:			dma_unmap_single(host->dma_dev, host->ones_dma,
drivers/mmc/host/mmc_spi.c:			dma_unmap_single(host->dma_dev, host->data_dma,
drivers/mmc/host/mmc_spi.c:				sizeof(*host->data), DMA_BIDIRECTIONAL);
drivers/mmc/host/mmc_spi.c:		kfree(host->data);
drivers/mmc/host/mmc_spi.c:		kfree(host->ones);
drivers/mmc/host/mmci.c: * This must be called with host->lock held
drivers/mmc/host/mmci.c:	if (host->clk_reg != clk) {
drivers/mmc/host/mmci.c:		host->clk_reg = clk;
drivers/mmc/host/mmci.c:		writel(clk, host->base + MMCICLOCK);
drivers/mmc/host/mmci.c: * This must be called with host->lock held
drivers/mmc/host/mmci.c:	if (host->pwr_reg != pwr) {
drivers/mmc/host/mmci.c:		host->pwr_reg = pwr;
drivers/mmc/host/mmci.c:		writel(pwr, host->base + MMCIPOWER);
drivers/mmc/host/mmci.c: * This must be called with host->lock held
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:		if (desired >= host->mclk) {
drivers/mmc/host/mmci.c:			host->cclk = host->mclk;
drivers/mmc/host/mmci.c:			clk = DIV_ROUND_UP(host->mclk, desired) - 2;
drivers/mmc/host/mmci.c:			host->cclk = host->mclk / (clk + 2);
drivers/mmc/host/mmci.c:			clk = host->mclk / (2 * desired) - 1;
drivers/mmc/host/mmci.c:			host->cclk = host->mclk / (2 * (clk + 1));
drivers/mmc/host/mmci.c:	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/mmci.c:	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_8)
drivers/mmc/host/mmci.c:	writel(0, host->base + MMCICOMMAND);
drivers/mmc/host/mmci.c:	BUG_ON(host->data);
drivers/mmc/host/mmci.c:	host->mrq = NULL;
drivers/mmc/host/mmci.c:	host->cmd = NULL;
drivers/mmc/host/mmci.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mmci.c:	pm_runtime_mark_last_busy(mmc_dev(host->mmc));
drivers/mmc/host/mmci.c:	pm_runtime_put_autosuspend(mmc_dev(host->mmc));
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:	if (host->singleirq) {
drivers/mmc/host/mmci.c:	writel(0, host->base + MMCIDATACTRL);
drivers/mmc/host/mmci.c:	host->data = NULL;
drivers/mmc/host/mmci.c:	sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
drivers/mmc/host/mmci.c:	struct mmci_platform_data *plat = host->plat;
drivers/mmc/host/mmci.c:		dev_info(mmc_dev(host->mmc), "no DMA platform data\n");
drivers/mmc/host/mmci.c:	host->next_data.cookie = 1;
drivers/mmc/host/mmci.c:		host->dma_rx_channel = dma_request_channel(mask,
drivers/mmc/host/mmci.c:		if (!host->dma_rx_channel)
drivers/mmc/host/mmci.c:			dev_err(mmc_dev(host->mmc), "no RX DMA channel\n");
drivers/mmc/host/mmci.c:		host->dma_tx_channel = dma_request_channel(mask,
drivers/mmc/host/mmci.c:		if (!host->dma_tx_channel)
drivers/mmc/host/mmci.c:			dev_warn(mmc_dev(host->mmc), "no TX DMA channel\n");
drivers/mmc/host/mmci.c:		host->dma_tx_channel = host->dma_rx_channel;
drivers/mmc/host/mmci.c:	if (host->dma_rx_channel)
drivers/mmc/host/mmci.c:		rxname = dma_chan_name(host->dma_rx_channel);
drivers/mmc/host/mmci.c:	if (host->dma_tx_channel)
drivers/mmc/host/mmci.c:		txname = dma_chan_name(host->dma_tx_channel);
drivers/mmc/host/mmci.c:	dev_info(mmc_dev(host->mmc), "DMA channels RX %s, TX %s\n",
drivers/mmc/host/mmci.c:	if (host->dma_tx_channel) {
drivers/mmc/host/mmci.c:		struct device *dev = host->dma_tx_channel->device->dev;
drivers/mmc/host/mmci.c:		if (max_seg_size < host->mmc->max_seg_size)
drivers/mmc/host/mmci.c:			host->mmc->max_seg_size = max_seg_size;
drivers/mmc/host/mmci.c:	if (host->dma_rx_channel) {
drivers/mmc/host/mmci.c:		struct device *dev = host->dma_rx_channel->device->dev;
drivers/mmc/host/mmci.c:		if (max_seg_size < host->mmc->max_seg_size)
drivers/mmc/host/mmci.c:			host->mmc->max_seg_size = max_seg_size;
drivers/mmc/host/mmci.c:	struct mmci_platform_data *plat = host->plat;
drivers/mmc/host/mmci.c:	if (host->dma_rx_channel)
drivers/mmc/host/mmci.c:		dma_release_channel(host->dma_rx_channel);
drivers/mmc/host/mmci.c:	if (host->dma_tx_channel && plat->dma_tx_param)
drivers/mmc/host/mmci.c:		dma_release_channel(host->dma_tx_channel);
drivers/mmc/host/mmci.c:	host->dma_rx_channel = host->dma_tx_channel = NULL;
drivers/mmc/host/mmci.c:	struct dma_chan *chan = host->dma_current;
drivers/mmc/host/mmci.c:		status = readl(host->base + MMCISTATUS);
drivers/mmc/host/mmci.c:		dev_err(mmc_dev(host->mmc), "buggy DMA detected. Taking evasive action.\n");
drivers/mmc/host/mmci.c:	dev_err(mmc_dev(host->mmc), "error during DMA transfer!\n");
drivers/mmc/host/mmci.c:	dmaengine_terminate_all(host->dma_current);
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:		.src_addr = host->phybase + MMCIFIFO,
drivers/mmc/host/mmci.c:		.dst_addr = host->phybase + MMCIFIFO,
drivers/mmc/host/mmci.c:	    host->dma_current && host->dma_desc_current)
drivers/mmc/host/mmci.c:		host->dma_current = NULL;
drivers/mmc/host/mmci.c:		host->dma_desc_current = NULL;
drivers/mmc/host/mmci.c:		chan = host->dma_rx_channel;
drivers/mmc/host/mmci.c:		chan = host->dma_tx_channel;
drivers/mmc/host/mmci.c:		host->dma_current = chan;
drivers/mmc/host/mmci.c:		host->dma_desc_current = desc;
drivers/mmc/host/mmci.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mmci.c:	ret = mmci_dma_prep_data(host, host->data, NULL);
drivers/mmc/host/mmci.c:	dev_vdbg(mmc_dev(host->mmc),
drivers/mmc/host/mmci.c:	dmaengine_submit(host->dma_desc_current);
drivers/mmc/host/mmci.c:	dma_async_issue_pending(host->dma_current);
drivers/mmc/host/mmci.c:	writel(datactrl, host->base + MMCIDATACTRL);
drivers/mmc/host/mmci.c:	writel(readl(host->base + MMCIMASK0) | MCI_DATAENDMASK,
drivers/mmc/host/mmci.c:	       host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:	struct mmci_host_next *next = &host->next_data;
drivers/mmc/host/mmci.c:		       " host->next_data.cookie %d\n",
drivers/mmc/host/mmci.c:		       __func__, data->host_cookie, host->next_data.cookie);
drivers/mmc/host/mmci.c:	host->dma_desc_current = next->dma_desc;
drivers/mmc/host/mmci.c:	host->dma_current = next->dma_chan;
drivers/mmc/host/mmci.c:	struct mmci_host_next *nd = &host->next_data;
drivers/mmc/host/mmci.c:	if (((data->flags & MMC_DATA_WRITE) && host->dma_tx_channel) ||
drivers/mmc/host/mmci.c:	    ((data->flags & MMC_DATA_READ) && host->dma_rx_channel)) {
drivers/mmc/host/mmci.c:		chan = host->dma_rx_channel;
drivers/mmc/host/mmci.c:		chan = host->dma_tx_channel;
drivers/mmc/host/mmci.c:			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:	dev_dbg(mmc_dev(host->mmc), "blksz %04x blks %04x flags %08x\n",
drivers/mmc/host/mmci.c:	host->data = data;
drivers/mmc/host/mmci.c:	host->size = data->blksz * data->blocks;
drivers/mmc/host/mmci.c:	clks = (unsigned long long)data->timeout_ns * host->cclk;
drivers/mmc/host/mmci.c:	base = host->base;
drivers/mmc/host/mmci.c:	writel(host->size, base + MMCIDATALENGTH);
drivers/mmc/host/mmci.c:	if (variant->sdio && host->mmc->card)
drivers/mmc/host/mmci.c:		if (mmc_card_sdio(host->mmc->card))
drivers/mmc/host/mmci.c:		if (host->size < variant->fifohalfsize)
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:	dev_dbg(mmc_dev(host->mmc), "op %02x arg %08x flags %08x\n",
drivers/mmc/host/mmci.c:	host->cmd = cmd;
drivers/mmc/host/mmci.c:		remain = readl(host->base + MMCIDATACNT);
drivers/mmc/host/mmci.c:		dev_dbg(mmc_dev(host->mmc), "MCI ERROR IRQ, status 0x%08x at 0x%08x\n",
drivers/mmc/host/mmci.c:			if (success > host->variant->fifosize)
drivers/mmc/host/mmci.c:				success -= host->variant->fifosize;
drivers/mmc/host/mmci.c:		dev_err(mmc_dev(host->mmc), "stray MCI_DATABLOCKEND interrupt\n");
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:	host->cmd = NULL;
drivers/mmc/host/mmci.c:		if (host->data) {
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:	int host_remain = host->size;
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:		    mmc_card_sdio(host->mmc->card)) {
drivers/mmc/host/mmci.c:				clk = host->clk_reg & ~variant->clkreg_enable;
drivers/mmc/host/mmci.c:				clk = host->clk_reg | variant->clkreg_enable;
drivers/mmc/host/mmci.c:	struct sg_mapping_iter *sg_miter = &host->sg_miter;
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:	void __iomem *base = host->base;
drivers/mmc/host/mmci.c:	dev_dbg(mmc_dev(host->mmc), "irq1 (pio) %08x\n", status);
drivers/mmc/host/mmci.c:		host->size -= len;
drivers/mmc/host/mmci.c:	if (status & MCI_RXACTIVE && host->size < variant->fifohalfsize)
drivers/mmc/host/mmci.c:	if (host->size == 0) {
drivers/mmc/host/mmci.c:	spin_lock(&host->lock);
drivers/mmc/host/mmci.c:		status = readl(host->base + MMCISTATUS);
drivers/mmc/host/mmci.c:		if (host->singleirq) {
drivers/mmc/host/mmci.c:			if (status & readl(host->base + MMCIMASK1))
drivers/mmc/host/mmci.c:		status &= readl(host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:		writel(status, host->base + MMCICLEAR);
drivers/mmc/host/mmci.c:		dev_dbg(mmc_dev(host->mmc), "irq0 (data+cmd) %08x\n", status);
drivers/mmc/host/mmci.c:		data = host->data;
drivers/mmc/host/mmci.c:		cmd = host->cmd;
drivers/mmc/host/mmci.c:	spin_unlock(&host->lock);
drivers/mmc/host/mmci.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/mmci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mmci.c:	host->mrq = mrq;
drivers/mmc/host/mmci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mmci.c:	struct variant_data *variant = host->variant;
drivers/mmc/host/mmci.c:	if (host->plat->ios_handler &&
drivers/mmc/host/mmci.c:		host->plat->ios_handler(mmc_dev(mmc), ios))
drivers/mmc/host/mmci.c:		if (host->vcc)
drivers/mmc/host/mmci.c:			ret = mmc_regulator_set_ocr(mmc, host->vcc, 0);
drivers/mmc/host/mmci.c:		if (host->vcc) {
drivers/mmc/host/mmci.c:			ret = mmc_regulator_set_ocr(mmc, host->vcc, ios->vdd);
drivers/mmc/host/mmci.c:		pwr |= host->plat->sigdir;
drivers/mmc/host/mmci.c:		if (host->hw_designer != AMBA_VENDOR_ST)
drivers/mmc/host/mmci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mmci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mmci.c:	if (host->gpio_wp == -ENOSYS)
drivers/mmc/host/mmci.c:	return gpio_get_value_cansleep(host->gpio_wp);
drivers/mmc/host/mmci.c:	struct mmci_platform_data *plat = host->plat;
drivers/mmc/host/mmci.c:	if (host->gpio_cd == -ENOSYS) {
drivers/mmc/host/mmci.c:		status = plat->status(mmc_dev(host->mmc));
drivers/mmc/host/mmci.c:		status = !!gpio_get_value_cansleep(host->gpio_cd)
drivers/mmc/host/mmci.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/mmci.c:	host->mmc = mmc;
drivers/mmc/host/mmci.c:	host->gpio_wp = -ENOSYS;
drivers/mmc/host/mmci.c:	host->gpio_cd = -ENOSYS;
drivers/mmc/host/mmci.c:	host->gpio_cd_irq = -1;
drivers/mmc/host/mmci.c:	host->hw_designer = amba_manf(dev);
drivers/mmc/host/mmci.c:	host->hw_revision = amba_rev(dev);
drivers/mmc/host/mmci.c:	dev_dbg(mmc_dev(mmc), "designer ID = 0x%02x\n", host->hw_designer);
drivers/mmc/host/mmci.c:	dev_dbg(mmc_dev(mmc), "revision = 0x%01x\n", host->hw_revision);
drivers/mmc/host/mmci.c:	host->clk = clk_get(&dev->dev, NULL);
drivers/mmc/host/mmci.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/mmci.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/mmci.c:		host->clk = NULL;
drivers/mmc/host/mmci.c:	ret = clk_prepare(host->clk);
drivers/mmc/host/mmci.c:	ret = clk_enable(host->clk);
drivers/mmc/host/mmci.c:	host->plat = plat;
drivers/mmc/host/mmci.c:	host->variant = variant;
drivers/mmc/host/mmci.c:	host->mclk = clk_get_rate(host->clk);
drivers/mmc/host/mmci.c:	if (host->mclk > 100000000) {
drivers/mmc/host/mmci.c:		ret = clk_set_rate(host->clk, 100000000);
drivers/mmc/host/mmci.c:		host->mclk = clk_get_rate(host->clk);
drivers/mmc/host/mmci.c:			host->mclk);
drivers/mmc/host/mmci.c:	host->phybase = dev->res.start;
drivers/mmc/host/mmci.c:	host->base = ioremap(dev->res.start, resource_size(&dev->res));
drivers/mmc/host/mmci.c:	if (!host->base) {
drivers/mmc/host/mmci.c:		mmc->f_min = DIV_ROUND_UP(host->mclk, 257);
drivers/mmc/host/mmci.c:		mmc->f_min = DIV_ROUND_UP(host->mclk, 512);
drivers/mmc/host/mmci.c:		mmc->f_max = min(host->mclk, plat->f_max);
drivers/mmc/host/mmci.c:		mmc->f_max = min(host->mclk, fmax);
drivers/mmc/host/mmci.c:	host->vcc = regulator_get(&dev->dev, "vmmc");
drivers/mmc/host/mmci.c:	if (IS_ERR(host->vcc))
drivers/mmc/host/mmci.c:		host->vcc = NULL;
drivers/mmc/host/mmci.c:		int mask = mmc_regulator_get_ocrmask(host->vcc);
drivers/mmc/host/mmci.c:			host->mmc->ocr_avail = (u32) mask;
drivers/mmc/host/mmci.c:	if (host->vcc == NULL)
drivers/mmc/host/mmci.c:	spin_lock_init(&host->lock);
drivers/mmc/host/mmci.c:	writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:	writel(0, host->base + MMCIMASK1);
drivers/mmc/host/mmci.c:	writel(0xfff, host->base + MMCICLEAR);
drivers/mmc/host/mmci.c:			host->gpio_cd = plat->gpio_cd;
drivers/mmc/host/mmci.c:			host->gpio_cd_irq = gpio_to_irq(plat->gpio_cd);
drivers/mmc/host/mmci.c:			host->gpio_wp = plat->gpio_wp;
drivers/mmc/host/mmci.c:	if ((host->plat->status || host->gpio_cd != -ENOSYS)
drivers/mmc/host/mmci.c:	    && host->gpio_cd_irq < 0)
drivers/mmc/host/mmci.c:		host->singleirq = true;
drivers/mmc/host/mmci.c:	writel(MCI_IRQENABLE, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:	if (host->gpio_wp != -ENOSYS)
drivers/mmc/host/mmci.c:		gpio_free(host->gpio_wp);
drivers/mmc/host/mmci.c:	if (host->gpio_cd_irq >= 0)
drivers/mmc/host/mmci.c:		free_irq(host->gpio_cd_irq, host);
drivers/mmc/host/mmci.c:	if (host->gpio_cd != -ENOSYS)
drivers/mmc/host/mmci.c:		gpio_free(host->gpio_cd);
drivers/mmc/host/mmci.c:	iounmap(host->base);
drivers/mmc/host/mmci.c:	clk_disable(host->clk);
drivers/mmc/host/mmci.c:	clk_unprepare(host->clk);
drivers/mmc/host/mmci.c:	clk_put(host->clk);
drivers/mmc/host/mmci.c:		writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:		writel(0, host->base + MMCIMASK1);
drivers/mmc/host/mmci.c:		writel(0, host->base + MMCICOMMAND);
drivers/mmc/host/mmci.c:		writel(0, host->base + MMCIDATACTRL);
drivers/mmc/host/mmci.c:		if (!host->singleirq)
drivers/mmc/host/mmci.c:		if (host->gpio_wp != -ENOSYS)
drivers/mmc/host/mmci.c:			gpio_free(host->gpio_wp);
drivers/mmc/host/mmci.c:		if (host->gpio_cd_irq >= 0)
drivers/mmc/host/mmci.c:			free_irq(host->gpio_cd_irq, host);
drivers/mmc/host/mmci.c:		if (host->gpio_cd != -ENOSYS)
drivers/mmc/host/mmci.c:			gpio_free(host->gpio_cd);
drivers/mmc/host/mmci.c:		iounmap(host->base);
drivers/mmc/host/mmci.c:		clk_disable(host->clk);
drivers/mmc/host/mmci.c:		clk_unprepare(host->clk);
drivers/mmc/host/mmci.c:		clk_put(host->clk);
drivers/mmc/host/mmci.c:		if (host->vcc)
drivers/mmc/host/mmci.c:			mmc_regulator_set_ocr(mmc, host->vcc, 0);
drivers/mmc/host/mmci.c:		regulator_put(host->vcc);
drivers/mmc/host/mmci.c:			writel(0, host->base + MMCIMASK0);
drivers/mmc/host/mmci.c:		writel(MCI_IRQENABLE, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	pr_debug("%s: %s: " fmt "\n", mmc_hostname(host->mmc), __func__ , args)
drivers/mmc/host/msm_sdcc.c:	pr_debug("%s-%s ", mmc_hostname(host->mmc), hdr);
drivers/mmc/host/msm_sdcc.c:	if (host && is_wifi_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	pr_info("[WIMAX] [MMC] %s: enable_irq wimax ++ host->sdcc_irq_disabled=%d\n", mmc_hostname(mmc),host->sdcc_irq_disabled);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:			host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:			enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:	pr_info("[WIMAX] [MMC] %s: disable_irq wimax ++ host->sdcc_irq_disabled=%d\n", mmc_hostname(mmc),host->sdcc_irq_disabled);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (!host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:			disable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:	if (!host->cpu_dma_latency)
drivers/mmc/host/msm_sdcc.c:		pm_qos_update_request(&host->pm_qos_req_dma,
drivers/mmc/host/msm_sdcc.c:				host->cpu_dma_latency);
drivers/mmc/host/msm_sdcc.c:		pm_qos_update_request(&host->pm_qos_req_dma,
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_reset_ep(host, &host->sps.prod);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_reset_ep(host, &host->sps.cons);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:	if (host->sps.reset_device) {
drivers/mmc/host/msm_sdcc.c:		rc = sps_device_reset(host->sps.bam_handle);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:		host->sps.reset_device = false;
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_restore_ep(host, &host->sps.prod);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_restore_ep(host, &host->sps.cons);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(readl_relaxed(host->base + MMCIPOWER)
drivers/mmc/host/msm_sdcc.c:				| MCI_SW_RST_CFG, host->base + MMCIPOWER);
drivers/mmc/host/msm_sdcc.c:		while (readl_relaxed(host->base + MMCIPOWER) & MCI_SW_RST_CFG) {
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(0, host->base + MMCICOMMAND);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(0, host->base + MMCIDATACTRL);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(readl_relaxed(host->base + MMCIPOWER)
drivers/mmc/host/msm_sdcc.c:				| MCI_SW_RST, host->base + MMCIPOWER);
drivers/mmc/host/msm_sdcc.c:		while (readl_relaxed(host->base + MMCIPOWER) & MCI_SW_RST) {
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		ret = clk_reset(host->clk, CLK_RESET_ASSERT);
drivers/mmc/host/msm_sdcc.c:				" with err %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:				host->clk_rate, ret);
drivers/mmc/host/msm_sdcc.c:		ret = clk_reset(host->clk, CLK_RESET_DEASSERT);
drivers/mmc/host/msm_sdcc.c:				" with err %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:				host->clk_rate, ret);
drivers/mmc/host/msm_sdcc.c:			host->sps.pipe_reset_pending = true;
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		mci_clk = readl_relaxed(host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:		mci_mask0 = readl_relaxed(host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		host->pwr = readl_relaxed(host->base + MMCIPOWER);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(host->pwr, host->base + MMCIPOWER);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(mci_clk, host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(mci_mask0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	if (host->dummy_52_needed)
drivers/mmc/host/msm_sdcc.c:		host->dummy_52_needed = 0;
drivers/mmc/host/msm_sdcc.c:	BUG_ON(host->curr.data);
drivers/mmc/host/msm_sdcc.c:	del_timer(&host->req_tout_timer);
drivers/mmc/host/msm_sdcc.c:		mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:	memset(&host->curr, 0, sizeof(struct msmsdcc_curr_req));
drivers/mmc/host/msm_sdcc.c:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/msm_sdcc.c:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	host->curr.data = NULL;
drivers/mmc/host/msm_sdcc.c:	host->curr.got_dataend = 0;
drivers/mmc/host/msm_sdcc.c:	host->curr.wait_for_auto_prog_done = false;
drivers/mmc/host/msm_sdcc.c:	host->curr.got_auto_prog_done = false;
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(0, host->base + MMCIDATACTRL);
drivers/mmc/host/msm_sdcc.c:	return host->core_memres->start + MMCIFIFO;
drivers/mmc/host/msm_sdcc.c:		udelay(host->reg_write_delay);
drivers/mmc/host/msm_sdcc.c:	else if (readl_relaxed(host->base + MCI_STATUS2) &
drivers/mmc/host/msm_sdcc.c:		while (readl_relaxed(host->base + MCI_STATUS2) &
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	udelay(host->reg_write_delay);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(arg, host->base + MMCIARGUMENT);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(c, host->base + MMCICOMMAND);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(host->cmd_timeout, host->base + MMCIDATATIMER);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((unsigned int)host->curr.xfer_size,
drivers/mmc/host/msm_sdcc.c:			host->base + MMCIDATALENGTH);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(host->cmd_datactrl, host->base + MMCIDATACTRL);
drivers/mmc/host/msm_sdcc.c:	if (host->cmd_cmd) {
drivers/mmc/host/msm_sdcc.c:			(u32)host->cmd_cmd->arg, (u32)host->cmd_c);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:	if (!(host->dma.result & DMOV_RSLT_VALID)) {
drivers/mmc/host/msm_sdcc.c:	if (host->dma.result & DMOV_RSLT_DONE) {
drivers/mmc/host/msm_sdcc.c:		host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:		host->curr.xfer_remain -= host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:		if (host->dma.result & DMOV_RSLT_ERROR)
drivers/mmc/host/msm_sdcc.c:			       mmc_hostname(host->mmc), host->dma.result);
drivers/mmc/host/msm_sdcc.c:		if (host->dma.result & DMOV_RSLT_FLUSH)
drivers/mmc/host/msm_sdcc.c:			       mmc_hostname(host->mmc), host->dma.result);
drivers/mmc/host/msm_sdcc.c:		       host->dma.err.flush[0], host->dma.err.flush[1],
drivers/mmc/host/msm_sdcc.c:		       host->dma.err.flush[2], host->dma.err.flush[3],
drivers/mmc/host/msm_sdcc.c:		       host->dma.err.flush[4],
drivers/mmc/host/msm_sdcc.c:		       host->dma.err.flush[5]);
drivers/mmc/host/msm_sdcc.c:		dma_unmap_sg(mmc_dev(host->mmc), host->dma.sg,
drivers/mmc/host/msm_sdcc.c:			     host->dma.num_ents, host->dma.dir);
drivers/mmc/host/msm_sdcc.c:	if (host->curr.user_pages) {
drivers/mmc/host/msm_sdcc.c:		struct scatterlist *sg = host->dma.sg;
drivers/mmc/host/msm_sdcc.c:		for (i = 0; i < host->dma.num_ents; i++, sg++)
drivers/mmc/host/msm_sdcc.c:	host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:	host->dma.busy = 0;
drivers/mmc/host/msm_sdcc.c:	if ((host->curr.got_dataend && (!host->curr.wait_for_auto_prog_done ||
drivers/mmc/host/msm_sdcc.c:		(host->curr.wait_for_auto_prog_done &&
drivers/mmc/host/msm_sdcc.c:		host->curr.got_auto_prog_done))) || mrq->data->error) {
drivers/mmc/host/msm_sdcc.c:			host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:			host->curr.xfer_remain -= host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:		if (host->dummy_52_needed) {
drivers/mmc/host/msm_sdcc.c:			mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:			host->dummy_52_sent = 1;
drivers/mmc/host/msm_sdcc.c:			mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:			del_timer(&host->req_tout_timer);
drivers/mmc/host/msm_sdcc.c:			memset(&host->curr, 0, sizeof(struct msmsdcc_curr_req));
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			mmc_request_done(host->mmc, mrq);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	host->sps.notify = *notify;
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), __func__, notify->event_id,
drivers/mmc/host/msm_sdcc.c:	tasklet_schedule(&host->sps.tlet);
drivers/mmc/host/msm_sdcc.c:	struct sps_event_notify *notify = &host->sps.notify;
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->sps.dir == DMA_FROM_DEVICE)
drivers/mmc/host/msm_sdcc.c:		sps_pipe_handle = host->sps.prod.pipe_handle;
drivers/mmc/host/msm_sdcc.c:		sps_pipe_handle = host->sps.cons.pipe_handle;
drivers/mmc/host/msm_sdcc.c:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:	for (i = 0; i < host->sps.xfer_req_cnt; i++) {
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__, rc, i);
drivers/mmc/host/msm_sdcc.c:	if (data_xfered == host->curr.xfer_size) {
drivers/mmc/host/msm_sdcc.c:		host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:		host->curr.xfer_remain -= host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			host->curr.xfer_size);
drivers/mmc/host/msm_sdcc.c:			" xfer_size=%d", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			data_xfered, host->curr.xfer_size);
drivers/mmc/host/msm_sdcc.c:		dma_unmap_sg(mmc_dev(host->mmc), host->sps.sg,
drivers/mmc/host/msm_sdcc.c:			     host->sps.num_ents, host->sps.dir);
drivers/mmc/host/msm_sdcc.c:	host->sps.sg = NULL;
drivers/mmc/host/msm_sdcc.c:	host->sps.busy = 0;
drivers/mmc/host/msm_sdcc.c:	if ((host->curr.got_dataend && (!host->curr.wait_for_auto_prog_done ||
drivers/mmc/host/msm_sdcc.c:		(host->curr.wait_for_auto_prog_done &&
drivers/mmc/host/msm_sdcc.c:		host->curr.got_auto_prog_done))) || mrq->data->error) {
drivers/mmc/host/msm_sdcc.c:			host->curr.data_xfered = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:			host->curr.xfer_remain -= host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:		if (host->dummy_52_needed) {
drivers/mmc/host/msm_sdcc.c:			mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:			host->dummy_52_sent = 1;
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			mrq->data->bytes_xfered = host->curr.data_xfered;
drivers/mmc/host/msm_sdcc.c:			del_timer(&host->req_tout_timer);
drivers/mmc/host/msm_sdcc.c:			memset(&host->curr, 0, sizeof(struct msmsdcc_curr_req));
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			mmc_request_done(host->mmc, mrq);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:		dma_unmap_sg(mmc_dev(host->mmc), host->sps.sg,
drivers/mmc/host/msm_sdcc.c:			     host->sps.num_ents, host->sps.dir);
drivers/mmc/host/msm_sdcc.c:	host->sps.sg = NULL;
drivers/mmc/host/msm_sdcc.c:	host->sps.busy = 0;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data)
drivers/mmc/host/msm_sdcc.c:	tasklet_schedule(&host->dma_tlet);
drivers/mmc/host/msm_sdcc.c:	if ((host->dma.channel == -1) || (host->dma.crci == -1))
drivers/mmc/host/msm_sdcc.c:	BUG_ON((host->pdev_id < 1) || (host->pdev_id > 5));
drivers/mmc/host/msm_sdcc.c:	host->dma.sg = data->sg;
drivers/mmc/host/msm_sdcc.c:	host->dma.num_ents = data->sg_len;
drivers/mmc/host/msm_sdcc.c:	BUG_ON(host->dma.num_ents > msmsdcc_get_nr_sg(host));
drivers/mmc/host/msm_sdcc.c:	nc = host->dma.nc;
drivers/mmc/host/msm_sdcc.c:		host->dma.dir = DMA_FROM_DEVICE;
drivers/mmc/host/msm_sdcc.c:		host->dma.dir = DMA_TO_DEVICE;
drivers/mmc/host/msm_sdcc.c:			host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:			host->dma.num_ents = 0;
drivers/mmc/host/msm_sdcc.c:	host->curr.user_pages = 0;
drivers/mmc/host/msm_sdcc.c:	for (i = 0; i < host->dma.num_ents; i++) {
drivers/mmc/host/msm_sdcc.c:				box->cmd |= CMD_SRC_CRCI(host->dma.crci);
drivers/mmc/host/msm_sdcc.c:				box->cmd |= CMD_DST_CRCI(host->dma.crci);
drivers/mmc/host/msm_sdcc.c:	BUG_ON(host->dma.cmd_busaddr & 0x07);
drivers/mmc/host/msm_sdcc.c:	nc->cmdptr = (host->dma.cmd_busaddr >> 3) | CMD_PTR_LP;
drivers/mmc/host/msm_sdcc.c:	host->dma.hdr.cmdptr = DMOV_CMD_PTR_LIST |
drivers/mmc/host/msm_sdcc.c:			       DMOV_CMD_ADDR(host->dma.cmdptr_busaddr);
drivers/mmc/host/msm_sdcc.c:	host->dma.hdr.complete_func = msmsdcc_dma_complete_func;
drivers/mmc/host/msm_sdcc.c:			dma_unmap_sg(mmc_dev(host->mmc), host->dma.sg,
drivers/mmc/host/msm_sdcc.c:				     host->dma.num_ents, host->dma.dir);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), err);
drivers/mmc/host/msm_sdcc.c:	rc = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/msm_sdcc.c:		       mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/msm_sdcc.c:	host->sps.sg = data->sg;
drivers/mmc/host/msm_sdcc.c:	host->sps.num_ents = data->sg_len;
drivers/mmc/host/msm_sdcc.c:	host->sps.xfer_req_cnt = 0;
drivers/mmc/host/msm_sdcc.c:		host->sps.dir = DMA_FROM_DEVICE;
drivers/mmc/host/msm_sdcc.c:		sps_pipe_handle = host->sps.prod.pipe_handle;
drivers/mmc/host/msm_sdcc.c:		host->sps.dir = DMA_TO_DEVICE;
drivers/mmc/host/msm_sdcc.c:		sps_pipe_handle = host->sps.cons.pipe_handle;
drivers/mmc/host/msm_sdcc.c:			host->dma.sg = NULL;
drivers/mmc/host/msm_sdcc.c:			host->dma.num_ents = 0;
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), rc,
drivers/mmc/host/msm_sdcc.c:			host->sps.xfer_req_cnt++;
drivers/mmc/host/msm_sdcc.c:		dma_unmap_sg(mmc_dev(host->mmc), host->sps.sg,
drivers/mmc/host/msm_sdcc.c:			     host->sps.num_ents, host->sps.dir);
drivers/mmc/host/msm_sdcc.c:	if (host->tuning_needed && host->en_auto_cmd19 &&
drivers/mmc/host/msm_sdcc.c:		!(host->mmc->ios.timing == MMC_TIMING_MMC_HS200)) {
drivers/mmc/host/msm_sdcc.c:			host->curr.mrq->cmd->opcode ==
drivers/mmc/host/msm_sdcc.c:			(!host->curr.mrq->sbc &&
drivers/mmc/host/msm_sdcc.c:			if (host->en_auto_cmd19 &&
drivers/mmc/host/msm_sdcc.c:			    host->mmc->ios.timing == MMC_TIMING_UHS_SDR104)
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base +
drivers/mmc/host/msm_sdcc.c:				host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base +
drivers/mmc/host/msm_sdcc.c:				host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:		host->prog_enable = 1;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.cmd != NULL) {
drivers/mmc/host/msm_sdcc.c:		       mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	host->curr.cmd = cmd;
drivers/mmc/host/msm_sdcc.c:	void __iomem *base = host->base;
drivers/mmc/host/msm_sdcc.c:	host->curr.data = data;
drivers/mmc/host/msm_sdcc.c:	host->curr.xfer_size = data->blksz * data->blocks;
drivers/mmc/host/msm_sdcc.c:	host->curr.xfer_remain = host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:	host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:	host->curr.got_dataend = 0;
drivers/mmc/host/msm_sdcc.c:	host->curr.got_auto_prog_done = false;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.wait_for_auto_prog_done)
drivers/mmc/host/msm_sdcc.c:				host->sps.busy = 1;
drivers/mmc/host/msm_sdcc.c:			if (host->curr.xfer_remain < MCI_FIFOSIZE)
drivers/mmc/host/msm_sdcc.c:	else if (host->curr.use_wr_data_pend)
drivers/mmc/host/msm_sdcc.c:	clks = (unsigned long long)data->timeout_ns * host->clk_rate;
drivers/mmc/host/msm_sdcc.c:	     mmc_hostname(host->mmc), data->timeout_ns, data->timeout_clks);
drivers/mmc/host/msm_sdcc.c:		host->cmd_timeout = timeout;
drivers/mmc/host/msm_sdcc.c:		host->cmd_pio_irqmask = pio_irqmask;
drivers/mmc/host/msm_sdcc.c:		host->cmd_datactrl = datactrl;
drivers/mmc/host/msm_sdcc.c:		host->cmd_cmd = cmd;
drivers/mmc/host/msm_sdcc.c:		host->dma.hdr.exec_func = msmsdcc_dma_exec_func;
drivers/mmc/host/msm_sdcc.c:		host->dma.hdr.user = (void *)host;
drivers/mmc/host/msm_sdcc.c:		host->dma.busy = 1;
drivers/mmc/host/msm_sdcc.c:			host->cmd_c = c;
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				(~(MCI_IRQ_PIO))) | host->cmd_pio_irqmask,
drivers/mmc/host/msm_sdcc.c:				host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		msm_dmov_enqueue_cmd_ext(host->dma.channel, &host->dma.hdr);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(host->curr.xfer_size, base + MMCIDATALENGTH);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			       mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		if (host->tuning_needed && !host->tuning_in_progress)
drivers/mmc/host/msm_sdcc.c:			host->tuning_done = false;
drivers/mmc/host/msm_sdcc.c:				 mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:				 (readl_relaxed(host->base
drivers/mmc/host/msm_sdcc.c:		if (host->tuning_needed && !host->tuning_in_progress)
drivers/mmc/host/msm_sdcc.c:			host->tuning_done = false;
drivers/mmc/host/msm_sdcc.c:		pr_err("%s: RX overrun\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		pr_err("%s: TX underrun\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		      mmc_hostname(host->mmc), status);
drivers/mmc/host/msm_sdcc.c:	if (host->dummy_52_needed)
drivers/mmc/host/msm_sdcc.c:		host->dummy_52_needed = 0;
drivers/mmc/host/msm_sdcc.c:	void __iomem	*base = host->base;
drivers/mmc/host/msm_sdcc.c:	void __iomem *base = host->base;
drivers/mmc/host/msm_sdcc.c:	struct msmsdcc_pio_data *pio = &host->pio;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data->flags & MMC_DATA_READ)
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data->flags & MMC_DATA_READ)
drivers/mmc/host/msm_sdcc.c:	struct msmsdcc_pio_data *pio = &host->pio;
drivers/mmc/host/msm_sdcc.c:	if (length < host->curr.xfer_remain) {
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data->flags & MMC_DATA_READ) {
drivers/mmc/host/msm_sdcc.c:	struct msmsdcc_pio_data *pio = &host->pio;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data->flags & MMC_DATA_READ) {
drivers/mmc/host/msm_sdcc.c:	host->pio.bounce_buf_len = 0;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data->flags & MMC_DATA_READ)
drivers/mmc/host/msm_sdcc.c:	sg_miter_start(&host->pio.sg_miter, host->curr.data->sg,
drivers/mmc/host/msm_sdcc.c:		       host->curr.data->sg_len, sg_miter_flags);
drivers/mmc/host/msm_sdcc.c:	sg_miter_stop(&host->pio.sg_miter);
drivers/mmc/host/msm_sdcc.c:	void __iomem		*base = host->base;
drivers/mmc/host/msm_sdcc.c:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	if (((readl_relaxed(host->base + MMCIMASK0) & status) &
drivers/mmc/host/msm_sdcc.c:		spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:		host->curr.xfer_remain -= len;
drivers/mmc/host/msm_sdcc.c:		host->curr.data_xfered += len;
drivers/mmc/host/msm_sdcc.c:	if (status & MCI_RXACTIVE && host->curr.xfer_remain < MCI_FIFOSIZE) {
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		if (!host->curr.xfer_remain) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed((readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				(~(MCI_IRQ_PIO))) | 0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	} else if (!host->curr.xfer_remain) {
drivers/mmc/host/msm_sdcc.c:		writel_relaxed((readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				(~(MCI_IRQ_PIO))) | 0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	while (((int)host->curr.xfer_remain > 0) && (++loop_cnt < 1000)) {
drivers/mmc/host/msm_sdcc.c:		if (readl_relaxed(host->base + MMCISTATUS) & MCI_RXDATAAVLBL) {
drivers/mmc/host/msm_sdcc.c:			spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:			spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	struct mmc_command *cmd = host->curr.cmd;
drivers/mmc/host/msm_sdcc.c:	host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:		cmd->resp[0] = readl_relaxed(host->base + MMCIRESPONSE0);
drivers/mmc/host/msm_sdcc.c:		cmd->resp[1] = readl_relaxed(host->base + MMCIRESPONSE1);
drivers/mmc/host/msm_sdcc.c:		cmd->resp[2] = readl_relaxed(host->base + MMCIRESPONSE2);
drivers/mmc/host/msm_sdcc.c:		cmd->resp[3] = readl_relaxed(host->base + MMCIRESPONSE3);
drivers/mmc/host/msm_sdcc.c:		if (is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/msm_sdcc.c:			!host->tuning_in_progress) {
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/msm_sdcc.c:		if (host->tuning_needed)
drivers/mmc/host/msm_sdcc.c:			host->tuning_done = false;
drivers/mmc/host/msm_sdcc.c:		if (cmd->cmd_timeout_ms > host->curr.req_tout_ms) {
drivers/mmc/host/msm_sdcc.c:			host->curr.req_tout_ms = cmd->cmd_timeout_ms;
drivers/mmc/host/msm_sdcc.c:			mod_timer(&host->req_tout_timer, (jiffies +
drivers/mmc/host/msm_sdcc.c:				  msecs_to_jiffies(host->curr.req_tout_ms)));
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data && host->dma.sg &&
drivers/mmc/host/msm_sdcc.c:			msm_dmov_flush(host->dma.channel, 0);
drivers/mmc/host/msm_sdcc.c:		else if (host->curr.data && host->sps.sg &&
drivers/mmc/host/msm_sdcc.c:		else if (host->curr.data) { 
drivers/mmc/host/msm_sdcc.c:			if (!cmd->error && host->prog_enable) {
drivers/mmc/host/msm_sdcc.c:					host->prog_enable = 0;
drivers/mmc/host/msm_sdcc.c:					host->curr.cmd = cmd;
drivers/mmc/host/msm_sdcc.c:				host->prog_enable = 0;
drivers/mmc/host/msm_sdcc.c:				host->curr.wait_for_auto_prog_done = false;
drivers/mmc/host/msm_sdcc.c:				if (host->dummy_52_needed)
drivers/mmc/host/msm_sdcc.c:					host->dummy_52_needed = 0;
drivers/mmc/host/msm_sdcc.c:		if (cmd == host->curr.mrq->sbc)
drivers/mmc/host/msm_sdcc.c:			msmsdcc_start_command(host, host->curr.mrq->cmd, 0);
drivers/mmc/host/msm_sdcc.c:			   !host->curr.use_wr_data_pend)
drivers/mmc/host/msm_sdcc.c:if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s msmsdcc_irq+++\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			if (host->irq_time_wimax == 0)
drivers/mmc/host/msm_sdcc.c:				host->irq_time_wimax = jiffies + HZ;
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (host->irq_time == 0)
drivers/mmc/host/msm_sdcc.c:			host->irq_time = jiffies + HZ;
drivers/mmc/host/msm_sdcc.c:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:		if (!atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:			if (!host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:				host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:			if (host->sdcc_suspended) {
drivers/mmc/host/msm_sdcc.c:				if (host->plat->sdiowakeup_irq)
drivers/mmc/host/msm_sdcc.c:					wake_lock(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc.c:				struct mmc_host 	*mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:					spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:					mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:					spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:					status = readl_relaxed(host->base + MMCISTATUS);
drivers/mmc/host/msm_sdcc.c:		status = readl_relaxed(host->base + MMCISTATUS);
drivers/mmc/host/msm_sdcc.c:		if (((readl_relaxed(host->base + MMCIMASK0) & status) &
drivers/mmc/host/msm_sdcc.c:		status &= readl_relaxed(host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(status, host->base + MMCICLEAR);
drivers/mmc/host/msm_sdcc.c:		if (host->clk_rate <=
drivers/mmc/host/msm_sdcc.c:			if (host->sdcc_suspending)
drivers/mmc/host/msm_sdcc.c:				wake_lock(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:			spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:			spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:		data = host->curr.data;
drivers/mmc/host/msm_sdcc.c:		if (host->dummy_52_sent) {
drivers/mmc/host/msm_sdcc.c:						mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:						mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:				host->dummy_52_sent = 0;
drivers/mmc/host/msm_sdcc.c:				host->dummy_52_needed = 0;
drivers/mmc/host/msm_sdcc.c:				spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:		cmd = host->curr.cmd;
drivers/mmc/host/msm_sdcc.c:			MCI_AUTOCMD19TIMEOUT)) && host->curr.cmd) {
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data) {
drivers/mmc/host/msm_sdcc.c:				host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:				if (host->dma.sg && is_dma_mode(host))
drivers/mmc/host/msm_sdcc.c:					msm_dmov_flush(host->dma.channel, 0);
drivers/mmc/host/msm_sdcc.c:				else if (host->sps.sg && is_sps_mode(host)) {
drivers/mmc/host/msm_sdcc.c:					if (host->curr.data)
drivers/mmc/host/msm_sdcc.c:					if (!data->stop || (host->curr.mrq->sbc
drivers/mmc/host/msm_sdcc.c:					else if ((host->curr.mrq->sbc
drivers/mmc/host/msm_sdcc.c:						!host->curr.mrq->sbc) {
drivers/mmc/host/msm_sdcc.c:			if (host->curr.wait_for_auto_prog_done &&
drivers/mmc/host/msm_sdcc.c:				host->curr.got_auto_prog_done = true;
drivers/mmc/host/msm_sdcc.c:			if (!host->curr.got_dataend && (status & MCI_DATAEND))
drivers/mmc/host/msm_sdcc.c:				host->curr.got_dataend = 1;
drivers/mmc/host/msm_sdcc.c:			if (host->curr.got_dataend &&
drivers/mmc/host/msm_sdcc.c:				(!host->curr.wait_for_auto_prog_done ||
drivers/mmc/host/msm_sdcc.c:				(host->curr.wait_for_auto_prog_done &&
drivers/mmc/host/msm_sdcc.c:				host->curr.got_auto_prog_done))) {
drivers/mmc/host/msm_sdcc.c:				if (!host->dma.busy && !host->sps.busy) {
drivers/mmc/host/msm_sdcc.c:						host->curr.data_xfered =
drivers/mmc/host/msm_sdcc.c:							host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:						host->curr.xfer_remain -=
drivers/mmc/host/msm_sdcc.c:							host->curr.xfer_size;
drivers/mmc/host/msm_sdcc.c:					if (!host->dummy_52_needed) {
drivers/mmc/host/msm_sdcc.c:							(host->curr.mrq->sbc
drivers/mmc/host/msm_sdcc.c:						else if ((host->curr.mrq->sbc
drivers/mmc/host/msm_sdcc.c:							!host->curr.mrq->sbc) {
drivers/mmc/host/msm_sdcc.c:						host->dummy_52_sent = 1;
drivers/mmc/host/msm_sdcc.c:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat) && time_after(jiffies, host->irq_time)) {
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), __func__, irq_count);
drivers/mmc/host/msm_sdcc.c:		host->irq_time = jiffies + HZ;
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && time_after(jiffies, host->irq_time_wimax)) {
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__, irq_count_wimax);
drivers/mmc/host/msm_sdcc.c:			host->irq_time_wimax = jiffies + HZ;
drivers/mmc/host/msm_sdcc.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/msm_sdcc.c:		    host->curr.use_wr_data_pend)
drivers/mmc/host/msm_sdcc.c:	WARN(host->dummy_52_sent, "Dummy CMD52 in progress\n");
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (is_sps_mode(host) && host->sps.pipe_reset_pending) {
drivers/mmc/host/msm_sdcc.c:		host->sps.pipe_reset_pending = false;
drivers/mmc/host/msm_sdcc.c:	if (host->tuning_needed && !host->tuning_in_progress &&
drivers/mmc/host/msm_sdcc.c:		!host->tuning_done) {
drivers/mmc/host/msm_sdcc.c:		if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104) {
drivers/mmc/host/msm_sdcc.c:			if (host->cont_tuning_cnt <= MAX_CONTINUOUS_TUNING_COUNT) 
drivers/mmc/host/msm_sdcc.c:		} else if (host->mmc->ios.timing == MMC_TIMING_MMC_HS200)
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->eject) {
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat) || is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		mutex_lock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:		if (!atomic_read(&host->clks_on) || host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:		if (!atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:			mmc->ios.clock = host->clk_rate;
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		if (host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:			if (host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:				struct irq_desc *desc = irq_to_desc(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:				enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:				host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		mutex_unlock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host->pwr || !atomic_read(&host->clks_on)
drivers/mmc/host/msm_sdcc.c:			|| host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:		     " new request (CMD%d)\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	WARN(host->curr.mrq, "%s: %s: New request (CMD%d) received while"
drivers/mmc/host/msm_sdcc.c:	     mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:	     mrq->cmd->opcode, host->curr.mrq->cmd->opcode);
drivers/mmc/host/msm_sdcc.c:		host->curr.req_tout_ms = 20000;
drivers/mmc/host/msm_sdcc.c:		if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			host->curr.req_tout_ms = 4000;
drivers/mmc/host/msm_sdcc.c:			host->curr.req_tout_ms = MSM_MMC_REQ_TIMEOUT;
drivers/mmc/host/msm_sdcc.c:	mod_timer(&host->req_tout_timer,
drivers/mmc/host/msm_sdcc.c:			 msecs_to_jiffies(host->curr.req_tout_ms)));
drivers/mmc/host/msm_sdcc.c:	host->curr.mrq = mrq;
drivers/mmc/host/msm_sdcc.c:				host->curr.wait_for_auto_prog_done = true;
drivers/mmc/host/msm_sdcc.c:				host->dummy_52_needed = 1;
drivers/mmc/host/msm_sdcc.c:			host->curr.use_wr_data_pend = true;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	struct device *dev = mmc_dev(host->mmc);
drivers/mmc/host/msm_sdcc.c:	curr_slot = host->plat->vreg_data;
drivers/mmc/host/msm_sdcc.c:			       host->pdev_id, rc);
drivers/mmc/host/msm_sdcc.c:	curr_slot = host->plat->vreg_data;
drivers/mmc/host/msm_sdcc.c:	if(is_sd_platform(host->plat) && (enable ^ vreg_table[0]->is_enabled)) {
drivers/mmc/host/msm_sdcc.c:			enable ? "Enabling" : "Disabling", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	if (host->plat->vreg_data) {
drivers/mmc/host/msm_sdcc.c:			host->plat->vreg_data->vdd_io_data;
drivers/mmc/host/msm_sdcc.c:			io_reg = host->plat->vreg_data->vdd_data;
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->io_pad_pwr_switch = 1;
drivers/mmc/host/msm_sdcc.c:		host->io_pad_pwr_switch = 0;
drivers/mmc/host/msm_sdcc.c:	if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		if (host->io_pad_pwr_switch)
drivers/mmc/host/msm_sdcc.c:			writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
drivers/mmc/host/msm_sdcc.c:					host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:			writel_relaxed((readl_relaxed(host->base + MMCICLOCK) &
drivers/mmc/host/msm_sdcc.c:					host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->vreg_data) {
drivers/mmc/host/msm_sdcc.c:			host->plat->vreg_data->vdd_io_data;
drivers/mmc/host/msm_sdcc.c:				       mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:	if (host->clk_rate > 400000 && msmsdcc_pwrsave)
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enable=%d\n", mmc_hostname(host->mmc), __func__,enable);
drivers/mmc/host/msm_sdcc.c:	if (enable && !atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		        wimax_enable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:		if (!IS_ERR_OR_NULL(host->bus_clk)) {
drivers/mmc/host/msm_sdcc.c:			rc = clk_prepare_enable(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__, rc);
drivers/mmc/host/msm_sdcc.c:		if (!IS_ERR(host->pclk)) {
drivers/mmc/host/msm_sdcc.c:			rc = clk_prepare_enable(host->pclk);
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), __func__, rc);
drivers/mmc/host/msm_sdcc.c:		rc = clk_prepare_enable(host->clk);
drivers/mmc/host/msm_sdcc.c:			pr_err("%s: %s: failed to enable the host-clk with error %d\n",
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__, rc);
drivers/mmc/host/msm_sdcc.c:		atomic_set(&host->clks_on, 1);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s wimax clk on\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	} else if (!enable && atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:				wimax_disable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:		clk_disable_unprepare(host->clk);
drivers/mmc/host/msm_sdcc.c:		if (!IS_ERR(host->pclk))
drivers/mmc/host/msm_sdcc.c:			clk_disable_unprepare(host->pclk);
drivers/mmc/host/msm_sdcc.c:		if (!IS_ERR_OR_NULL(host->bus_clk))
drivers/mmc/host/msm_sdcc.c:			clk_disable_unprepare(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:		atomic_set(&host->clks_on, 0);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s wimax clk off\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->pclk))
drivers/mmc/host/msm_sdcc.c:		clk_disable_unprepare(host->pclk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->bus_clk))
drivers/mmc/host/msm_sdcc.c:		clk_disable_unprepare(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->sup_clk_table && host->plat->sup_clk_cnt) {
drivers/mmc/host/msm_sdcc.c:		for (cnt = 0; cnt < host->plat->sup_clk_cnt; cnt++) {
drivers/mmc/host/msm_sdcc.c:			if (host->plat->sup_clk_table[cnt] > req_clk)
drivers/mmc/host/msm_sdcc.c:			else if (host->plat->sup_clk_table[cnt] == req_clk) {
drivers/mmc/host/msm_sdcc.c:				sel_clk = host->plat->sup_clk_table[cnt];
drivers/mmc/host/msm_sdcc.c:				sel_clk = host->plat->sup_clk_table[cnt];
drivers/mmc/host/msm_sdcc.c:		if ((req_clk < host->plat->msmsdcc_fmax) &&
drivers/mmc/host/msm_sdcc.c:			(req_clk > host->plat->msmsdcc_fmid))
drivers/mmc/host/msm_sdcc.c:			sel_clk = host->plat->msmsdcc_fmid;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->sup_clk_table && host->plat->sup_clk_cnt)
drivers/mmc/host/msm_sdcc.c:		return host->plat->sup_clk_table[0];
drivers/mmc/host/msm_sdcc.c:		return host->plat->msmsdcc_fmin;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->sup_clk_table && host->plat->sup_clk_cnt)
drivers/mmc/host/msm_sdcc.c:		return host->plat->sup_clk_table[host->plat->sup_clk_cnt - 1];
drivers/mmc/host/msm_sdcc.c:		return host->plat->msmsdcc_fmax;
drivers/mmc/host/msm_sdcc.c:	curr = host->plat->pin_data->gpio_data;
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	curr = host->plat->pin_data->pad_data;
drivers/mmc/host/msm_sdcc.c:	if(host->plat->config_sdgpio)
drivers/mmc/host/msm_sdcc.c:		return host->plat->config_sdgpio(enable);
drivers/mmc/host/msm_sdcc.c:	if (!host->plat->pin_data || host->plat->pin_data->cfg_sts == enable)
drivers/mmc/host/msm_sdcc.c:	if (host->plat->pin_data->is_gpio)
drivers/mmc/host/msm_sdcc.c:		host->plat->pin_data->cfg_sts = enable;
drivers/mmc/host/msm_sdcc.c:	unsigned int pin = host->plat->mpm_sdiowakeup_int;
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->translate_vdd && !host->sdio_gpio_lpm)
drivers/mmc/host/msm_sdcc.c:		ret = host->plat->translate_vdd(mmc_dev(mmc), ios->vdd);
drivers/mmc/host/msm_sdcc.c:	else if (!host->plat->translate_vdd && !host->sdio_gpio_lpm)
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		if (is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			if (!host->eject && mmc->card && mmc_sd_card_uhs(mmc->card))
drivers/mmc/host/msm_sdcc.c:	wakeup_irq = (host->plat->sdiowakeup_irq) ?
drivers/mmc/host/msm_sdcc.c:			host->plat->sdiowakeup_irq :
drivers/mmc/host/msm_sdcc.c:			host->core_irqres->start;
drivers/mmc/host/msm_sdcc.c:	if (!host->irq_wake_enabled) {
drivers/mmc/host/msm_sdcc.c:		host->irq_wake_enabled = true;
drivers/mmc/host/msm_sdcc.c:	wakeup_irq = (host->plat->sdiowakeup_irq) ?
drivers/mmc/host/msm_sdcc.c:			host->plat->sdiowakeup_irq :
drivers/mmc/host/msm_sdcc.c:			host->core_irqres->start;
drivers/mmc/host/msm_sdcc.c:	if (host->irq_wake_enabled) {
drivers/mmc/host/msm_sdcc.c:		host->irq_wake_enabled = false;
drivers/mmc/host/msm_sdcc.c:	bw = host->clk_rate;
drivers/mmc/host/msm_sdcc.c:	unsigned int *table = host->plat->msm_bus_voting_data->bw_vecs;
drivers/mmc/host/msm_sdcc.c:	unsigned int size = host->plat->msm_bus_voting_data->bw_vecs_size;
drivers/mmc/host/msm_sdcc.c:	if (host->msm_bus_vote.is_max_bw_needed && bw)
drivers/mmc/host/msm_sdcc.c:		return host->msm_bus_vote.max_bw_vote;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->msm_bus_voting_data &&
drivers/mmc/host/msm_sdcc.c:	    host->plat->msm_bus_voting_data->use_cases &&
drivers/mmc/host/msm_sdcc.c:	    host->plat->msm_bus_voting_data->bw_vecs &&
drivers/mmc/host/msm_sdcc.c:	    host->plat->msm_bus_voting_data->bw_vecs_size) {
drivers/mmc/host/msm_sdcc.c:		use_cases = host->plat->msm_bus_voting_data->use_cases;
drivers/mmc/host/msm_sdcc.c:		host->msm_bus_vote.client_handle =
drivers/mmc/host/msm_sdcc.c:	if (!host->msm_bus_vote.client_handle) {
drivers/mmc/host/msm_sdcc.c:		       mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		host->msm_bus_vote.min_bw_vote =
drivers/mmc/host/msm_sdcc.c:		host->msm_bus_vote.max_bw_vote =
drivers/mmc/host/msm_sdcc.c:	if (host->msm_bus_vote.client_handle)
drivers/mmc/host/msm_sdcc.c:			host->msm_bus_vote.client_handle);
drivers/mmc/host/msm_sdcc.c:	if (vote != host->msm_bus_vote.curr_vote) {
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:				host->msm_bus_vote.client_handle, vote);
drivers/mmc/host/msm_sdcc.c:			       mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			       host->msm_bus_vote.client_handle, vote, rc);
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc), ktime_to_ms(diff));
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->msm_bus_vote.curr_vote = vote;
drivers/mmc/host/msm_sdcc.c:	if (!host->msm_bus_vote.client_handle)
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host->curr.mrq)
drivers/mmc/host/msm_sdcc.c:			host->msm_bus_vote.min_bw_vote, flags);
drivers/mmc/host/msm_sdcc.c:			   mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host->msm_bus_vote.client_handle)
drivers/mmc/host/msm_sdcc.c:	cancel_delayed_work_sync(&host->msm_bus_vote.vote_work);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host->msm_bus_vote.client_handle)
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->msm_bus_vote.min_bw_vote != host->msm_bus_vote.curr_vote)
drivers/mmc/host/msm_sdcc.c:				   &host->msm_bus_vote.vote_work,
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:			|| host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (!host->sdcc_suspended) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(MCI_SDIOINTMASK, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(MCI_SDIOINTMASK, host->base + MMCICLEAR);
drivers/mmc/host/msm_sdcc.c:		if (!host->plat->sdiowakeup_irq) {
drivers/mmc/host/msm_sdcc.c:					host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			if (host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:				host->sdio_wakeupirq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:				enable_irq(host->plat->sdiowakeup_irq);
drivers/mmc/host/msm_sdcc.c:		if (!host->plat->sdiowakeup_irq) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(MCI_SDIOINTMASK, host->base + MMCICLEAR);
drivers/mmc/host/msm_sdcc.c:		} else if (!host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:			disable_irq_nosync(host->plat->sdiowakeup_irq);
drivers/mmc/host/msm_sdcc.c:			host->sdio_wakeupirq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s:msmsdcc_set_ios\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (!host->sdcc_irq_disabled && !(is_wimax_platform(host->plat) && mmc_wimax_get_status())) {
drivers/mmc/host/msm_sdcc.c:	if (!host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:		disable_irq_nosync(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	synchronize_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		            wimax_enable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			printk(KERN_INFO "[WIFI] [MMC] %s [WIFI] %s clks is ON\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:			if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:					printk(KERN_INFO "[WIMAX] [MMC] %s [WiMAX] %s wimax clk is ON\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(host->mci_irqenable, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			clk = readl_relaxed(host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(clk, host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:			if (!host->ddr_doubled_clk_rate ||
drivers/mmc/host/msm_sdcc.c:				(host->ddr_doubled_clk_rate &&
drivers/mmc/host/msm_sdcc.c:				(host->ddr_doubled_clk_rate != ios->clock))) {
drivers/mmc/host/msm_sdcc.c:				host->ddr_doubled_clk_rate =
drivers/mmc/host/msm_sdcc.c:				clock = host->ddr_doubled_clk_rate;
drivers/mmc/host/msm_sdcc.c:			host->ddr_doubled_clk_rate = 0;
drivers/mmc/host/msm_sdcc.c:		if (clock != host->clk_rate) {
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			rc = clk_set_rate(host->clk, clock);
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->clk_rate = clock;
drivers/mmc/host/msm_sdcc.c:			host->reg_write_delay =
drivers/mmc/host/msm_sdcc.c:				      (host->clk_rate ? host->clk_rate :
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s clk |= MCI_CLK_ENABLE\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	host->tuning_needed = 0;
drivers/mmc/host/msm_sdcc.c:	host->cont_tuning_cnt = 0;
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	if (host->clk_rate > (100 * 1000 * 1000) &&
drivers/mmc/host/msm_sdcc.c:		host->tuning_needed = 1;
drivers/mmc/host/msm_sdcc.c:		host->tuning_done = false;
drivers/mmc/host/msm_sdcc.c:		if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed((readl_relaxed(host->base +
drivers/mmc/host/msm_sdcc.c:				host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:			writel_relaxed((readl_relaxed(host->base +
drivers/mmc/host/msm_sdcc.c:				host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:		if (is_wifi_slot(host->plat) && host->pdev_id == 3) {
drivers/mmc/host/msm_sdcc.c:			host->io_pad_pwr_switch = 1;
drivers/mmc/host/msm_sdcc.c:	if (host->io_pad_pwr_switch)
drivers/mmc/host/msm_sdcc.c:	if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		if (readl_relaxed(host->base + MMCICLOCK) != clk) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(clk, host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:		if (readl_relaxed(host->base + MMCIPOWER) != pwr) {
drivers/mmc/host/msm_sdcc.c:			host->pwr = pwr;
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(pwr, host->base + MMCIPOWER);
drivers/mmc/host/msm_sdcc.c:	if (!(clk & MCI_CLK_ENABLE) && atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:				wimax_disable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			printk(KERN_INFO "[WIFI] [MMC] %s [WIFI] %s clks is OFF\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:				printk(KERN_INFO "[WIMAX] [MMC] %s [WiMAX] %s wimax clks is OFF\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->tuning_in_progress)
drivers/mmc/host/msm_sdcc.c:		WARN(!atomic_read(&host->clks_on),
drivers/mmc/host/msm_sdcc.c:	if (ios->power_mode != MMC_POWER_OFF && host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:		if(is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:				enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:				host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:		} else if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s, ios->power_mode=%d clks_on=%d\n", mmc_hostname(host->mmc), __func__,ios->power_mode,atomic_read(&host->clks_on));
drivers/mmc/host/msm_sdcc.c:			if (atomic_read(&host->clks_on) && (!host->sdcc_irq_disabled)) {
drivers/mmc/host/msm_sdcc.c:				pr_info("[WIMAX] [MMC] %s: %s wimax enable_irq , host->sdcc_irq_disabled=%d\n", mmc_hostname(host->mmc), __func__,host->sdcc_irq_disabled);
drivers/mmc/host/msm_sdcc.c:				enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:				host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:			if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:				pr_info("[WIMAX] [MMC] %s: %s Non-wimax enable_irq ios->power_mode=%d\n", mmc_hostname(host->mmc), __func__,ios->power_mode);
drivers/mmc/host/msm_sdcc.c:			enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	clk = readl_relaxed(host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(clk, host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->wpswitch) {
drivers/mmc/host/msm_sdcc.c:		status = host->plat->wpswitch(mmc_dev(mmc));
drivers/mmc/host/msm_sdcc.c:	} else if (host->plat->wpswitch_gpio) {
drivers/mmc/host/msm_sdcc.c:		status = gpio_request(host->plat->wpswitch_gpio,
drivers/mmc/host/msm_sdcc.c:				host->plat->wpswitch_gpio);
drivers/mmc/host/msm_sdcc.c:					host->plat->wpswitch_gpio);
drivers/mmc/host/msm_sdcc.c:						host->plat->wpswitch_gpio);
drivers/mmc/host/msm_sdcc.c:				status ^= !host->plat->is_wpswitch_active_low;
drivers/mmc/host/msm_sdcc.c:			gpio_free(host->plat->wpswitch_gpio);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->mci_irqenable |= MCI_SDIOINTOPERMASK;
drivers/mmc/host/msm_sdcc.c:		if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(readl_relaxed(host->base + MMCIMASK0) |
drivers/mmc/host/msm_sdcc.c:				MCI_SDIOINTOPERMASK, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		host->mci_irqenable &= ~MCI_SDIOINTOPERMASK;
drivers/mmc/host/msm_sdcc.c:		if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(readl_relaxed(host->base + MMCIMASK0) &
drivers/mmc/host/msm_sdcc.c:				~MCI_SDIOINTOPERMASK, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	struct device *dev = mmc_dev(host->mmc);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), host->sdcc_suspended,
drivers/mmc/host/msm_sdcc.c:		host->pending_resume, host->sdcc_suspending);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), dev->power.runtime_status,
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), ktime_to_us(host->enable_t), atomic_read(&host->enable_count_usage), ktime_to_us(host->disable_t), atomic_read(&host->disable_count_usage), ktime_to_us(host->rpm_sus_t), ktime_to_us(host->rpm_res_t));
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat) || is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	if (host->sdcc_suspended && host->pending_resume &&
drivers/mmc/host/msm_sdcc.c:		host->pending_resume = false;
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		host->enable_t = ktime_get();
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		atomic_set(&host->enable_count_usage, atomic_read(&dev->power.usage_count));
drivers/mmc/host/msm_sdcc.c:	if (host->plat->disable_runtime_pm)
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		host->disable_t = ktime_get();
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		atomic_set(&host->disable_count_usage, atomic_read(&dev->power.usage_count));
drivers/mmc/host/msm_sdcc.c:	if (host->sdcc_suspended && host->pending_resume) {
drivers/mmc/host/msm_sdcc.c:		host->pending_resume = false;
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (host->clks_on) {
drivers/mmc/host/msm_sdcc.c:			printk(KERN_INFO "[WIFI] [MMC] %s [WIFI] %s clks is ON\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (!host->clks_on) {
drivers/mmc/host/msm_sdcc.c:			printk(KERN_INFO "[WIFI] [MMC] %s [WIFI] %s clks is OFF\n", __func__, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (readl_relaxed(host->base + MCI_TEST_INPUT) & (0xF << 1)) {
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
drivers/mmc/host/msm_sdcc.c:			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MMCICLOCK)
drivers/mmc/host/msm_sdcc.c:			& ~MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if ((readl_relaxed(host->base + MCI_TEST_INPUT) & (0xF << 1))
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
drivers/mmc/host/msm_sdcc.c:			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->clk_rate <= 112000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 125000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 137000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 150000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 162000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 175000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 187000000)
drivers/mmc/host/msm_sdcc.c:	else if (host->clk_rate <= 200000000)
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MMCICLOCK)
drivers/mmc/host/msm_sdcc.c:			& ~MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_DLL_RST), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_DLL_PDN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			& ~MCI_DLL_RST), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			& ~MCI_DLL_PDN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_DLL_EN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_CK_OUT_EN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	while (!(readl_relaxed(host->base + MCI_DLL_STATUS) & MCI_DLL_LOCK)) {
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
drivers/mmc/host/msm_sdcc.c:			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	ck_out_en = !!(readl_relaxed(host->base + MCI_DLL_CONFIG) &
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__, poll);
drivers/mmc/host/msm_sdcc.c:		ck_out_en = !!(readl_relaxed(host->base + MCI_DLL_CONFIG) &
drivers/mmc/host/msm_sdcc.c:	config = readl_relaxed(host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(config, host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_CK_OUT_EN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	pr_err("%s: %s: Failed\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	config = readl_relaxed(host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(config, host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed((readl_relaxed(host->base + MCI_DLL_CONFIG)
drivers/mmc/host/msm_sdcc.c:			| MCI_CK_OUT_EN), host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	config = readl_relaxed(host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(config, host->base + MCI_DLL_CONFIG);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), __func__, phase);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), __func__, total_phases);
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), __func__, ret);
drivers/mmc/host/msm_sdcc.c:	if (!host->tuning_needed) {
drivers/mmc/host/msm_sdcc.c:	host->cont_tuning_cnt++;
drivers/mmc/host/msm_sdcc.c:	if (host->cont_tuning_cnt > MAX_CONTINUOUS_TUNING_COUNT) {
drivers/mmc/host/msm_sdcc.c:		if (host->cont_tuning_cnt == (MAX_CONTINUOUS_TUNING_COUNT+1))
drivers/mmc/host/msm_sdcc.c:		if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	WARN(!host->pwr, "SDCC power is turned off\n");
drivers/mmc/host/msm_sdcc.c:	WARN(!atomic_read(&host->clks_on), "SDCC clocks are turned off\n");
drivers/mmc/host/msm_sdcc.c:	WARN(host->sdcc_irq_disabled, "SDCC IRQ is disabled\n");
drivers/mmc/host/msm_sdcc.c:	host->tuning_in_progress = 1;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	host->tuning_in_progress = 0;
drivers/mmc/host/msm_sdcc.c:		host->cont_tuning_cnt = 0;
drivers/mmc/host/msm_sdcc.c:		if (is_wifi_platform(host->plat)) 
drivers/mmc/host/msm_sdcc.c:		host->tuning_done = true;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	unsigned int gpio_no = host->plat->status_gpio;
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), __func__, gpio_no);
drivers/mmc/host/msm_sdcc.c:			if (host->plat->is_status_gpio_active_low)
drivers/mmc/host/msm_sdcc.c:       if (host->plat->status || host->plat->status_gpio) {
drivers/mmc/host/msm_sdcc.c:               if (host->plat->status)
drivers/mmc/host/msm_sdcc.c:                       status = host->plat->status(mmc_dev(host->mmc));
drivers/mmc/host/msm_sdcc.c:	if (host->plat->status || host->plat->status_gpio) {
drivers/mmc/host/msm_sdcc.c:		if (host->plat->status)
drivers/mmc/host/msm_sdcc.c:			status = host->plat->status(mmc_dev(host->mmc));
drivers/mmc/host/msm_sdcc.c:		host->eject = !status;
drivers/mmc/host/msm_sdcc.c:		if (status ^ host->oldstat) {
drivers/mmc/host/msm_sdcc.c:			if (host->plat->status)
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:					host->oldstat, status);
drivers/mmc/host/msm_sdcc.c:			else if (host->plat->is_status_gpio_active_low)
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:					host->oldstat, status);
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:					host->oldstat, status);
drivers/mmc/host/msm_sdcc.c:			mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:		host->oldstat = status;
drivers/mmc/host/msm_sdcc.c:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:	pr_debug("%s: SDIO Wake up IRQ : %d\n", mmc_hostname(host->mmc), irq);
drivers/mmc/host/msm_sdcc.c:	spin_lock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	if (!host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:		if (host->sdcc_suspended) {
drivers/mmc/host/msm_sdcc.c:			wake_lock(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc.c:		host->sdio_wakeupirq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client) {
drivers/mmc/host/msm_sdcc.c:		wake_lock(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc.c:		spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:	spin_unlock(&host->lock);
drivers/mmc/host/msm_sdcc.c:	pr_debug("%s: card_present %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	memset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));
drivers/mmc/host/msm_sdcc.c:	host->dma.host = host;
drivers/mmc/host/msm_sdcc.c:	host->dma.channel = -1;
drivers/mmc/host/msm_sdcc.c:	host->dma.crci = -1;
drivers/mmc/host/msm_sdcc.c:	if (!host->dmares)
drivers/mmc/host/msm_sdcc.c:	host->dma.nc = dma_alloc_coherent(NULL,
drivers/mmc/host/msm_sdcc.c:					  &host->dma.nc_busaddr,
drivers/mmc/host/msm_sdcc.c:	if (host->dma.nc == NULL) {
drivers/mmc/host/msm_sdcc.c:	memset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));
drivers/mmc/host/msm_sdcc.c:	host->dma.cmd_busaddr = host->dma.nc_busaddr;
drivers/mmc/host/msm_sdcc.c:	host->dma.cmdptr_busaddr = host->dma.nc_busaddr +
drivers/mmc/host/msm_sdcc.c:	host->dma.channel = host->dmares->start;
drivers/mmc/host/msm_sdcc.c:	host->dma.crci = host->dma_crci_res->start;
drivers/mmc/host/msm_sdcc.c:			   mmc_hostname(host->mmc), is_producer);
drivers/mmc/host/msm_sdcc.c:			" rc=%d", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		sps_config->source = host->sps.bam_handle;
drivers/mmc/host/msm_sdcc.c:		sps_config->destination = host->sps.bam_handle;
drivers/mmc/host/msm_sdcc.c:	sps_config->src_pipe_index = host->sps.src_pipe_index;
drivers/mmc/host/msm_sdcc.c:	sps_config->dest_pipe_index = host->sps.dest_pipe_index;
drivers/mmc/host/msm_sdcc.c:	sps_config->desc.base = dma_alloc_coherent(mmc_dev(host->mmc),
drivers/mmc/host/msm_sdcc.c:			, mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:			" rc=%d", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			" rc=%d", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		" desc_fifo.phys_base=0x%x\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	dma_free_coherent(mmc_dev(host->mmc),
drivers/mmc/host/msm_sdcc.c:	dma_free_coherent(mmc_dev(host->mmc),
drivers/mmc/host/msm_sdcc.c:			" rc=%d", mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:			" rc=%d", mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), __func__,
drivers/mmc/host/msm_sdcc.c:		host->sps.pipe_reset_pending = true;
drivers/mmc/host/msm_sdcc.c:		host->sps.reset_device = true;
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), (u32) sps_cb_case);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data) {
drivers/mmc/host/msm_sdcc.c:			host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:			if (host->sps.sg && is_sps_mode(host)) {
drivers/mmc/host/msm_sdcc.c:					mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:				"%s, line: %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	host->bam_base = ioremap(host->bam_memres->start,
drivers/mmc/host/msm_sdcc.c:				resource_size(host->bam_memres));
drivers/mmc/host/msm_sdcc.c:	if (!host->bam_base) {
drivers/mmc/host/msm_sdcc.c:			" size=0x%x", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			host->bam_memres->start,
drivers/mmc/host/msm_sdcc.c:			(host->bam_memres->end -
drivers/mmc/host/msm_sdcc.c:			host->bam_memres->start));
drivers/mmc/host/msm_sdcc.c:	bam.phys_addr = host->bam_memres->start;
drivers/mmc/host/msm_sdcc.c:	bam.virt_addr = host->bam_base;
drivers/mmc/host/msm_sdcc.c:	bam.irq = (u32)host->bam_irqres->start;
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: bam physical base=0x%x\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: bam virtual base=0x%x\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	rc = sps_register_bam_device(&bam, &host->sps.bam_handle);
drivers/mmc/host/msm_sdcc.c:			   mmc_hostname(host->mmc), rc);
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc), host->sps.bam_handle);
drivers/mmc/host/msm_sdcc.c:	host->sps.src_pipe_index = SPS_SDCC_PRODUCER_PIPE_INDEX;
drivers/mmc/host/msm_sdcc.c:	host->sps.dest_pipe_index = SPS_SDCC_CONSUMER_PIPE_INDEX;
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_init_ep_conn(host, &host->sps.prod,
drivers/mmc/host/msm_sdcc.c:	rc = msmsdcc_sps_init_ep_conn(host, &host->sps.cons,
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		(unsigned long long)host->bam_memres->start,
drivers/mmc/host/msm_sdcc.c:		(unsigned int)host->bam_irqres->start);
drivers/mmc/host/msm_sdcc.c:	msmsdcc_sps_exit_ep_conn(host, &host->sps.prod);
drivers/mmc/host/msm_sdcc.c:	sps_deregister_bam_device(host->sps.bam_handle);
drivers/mmc/host/msm_sdcc.c:	iounmap(host->bam_base);
drivers/mmc/host/msm_sdcc.c:	msmsdcc_sps_exit_ep_conn(host, &host->sps.cons);
drivers/mmc/host/msm_sdcc.c:	msmsdcc_sps_exit_ep_conn(host, &host->sps.prod);
drivers/mmc/host/msm_sdcc.c:	sps_deregister_bam_device(host->sps.bam_handle);
drivers/mmc/host/msm_sdcc.c:	iounmap(host->bam_base);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:	host->polling_enabled = mmc->caps & MMC_CAP_NEEDS_POLL;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->msm_bus_vote.is_max_bw_needed);
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->msm_bus_vote.is_max_bw_needed = !!value;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->en_auto_cmd19 = !!temp;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	return snprintf(buf, PAGE_SIZE, "%d\n", host->en_auto_cmd19);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIFI] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	host->polling_enabled = host->mmc->caps & MMC_CAP_NEEDS_POLL;
drivers/mmc/host/msm_sdcc.c:	host->mmc->caps &= ~MMC_CAP_NEEDS_POLL;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->polling_enabled) {
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->mmc->caps |= MMC_CAP_NEEDS_POLL;
drivers/mmc/host/msm_sdcc.c:		mmc_detect_change(host->mmc, 0);
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIFI] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:			pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	pr_err("%s: SDCC PWR is %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		(host->pwr ? "ON" : "OFF"));
drivers/mmc/host/msm_sdcc.c:		mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		(atomic_read(&host->clks_on) ? "ON" : "OFF"),
drivers/mmc/host/msm_sdcc.c:		(u32)clk_get_rate(host->clk));
drivers/mmc/host/msm_sdcc.c:	pr_err("%s: SDCC irq is %s\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		(host->sdcc_irq_disabled ? "disabled" : "enabled"));
drivers/mmc/host/msm_sdcc.c:	if (atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:		msmsdcc_print_regs("SDCC-CORE", host->base,
drivers/mmc/host/msm_sdcc.c:				   host->core_memres->start, 28);
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:			readl_relaxed(host->base + MCI_TEST_INPUT));
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data) {
drivers/mmc/host/msm_sdcc.c:		if (!msmsdcc_is_dma_possible(host, host->curr.data))
drivers/mmc/host/msm_sdcc.c:			pr_err("%s: PIO mode\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), host->dma.busy,
drivers/mmc/host/msm_sdcc.c:				host->dma.channel, host->dma.crci);
drivers/mmc/host/msm_sdcc.c:			if (host->sps.busy && atomic_read(&host->clks_on))
drivers/mmc/host/msm_sdcc.c:				msmsdcc_print_regs("SDCC-DML", host->dml_base,
drivers/mmc/host/msm_sdcc.c:						   host->dml_memres->start,
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), host->sps.busy);
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(host->mmc), host->curr.xfer_size,
drivers/mmc/host/msm_sdcc.c:			host->curr.data_xfered, host->curr.xfer_remain);
drivers/mmc/host/msm_sdcc.c:		" req_tout_ms=%d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		host->curr.got_dataend, host->prog_enable,
drivers/mmc/host/msm_sdcc.c:		host->curr.wait_for_auto_prog_done,
drivers/mmc/host/msm_sdcc.c:		host->curr.got_auto_prog_done, host->curr.req_tout_ms);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->dummy_52_sent) {
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		host->dummy_52_sent = 0;
drivers/mmc/host/msm_sdcc.c:	mrq = host->curr.mrq;
drivers/mmc/host/msm_sdcc.c:		pr_info("%s: CMD%d: Request timeout\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:		host->dummy_52_needed = 0;
drivers/mmc/host/msm_sdcc.c:		if (host->curr.data) {
drivers/mmc/host/msm_sdcc.c:			host->curr.data_xfered = 0;
drivers/mmc/host/msm_sdcc.c:			if (host->dma.sg && is_dma_mode(host)) {
drivers/mmc/host/msm_sdcc.c:				msm_dmov_flush(host->dma.channel, 0);
drivers/mmc/host/msm_sdcc.c:			} else if (host->sps.sg && is_sps_mode(host)) {
drivers/mmc/host/msm_sdcc.c:			host->prog_enable = 0;
drivers/mmc/host/msm_sdcc.c:			host->curr.wait_for_auto_prog_done = false;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host || !host->card)
drivers/mmc/host/msm_sdcc.c:	return sprintf(page, "%d", host->card->wr_perf);
drivers/mmc/host/msm_sdcc.c:	return sprintf(page, "%d", host->burst_mode);
drivers/mmc/host/msm_sdcc.c:	if (!host || !host->card || !host->card->mmcblk_dev)
drivers/mmc/host/msm_sdcc.c:	host->burst_mode = (buffer[0] == '0') ? 0 : 1;
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: %d\n", __func__, host->burst_mode);
drivers/mmc/host/msm_sdcc.c:	if (!host->burst_mode) {
drivers/mmc/host/msm_sdcc.c:	kobject_uevent_env(&host->card->mmcblk_dev->kobj, KOBJ_CHANGE, envp);
drivers/mmc/host/msm_sdcc.c:	return sprintf(page, "%d", host->bkops_trigger);
drivers/mmc/host/msm_sdcc.c:	host->bkops_trigger = value;
drivers/mmc/host/msm_sdcc.c:	host->pdev_id = pdev->id;
drivers/mmc/host/msm_sdcc.c:	host->plat = plat;
drivers/mmc/host/msm_sdcc.c:	host->mmc = mmc;
drivers/mmc/host/msm_sdcc.c:	host->curr.cmd = NULL;
drivers/mmc/host/msm_sdcc.c:	host->base = ioremap(core_memres->start,
drivers/mmc/host/msm_sdcc.c:	if (!host->base) {
drivers/mmc/host/msm_sdcc.c:	host->core_irqres = core_irqres;
drivers/mmc/host/msm_sdcc.c:	host->bam_irqres = bam_irqres;
drivers/mmc/host/msm_sdcc.c:	host->core_memres = core_memres;
drivers/mmc/host/msm_sdcc.c:	host->dml_memres = dml_memres;
drivers/mmc/host/msm_sdcc.c:	host->bam_memres = bam_memres;
drivers/mmc/host/msm_sdcc.c:	host->dmares = dmares;
drivers/mmc/host/msm_sdcc.c:	host->dma_crci_res = dma_crci_res;
drivers/mmc/host/msm_sdcc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/msm_sdcc.c:	mutex_init(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	mutex_init(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:	host->enable_t = ktime_get();
drivers/mmc/host/msm_sdcc.c:	host->disable_t = host->enable_t;
drivers/mmc/host/msm_sdcc.c:	host->rpm_sus_t = host->enable_t;
drivers/mmc/host/msm_sdcc.c:	host->rpm_res_t = host->enable_t;
drivers/mmc/host/msm_sdcc.c:	tasklet_init(&host->dma_tlet, msmsdcc_dma_complete_tlet,
drivers/mmc/host/msm_sdcc.c:	tasklet_init(&host->sps.tlet, msmsdcc_sps_complete_tlet,
drivers/mmc/host/msm_sdcc.c:		host->dma.channel = -1;
drivers/mmc/host/msm_sdcc.c:		host->dma.crci = -1;
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat) || is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	host->bus_clk = clk_get(&pdev->dev, "bus_clk");
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->bus_clk)) {
drivers/mmc/host/msm_sdcc.c:		ret = clk_set_rate(host->bus_clk, INT_MAX);
drivers/mmc/host/msm_sdcc.c:		ret = clk_prepare_enable(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:	host->pclk = clk_get(&pdev->dev, "iface_clk");
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR(host->pclk)) {
drivers/mmc/host/msm_sdcc.c:		ret = clk_prepare_enable(host->pclk);
drivers/mmc/host/msm_sdcc.c:		host->pclk_rate = clk_get_rate(host->pclk);
drivers/mmc/host/msm_sdcc.c:	host->clk = clk_get(&pdev->dev, "core_clk");
drivers/mmc/host/msm_sdcc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/msm_sdcc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/msm_sdcc.c:	ret = clk_set_rate(host->clk, msmsdcc_get_min_sup_clk_rate(host));
drivers/mmc/host/msm_sdcc.c:	ret = clk_prepare_enable(host->clk);
drivers/mmc/host/msm_sdcc.c:	host->clk_rate = clk_get_rate(host->clk);
drivers/mmc/host/msm_sdcc.c:	if (!host->clk_rate)
drivers/mmc/host/msm_sdcc.c:	host->reg_write_delay =
drivers/mmc/host/msm_sdcc.c:	atomic_set(&host->clks_on, 1);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->cpu_dma_latency)
drivers/mmc/host/msm_sdcc.c:		host->cpu_dma_latency = host->plat->cpu_dma_latency;
drivers/mmc/host/msm_sdcc.c:		host->cpu_dma_latency = MSM_MMC_DEFAULT_CPUDMA_LATENCY;
drivers/mmc/host/msm_sdcc.c:	pm_qos_add_request(&host->pm_qos_req_dma,
drivers/mmc/host/msm_sdcc.c:	if (host->msm_bus_vote.client_handle)
drivers/mmc/host/msm_sdcc.c:		INIT_DELAYED_WORK(&host->msm_bus_vote.vote_work,
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat) && (plat->status || plat->status_gpio) && plat->status_irq)
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat) || is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	if (plat->is_sdio_al_client || is_mmc_platform(host->plat) || is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_slot(host->plat) || is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_slot(host->plat)) {
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(MCI_CLEAR_STATIC_MASK, host->base + MMCICLEAR);
drivers/mmc/host/msm_sdcc.c:	writel_relaxed(MCI_IRQENABLE, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:	host->mci_irqenable = MCI_IRQENABLE;
drivers/mmc/host/msm_sdcc.c:	host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:		wake_lock_init(&host->sdio_wlock, WAKE_LOCK_SUSPEND,
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			if (!host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:				host->sdio_wakeupirq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->mpm_sdiowakeup_int) {
drivers/mmc/host/msm_sdcc.c:		wake_lock_init(&host->sdio_wlock, WAKE_LOCK_SUSPEND,
drivers/mmc/host/msm_sdcc.c:	wake_lock_init(&host->sdio_suspend_wlock, WAKE_LOCK_SUSPEND,
drivers/mmc/host/msm_sdcc.c:			host->oldstat = plat->status(mmc_dev(host->mmc));
drivers/mmc/host/msm_sdcc.c:			host->oldstat = msmsdcc_slot_status(host);
drivers/mmc/host/msm_sdcc.c:		host->eject = !host->oldstat;
drivers/mmc/host/msm_sdcc.c:	setup_timer(&host->req_tout_timer, msmsdcc_req_tout_timer_hdlr,
drivers/mmc/host/msm_sdcc.c:	host->early_suspend.suspend = msmsdcc_early_suspend;
drivers/mmc/host/msm_sdcc.c:	host->early_suspend.resume  = msmsdcc_late_resume;
drivers/mmc/host/msm_sdcc.c:	host->early_suspend.level   = EARLY_SUSPEND_LEVEL_DISABLE_FB;
drivers/mmc/host/msm_sdcc.c:	register_early_suspend(&host->early_suspend);
drivers/mmc/host/msm_sdcc.c:		(unsigned int) plat->status_irq, host->dma.channel,
drivers/mmc/host/msm_sdcc.c:		host->dma.crci);
drivers/mmc/host/msm_sdcc.c:			mmc_hostname(mmc), host->hw_caps);
drivers/mmc/host/msm_sdcc.c:		msmsdcc_get_max_sup_clk_rate(host), host->pclk_rate);
drivers/mmc/host/msm_sdcc.c:	       host->eject);
drivers/mmc/host/msm_sdcc.c:	if (is_dma_mode(host) && host->dma.channel != -1
drivers/mmc/host/msm_sdcc.c:			&& host->dma.crci != -1) {
drivers/mmc/host/msm_sdcc.c:		       mmc_hostname(mmc), host->dma.nc, host->dma.nc_busaddr);
drivers/mmc/host/msm_sdcc.c:		       mmc_hostname(mmc), host->dma.cmd_busaddr,
drivers/mmc/host/msm_sdcc.c:		       host->dma.cmdptr_busaddr);
drivers/mmc/host/msm_sdcc.c:	host->max_bus_bw.show = show_sdcc_to_mem_max_bus_bw;
drivers/mmc/host/msm_sdcc.c:	host->max_bus_bw.store = store_sdcc_to_mem_max_bus_bw;
drivers/mmc/host/msm_sdcc.c:	sysfs_attr_init(&host->max_bus_bw.attr);
drivers/mmc/host/msm_sdcc.c:	host->max_bus_bw.attr.name = "max_bus_bw";
drivers/mmc/host/msm_sdcc.c:	host->max_bus_bw.attr.mode = S_IRUGO | S_IWUSR;
drivers/mmc/host/msm_sdcc.c:	ret = device_create_file(&pdev->dev, &host->max_bus_bw);
drivers/mmc/host/msm_sdcc.c:		host->polling.show = show_polling;
drivers/mmc/host/msm_sdcc.c:		host->polling.store = store_polling;
drivers/mmc/host/msm_sdcc.c:		sysfs_attr_init(&host->polling.attr);
drivers/mmc/host/msm_sdcc.c:		host->polling.attr.name = "polling";
drivers/mmc/host/msm_sdcc.c:		host->polling.attr.mode = S_IRUGO | S_IWUSR;
drivers/mmc/host/msm_sdcc.c:		ret = device_create_file(&pdev->dev, &host->polling);
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		host->wr_perf_proc = create_proc_entry("emmc_wr_perf", 0444, NULL);
drivers/mmc/host/msm_sdcc.c:		if (host->wr_perf_proc) {
drivers/mmc/host/msm_sdcc.c:			host->wr_perf_proc->read_proc = msmsdcc_proc_wperf_show;
drivers/mmc/host/msm_sdcc.c:			host->wr_perf_proc->data = (void *) host->mmc;
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		host->burst_proc = create_proc_entry("emmc_burst", 0664, NULL);
drivers/mmc/host/msm_sdcc.c:		if (host->burst_proc) {
drivers/mmc/host/msm_sdcc.c:			host->burst_proc->read_proc = msmsdcc_proc_burst_show;
drivers/mmc/host/msm_sdcc.c:			host->burst_proc->write_proc = msmsdcc_proc_burst_set;
drivers/mmc/host/msm_sdcc.c:			host->burst_proc->data = (void *) host->mmc;
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		host->bkops_proc = create_proc_entry("emmc_bkops", 0664, NULL);
drivers/mmc/host/msm_sdcc.c:		if (host->bkops_proc) {
drivers/mmc/host/msm_sdcc.c:			host->bkops_proc->read_proc = msmsdcc_proc_bkops_show;
drivers/mmc/host/msm_sdcc.c:			host->bkops_proc->write_proc = msmsdcc_proc_bkops_set;
drivers/mmc/host/msm_sdcc.c:			host->bkops_proc->data = (void *) host->mmc;
drivers/mmc/host/msm_sdcc.c:				mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:	host->auto_cmd19_attr.show = show_enable_auto_cmd19;
drivers/mmc/host/msm_sdcc.c:	host->auto_cmd19_attr.store = store_enable_auto_cmd19;
drivers/mmc/host/msm_sdcc.c:	sysfs_attr_init(&host->auto_cmd19_attr.attr);
drivers/mmc/host/msm_sdcc.c:	host->auto_cmd19_attr.attr.name = "enable_auto_cmd19";
drivers/mmc/host/msm_sdcc.c:	host->auto_cmd19_attr.attr.mode = S_IRUGO | S_IWUSR;
drivers/mmc/host/msm_sdcc.c:	ret = device_create_file(&pdev->dev, &host->auto_cmd19_attr);
drivers/mmc/host/msm_sdcc.c:	device_remove_file(&pdev->dev, &host->polling);
drivers/mmc/host/msm_sdcc.c:	device_remove_file(&pdev->dev, &host->max_bus_bw);
drivers/mmc/host/msm_sdcc.c:	del_timer_sync(&host->req_tout_timer);
drivers/mmc/host/msm_sdcc.c:	wake_lock_destroy(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:		wake_lock_destroy(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc.c:	clk_disable(host->clk);
drivers/mmc/host/msm_sdcc.c:	if (host->cpu_dma_latency)
drivers/mmc/host/msm_sdcc.c:		pm_qos_remove_request(&host->pm_qos_req_dma);
drivers/mmc/host/msm_sdcc.c:	clk_put(host->clk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR(host->pclk))
drivers/mmc/host/msm_sdcc.c:		clk_disable_unprepare(host->pclk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR(host->pclk))
drivers/mmc/host/msm_sdcc.c:		clk_put(host->pclk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->bus_clk))
drivers/mmc/host/msm_sdcc.c:		clk_disable_unprepare(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->bus_clk))
drivers/mmc/host/msm_sdcc.c:		clk_put(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:		if (host->dmares)
drivers/mmc/host/msm_sdcc.c:				host->dma.nc, host->dma.nc_busaddr);
drivers/mmc/host/msm_sdcc.c:	iounmap(host->base);
drivers/mmc/host/msm_sdcc.c:	plat = host->plat;
drivers/mmc/host/msm_sdcc.c:		device_remove_file(&pdev->dev, &host->auto_cmd19_attr);
drivers/mmc/host/msm_sdcc.c:	device_remove_file(&pdev->dev, &host->max_bus_bw);
drivers/mmc/host/msm_sdcc.c:		device_remove_file(&pdev->dev, &host->polling);
drivers/mmc/host/msm_sdcc.c:	del_timer_sync(&host->req_tout_timer);
drivers/mmc/host/msm_sdcc.c:	tasklet_kill(&host->dma_tlet);
drivers/mmc/host/msm_sdcc.c:	tasklet_kill(&host->sps.tlet);
drivers/mmc/host/msm_sdcc.c:	wake_lock_destroy(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:		wake_lock_destroy(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc.c:	free_irq(host->core_irqres->start, host);
drivers/mmc/host/msm_sdcc.c:	free_irq(host->core_irqres->start, host);
drivers/mmc/host/msm_sdcc.c:	clk_put(host->clk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR(host->pclk))
drivers/mmc/host/msm_sdcc.c:		clk_put(host->pclk);
drivers/mmc/host/msm_sdcc.c:	if (!IS_ERR_OR_NULL(host->bus_clk))
drivers/mmc/host/msm_sdcc.c:		clk_put(host->bus_clk);
drivers/mmc/host/msm_sdcc.c:	if (host->cpu_dma_latency)
drivers/mmc/host/msm_sdcc.c:		pm_qos_remove_request(&host->pm_qos_req_dma);
drivers/mmc/host/msm_sdcc.c:	if (host->msm_bus_vote.client_handle) {
drivers/mmc/host/msm_sdcc.c:		if (host->dmares)
drivers/mmc/host/msm_sdcc.c:					host->dma.nc, host->dma.nc_busaddr);
drivers/mmc/host/msm_sdcc.c:	iounmap(host->base);
drivers/mmc/host/msm_sdcc.c:	unregister_early_suspend(&host->early_suspend);
drivers/mmc/host/msm_sdcc.c:	if (host->wr_perf_proc)
drivers/mmc/host/msm_sdcc.c:	if (host->burst_proc)
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		if (!host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(0, host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			disable_irq_nosync(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:		if (host->plat->sdio_lpm_gpio_setup &&
drivers/mmc/host/msm_sdcc.c:				!host->sdio_gpio_lpm) {
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->plat->sdio_lpm_gpio_setup(mmc_dev(mmc), 0);
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->sdio_gpio_lpm = 1;
drivers/mmc/host/msm_sdcc.c:		if (host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:			enable_irq(host->plat->sdiowakeup_irq);
drivers/mmc/host/msm_sdcc.c:			host->sdio_wakeupirq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:		if (!host->sdio_wakeupirq_disabled) {
drivers/mmc/host/msm_sdcc.c:			disable_irq_nosync(host->plat->sdiowakeup_irq);
drivers/mmc/host/msm_sdcc.c:			host->sdio_wakeupirq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:		if (host->plat->sdio_lpm_gpio_setup &&
drivers/mmc/host/msm_sdcc.c:				host->sdio_gpio_lpm) {
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->plat->sdio_lpm_gpio_setup(mmc_dev(mmc), 1);
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->sdio_gpio_lpm = 0;
drivers/mmc/host/msm_sdcc.c:		if (host->sdcc_irq_disabled && atomic_read(&host->clks_on)) {
drivers/mmc/host/msm_sdcc.c:			writel_relaxed(host->mci_irqenable,
drivers/mmc/host/msm_sdcc.c:				       host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:			enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:	mmc->ios.clock = host->clk_rate;
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/msm_sdcc.c:	mmc->ios.clock = host->clk_rate;
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client) {
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspending = 1;
drivers/mmc/host/msm_sdcc.c:			if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:					wimax_disable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:			if (!is_wifi_slot(host->plat) && !is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:				pr_info("[MMC] %s: %s mmc_suspend_host\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:			if (!is_wifi_slot(host->plat)) {
drivers/mmc/host/msm_sdcc.c:				if (!rc && is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_suspended = true;
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspending = 0;
drivers/mmc/host/msm_sdcc.c:		if (rc && wake_lock_active(&host->sdio_suspend_wlock))
drivers/mmc/host/msm_sdcc.c:			wake_unlock(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		printk(KERN_DEBUG "[WIFI] [MMC] %s: %s enter,", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s msmsdcc_ungate_clock 2\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		writel_relaxed(host->mci_irqenable | host->cmd_pio_irqmask,
drivers/mmc/host/msm_sdcc.c:							host->base + MMCIMASK0);
drivers/mmc/host/msm_sdcc.c:		if (!is_wifi_slot(host->plat) && !is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			pr_info("[MMC] %s: %s mmc_resume_host\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		if (!is_wifi_slot(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspended = false;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			if ((host->plat->mpm_sdiowakeup_int ||
drivers/mmc/host/msm_sdcc.c:					host->plat->sdiowakeup_irq) &&
drivers/mmc/host/msm_sdcc.c:					wake_lock_active(&host->sdio_wlock))
drivers/mmc/host/msm_sdcc.c:				wake_lock_timeout(&host->sdio_wlock, 1);
drivers/mmc/host/msm_sdcc.c:		wake_unlock(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:				wimax_enable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->curr.mrq) {
drivers/mmc/host/msm_sdcc.c:		WARN(host->curr.mrq, "Request in progress\n");
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (!host->sdcc_irq_disabled && host->mmc->card) {
drivers/mmc/host/msm_sdcc.c:		disable_irq_nosync(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	if (host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:		enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:	mutex_lock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	mutex_unlock(&host->clk_mutex);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client) {
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		mutex_lock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (host->curr.mrq) {
drivers/mmc/host/msm_sdcc.c:			mutex_unlock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:		if (is_mmc_platform(host->plat) && host->curr.mrq) {
drivers/mmc/host/msm_sdcc.c:    	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:    	    if (mmc->card && mmc_card_sdio(mmc->card) && host->is_runtime_resumed)
drivers/mmc/host/msm_sdcc.c:		if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:			if (mmc->card && mmc_card_sdio(mmc->card) && host->is_runtime_resumed_wimax)
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat)&& mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		if (is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspending = 1;
drivers/mmc/host/msm_sdcc.c:			if (!is_wifi_slot(host->plat) && !is_sd_platform(host->plat) && !is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			if (!is_wifi_slot(host->plat) && !is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:				pr_info("[MMC] %s: %s mmc_suspend_host\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			host->sdcc_suspended = true;
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:				if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:					host->rpm_sus_t = ktime_get();
drivers/mmc/host/msm_sdcc.c:				spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:				if (mmc_card_sd(mmc->card) && !host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:					disable_irq_nosync(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:					host->sdcc_irq_disabled = 1;
drivers/mmc/host/msm_sdcc.c:					spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:					synchronize_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:					spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:				spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspending = 0;
drivers/mmc/host/msm_sdcc.c:		if (rc && wake_lock_active(&host->sdio_suspend_wlock))
drivers/mmc/host/msm_sdcc.c:			wake_unlock(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		mutex_unlock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:	if (is_wifi_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		host->is_runtime_resumed = true;
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		host->is_runtime_resumed_wimax = true;
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		mutex_lock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:    	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:			if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:				host->rpm_res_t = ktime_get();
drivers/mmc/host/msm_sdcc.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			if (mmc_card_sd(mmc->card) && host->sdcc_irq_disabled) {
drivers/mmc/host/msm_sdcc.c:				enable_irq(host->core_irqres->start);
drivers/mmc/host/msm_sdcc.c:				host->sdcc_irq_disabled = 0;
drivers/mmc/host/msm_sdcc.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		if (!is_wifi_slot(host->plat) && !is_sd_platform(host->plat) && !is_wimax_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:		if (!is_wifi_slot(host->plat) && !is_sd_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:			pr_info("[MMC] %s: %s mmc_suspend_host\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:		host->sdcc_suspended = false;
drivers/mmc/host/msm_sdcc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/msm_sdcc.c:			if ((host->plat->mpm_sdiowakeup_int ||
drivers/mmc/host/msm_sdcc.c:					host->plat->sdiowakeup_irq) &&
drivers/mmc/host/msm_sdcc.c:					wake_lock_active(&host->sdio_wlock))
drivers/mmc/host/msm_sdcc.c:				wake_lock_timeout(&host->sdio_wlock, 1);
drivers/mmc/host/msm_sdcc.c:		wake_unlock(&host->sdio_suspend_wlock);
drivers/mmc/host/msm_sdcc.c:	if (is_sd_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:		mutex_unlock(&host->rpm_mutex);
drivers/mmc/host/msm_sdcc.c:    	if (is_wifi_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:    		host->is_runtime_resumed = false;
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		host->is_runtime_resumed_wimax = false;
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	else if (is_wimax_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter , return!\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (!is_mmc_platform(host->plat) || !mmc->card || !mmc->card->ext_csd.bkops_en) {
drivers/mmc/host/msm_sdcc.c:		if (is_mmc_platform(host->plat) && mmc->card) {
drivers/mmc/host/msm_sdcc.c:			pr_info("%s: %s leave (bkops_en %d)\n", mmc_hostname(host->mmc), __func__, mmc->card->ext_csd.bkops_en);
drivers/mmc/host/msm_sdcc.c:		pr_info("%s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:				pr_info("%s: bkops already start\n", mmc_hostname(host->mmc));
drivers/mmc/host/msm_sdcc.c:		pr_info("%s: bkops remain %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: %s leave err = %d\n", mmc_hostname(host->mmc), __func__, err);
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: %s enter\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:		if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:				wimax_enable_irq(host->mmc);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status()) {
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s enter, return!!\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_mmc_platform(host->plat)) {
drivers/mmc/host/msm_sdcc.c:						pr_info("%s: %s suspend_host fail\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:						pr_info("%s: %s suspend_host success\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:				pr_info("%s: %s mmc_bkops_resume_task fail\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	pr_info("%s: %s leave\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s ...\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:	if (!is_sd_platform(host->plat) && host->plat->status_irq)
drivers/mmc/host/msm_sdcc.c:		disable_irq(host->plat->status_irq);
drivers/mmc/host/msm_sdcc.c:	if (!pm_runtime_suspended(dev) || is_sd_platform(host->plat) || is_mmc_platform(host->plat))
drivers/mmc/host/msm_sdcc.c:	if (atomic_read(&host->clks_on) && !host->plat->is_sdio_al_client) {
drivers/mmc/host/msm_sdcc.c:	if (is_wimax_platform(host->plat) && mmc_wimax_get_status())
drivers/mmc/host/msm_sdcc.c:		pr_info("[WIMAX] [MMC] %s: %s ...\n", mmc_hostname(host->mmc), __func__);
drivers/mmc/host/msm_sdcc.c:	if (host->plat->is_sdio_al_client)
drivers/mmc/host/msm_sdcc.c:		host->pending_resume = true;
drivers/mmc/host/msm_sdcc.c:		host->pending_resume = true;
drivers/mmc/host/msm_sdcc.c:	if (!is_sd_platform(host->plat) && host->plat->status_irq) {
drivers/mmc/host/msm_sdcc.c:		enable_irq(host->plat->status_irq);
drivers/mmc/host/msm_sdcc.c:	i += scnprintf(buf + i, max - i, "STAT: %p %p %p\n", host->curr.mrq,
drivers/mmc/host/msm_sdcc.c:		       host->curr.cmd, host->curr.data);
drivers/mmc/host/msm_sdcc.c:	if (host->curr.cmd) {
drivers/mmc/host/msm_sdcc.c:		struct mmc_command *cmd = host->curr.cmd;
drivers/mmc/host/msm_sdcc.c:	if (host->curr.data) {
drivers/mmc/host/msm_sdcc.c:		struct mmc_data *data = host->curr.data;
drivers/mmc/host/msm_sdcc.c:			      host->curr.xfer_size, host->curr.xfer_remain,
drivers/mmc/host/msm_sdcc.c:			      host->curr.data_xfered, host->dma.sg);
drivers/mmc/host/msm_sdcc.c:		debugfs_file = debugfs_create_file(mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc.h:	version = readl_relaxed(host->base + MCI_VERSION);
drivers/mmc/host/msm_sdcc.h:	pr_info("%s: SDCC Version: 0x%.8x\n", mmc_hostname(host->mmc), version);
drivers/mmc/host/msm_sdcc.h:		host->hw_caps |= MSMSDCC_AUTO_PROG_DONE |
drivers/mmc/host/msm_sdcc.h:		host->hw_caps |= MSMSDCC_SW_RST | MSMSDCC_SW_RST_CFG;
drivers/mmc/host/msm_sdcc.h:	wake_unlock(&host->sdio_wlock);
drivers/mmc/host/msm_sdcc_dml.c:	if (!host->dml_base) {
drivers/mmc/host/msm_sdcc_dml.c:		host->dml_base = ioremap(host->dml_memres->start,
drivers/mmc/host/msm_sdcc_dml.c:					resource_size(host->dml_memres));
drivers/mmc/host/msm_sdcc_dml.c:		if (!host->dml_base) {
drivers/mmc/host/msm_sdcc_dml.c:				" size=0x%x", mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc_dml.c:				host->dml_memres->start,
drivers/mmc/host/msm_sdcc_dml.c:				(host->dml_memres->end -
drivers/mmc/host/msm_sdcc_dml.c:				host->dml_memres->start));
drivers/mmc/host/msm_sdcc_dml.c:			mmc_hostname(host->mmc),
drivers/mmc/host/msm_sdcc_dml.c:			(unsigned long long)host->dml_memres->start);
drivers/mmc/host/msm_sdcc_dml.c:	dml_base = host->dml_base;
drivers/mmc/host/msm_sdcc_dml.c:	writel_relaxed(host->sps.src_pipe_index |
drivers/mmc/host/msm_sdcc_dml.c:		(host->sps.dest_pipe_index << CONSUMER_PIPE_ID_SHFT),
drivers/mmc/host/msm_sdcc_dml.c:	writel_relaxed(1, (host->dml_base + DML_SW_RESET));
drivers/mmc/host/msm_sdcc_dml.c:	return !(readl_relaxed(host->dml_base + DML_STATUS) & PRODUCER_IDLE) ||
drivers/mmc/host/msm_sdcc_dml.c:		!(readl_relaxed(host->dml_base + DML_STATUS) & CONSUMER_IDLE);
drivers/mmc/host/msm_sdcc_dml.c:	void __iomem *dml_base = host->dml_base;
drivers/mmc/host/msm_sdcc_dml.c:		writel_relaxed(host->curr.xfer_size,
drivers/mmc/host/msm_sdcc_dml.c:	iounmap(host->dml_base);
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:				dev_warn(host->dev, "FIFO_EMPTY bit missing\n");
drivers/mmc/host/mvsdio.c:		dev_dbg(host->dev, "*** wait for FIFO_EMPTY bit "
drivers/mmc/host/mvsdio.c:	tmout = DIV_ROUND_UP(data->timeout_ns, host->ns_per_clk);
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "data %s at 0x%08x: blocks=%d blksz=%d tmout=%u (%d)\n",
drivers/mmc/host/mvsdio.c:	host->ctrl &= ~MVSD_HOST_CTRL_TMOUT_MASK;
drivers/mmc/host/mvsdio.c:	host->ctrl |= MVSD_HOST_CTRL_TMOUT(tmout_index);
drivers/mmc/host/mvsdio.c:	mvsd_write(MVSD_HOST_CTRL, host->ctrl);
drivers/mmc/host/mvsdio.c:		host->pio_size = data->blocks * data->blksz;
drivers/mmc/host/mvsdio.c:		host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/mvsdio.c:					  mmc_hostname(host->mmc),
drivers/mmc/host/mvsdio.c:					  host->pio_ptr, host->pio_size);
drivers/mmc/host/mvsdio.c:		host->sg_frags = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/mvsdio.c:	host->mrq = mrq;
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "cmd %d (hw state 0x%04x)\n",
drivers/mmc/host/mvsdio.c:			else if (host->pio_size > 32)
drivers/mmc/host/mvsdio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:	host->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:	host->xfer_mode |= xfer;
drivers/mmc/host/mvsdio.c:	mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:	host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:	host->intr_en |= intr | MVSD_NOR_ERROR;
drivers/mmc/host/mvsdio.c:	mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:	mod_timer(&host->timer, jiffies + 5 * HZ);
drivers/mmc/host/mvsdio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	if (host->pio_ptr) {
drivers/mmc/host/mvsdio.c:		host->pio_ptr = NULL;
drivers/mmc/host/mvsdio.c:		host->pio_size = 0;
drivers/mmc/host/mvsdio.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_frags,
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "data done: blocks_left=%d, bytes_left=%d\n",
drivers/mmc/host/mvsdio.c:			dev_dbg(host->dev, "c12err 0x%04x\n", err_cmd12);
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "intr 0x%04x intr_en 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:	spin_lock(&host->lock);
drivers/mmc/host/mvsdio.c:	if (host->pio_size &&
drivers/mmc/host/mvsdio.c:	    (intr_status & host->intr_en &
drivers/mmc/host/mvsdio.c:		u16 *p = host->pio_ptr;
drivers/mmc/host/mvsdio.c:		int s = host->pio_size;
drivers/mmc/host/mvsdio.c:				host->intr_en &=
drivers/mmc/host/mvsdio.c:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:			} else if (host->intr_en & MVSD_NOR_RX_FIFO_8W) {
drivers/mmc/host/mvsdio.c:				host->intr_en &= ~MVSD_NOR_RX_FIFO_8W;
drivers/mmc/host/mvsdio.c:				host->intr_en |= MVSD_NOR_RX_READY;
drivers/mmc/host/mvsdio.c:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:		dev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:		host->pio_ptr = p;
drivers/mmc/host/mvsdio.c:		host->pio_size = s;
drivers/mmc/host/mvsdio.c:	} else if (host->pio_size &&
drivers/mmc/host/mvsdio.c:		   (intr_status & host->intr_en &
drivers/mmc/host/mvsdio.c:		u16 *p = host->pio_ptr;
drivers/mmc/host/mvsdio.c:		int s = host->pio_size;
drivers/mmc/host/mvsdio.c:				host->intr_en &=
drivers/mmc/host/mvsdio.c:				mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:		dev_dbg(host->dev, "pio %d intr 0x%04x hw_state 0x%04x\n",
drivers/mmc/host/mvsdio.c:		host->pio_ptr = p;
drivers/mmc/host/mvsdio.c:		host->pio_size = s;
drivers/mmc/host/mvsdio.c:	if (intr_status & host->intr_en & ~intr_done_mask) {
drivers/mmc/host/mvsdio.c:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/mvsdio.c:		del_timer(&host->timer);
drivers/mmc/host/mvsdio.c:		host->mrq = NULL;
drivers/mmc/host/mvsdio.c:		host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:		mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:		spin_unlock(&host->lock);
drivers/mmc/host/mvsdio.c:			dev_dbg(host->dev, "err 0x%04x\n", err_status);
drivers/mmc/host/mvsdio.c:					mmc_hostname(host->mmc), err_status);
drivers/mmc/host/mvsdio.c:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mvsdio.c:		spin_unlock(&host->lock);
drivers/mmc/host/mvsdio.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mvsdio.c:			"pio=%d\n", mmc_hostname(host->mmc), intr_status,
drivers/mmc/host/mvsdio.c:			host->intr_en, host->pio_size);
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:	mrq = host->mrq;
drivers/mmc/host/mvsdio.c:				mmc_hostname(host->mmc));
drivers/mmc/host/mvsdio.c:				"intr_en=0x%04x\n", mmc_hostname(host->mmc),
drivers/mmc/host/mvsdio.c:		host->mrq = NULL;
drivers/mmc/host/mvsdio.c:		host->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:		mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:		host->intr_en &= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:		mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mvsdio.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mvsdio.c:		host->xfer_mode |= MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:		host->intr_en |= MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:		host->xfer_mode &= ~MVSD_XFER_MODE_INT_CHK_EN;
drivers/mmc/host/mvsdio.c:		host->intr_en &= ~MVSD_NOR_CARD_INT;
drivers/mmc/host/mvsdio.c:	mvsd_write(MVSD_XFER_MODE, host->xfer_mode);
drivers/mmc/host/mvsdio.c:	mvsd_write(MVSD_NOR_INTR_EN, host->intr_en);
drivers/mmc/host/mvsdio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mvsdio.c:	if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:		return gpio_get_value(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "power up\n");
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "power down\n");
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:		host->clock = 0;
drivers/mmc/host/mvsdio.c:		dev_dbg(host->dev, "clock off\n");
drivers/mmc/host/mvsdio.c:	} else if (ios->clock != host->clock) {
drivers/mmc/host/mvsdio.c:		u32 m = DIV_ROUND_UP(host->base_clock, ios->clock) - 1;
drivers/mmc/host/mvsdio.c:		host->clock = ios->clock;
drivers/mmc/host/mvsdio.c:		host->ns_per_clk = 1000000000 / (host->base_clock / (m+1));
drivers/mmc/host/mvsdio.c:		dev_dbg(host->dev, "clock=%d (%d), div=0x%04x\n",
drivers/mmc/host/mvsdio.c:			ios->clock, host->base_clock / (m+1), m);
drivers/mmc/host/mvsdio.c:	host->ctrl = ctrl_reg;
drivers/mmc/host/mvsdio.c:	dev_dbg(host->dev, "ctrl 0x%04x: %s %s %s\n", ctrl_reg,
drivers/mmc/host/mvsdio.c:	void __iomem *iobase = host->base;
drivers/mmc/host/mvsdio.c:	host->mmc = mmc;
drivers/mmc/host/mvsdio.c:	host->dev = &pdev->dev;
drivers/mmc/host/mvsdio.c:	host->res = r;
drivers/mmc/host/mvsdio.c:	host->base_clock = mvsd_data->clock / 2;
drivers/mmc/host/mvsdio.c:	mmc->f_min = DIV_ROUND_UP(host->base_clock, MVSD_BASE_DIV_MAX);
drivers/mmc/host/mvsdio.c:	spin_lock_init(&host->lock);
drivers/mmc/host/mvsdio.c:	host->base = ioremap(r->start, SZ_4K);
drivers/mmc/host/mvsdio.c:	if (!host->base) {
drivers/mmc/host/mvsdio.c:		host->irq = irq;
drivers/mmc/host/mvsdio.c:				host->gpio_card_detect =
drivers/mmc/host/mvsdio.c:	if (!host->gpio_card_detect)
drivers/mmc/host/mvsdio.c:			host->gpio_write_protect =
drivers/mmc/host/mvsdio.c:	setup_timer(&host->timer, mvsd_timeout_timer, (unsigned long)host);
drivers/mmc/host/mvsdio.c:	if (host->gpio_card_detect)
drivers/mmc/host/mvsdio.c:		       host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:		if (host->irq)
drivers/mmc/host/mvsdio.c:			free_irq(host->irq, host);
drivers/mmc/host/mvsdio.c:		if (host->gpio_card_detect) {
drivers/mmc/host/mvsdio.c:			free_irq(gpio_to_irq(host->gpio_card_detect), host);
drivers/mmc/host/mvsdio.c:			gpio_free(host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:		if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:			gpio_free(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:		if (host->base)
drivers/mmc/host/mvsdio.c:			iounmap(host->base);
drivers/mmc/host/mvsdio.c:		if (host->gpio_card_detect) {
drivers/mmc/host/mvsdio.c:			free_irq(gpio_to_irq(host->gpio_card_detect), host);
drivers/mmc/host/mvsdio.c:			gpio_free(host->gpio_card_detect);
drivers/mmc/host/mvsdio.c:		free_irq(host->irq, host);
drivers/mmc/host/mvsdio.c:		if (host->gpio_write_protect)
drivers/mmc/host/mvsdio.c:			gpio_free(host->gpio_write_protect);
drivers/mmc/host/mvsdio.c:		del_timer_sync(&host->timer);
drivers/mmc/host/mvsdio.c:		iounmap(host->base);
drivers/mmc/host/mvsdio.c:		release_resource(host->res);
drivers/mmc/host/mxcmmc.c:	host->vcc = regulator_get(mmc_dev(host->mmc), "vmmc");
drivers/mmc/host/mxcmmc.c:	if (IS_ERR(host->vcc)) {
drivers/mmc/host/mxcmmc.c:		host->vcc = NULL;
drivers/mmc/host/mxcmmc.c:		host->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);
drivers/mmc/host/mxcmmc.c:		if (host->pdata && host->pdata->ocr_avail)
drivers/mmc/host/mxcmmc.c:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:	if (host->vcc == NULL) {
drivers/mmc/host/mxcmmc.c:		if (host->pdata && host->pdata->ocr_avail)
drivers/mmc/host/mxcmmc.c:			host->mmc->ocr_avail = host->pdata->ocr_avail;
drivers/mmc/host/mxcmmc.c:			host->mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
drivers/mmc/host/mxcmmc.c:	if (host->vcc) {
drivers/mmc/host/mxcmmc.c:			mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);
drivers/mmc/host/mxcmmc.c:			mmc_regulator_set_ocr(host->mmc, host->vcc, 0);
drivers/mmc/host/mxcmmc.c:	if (host->pdata && host->pdata->setpower)
drivers/mmc/host/mxcmmc.c:		host->pdata->setpower(mmc_dev(host->mmc), vdd);
drivers/mmc/host/mxcmmc.c:	return host->do_dma;
drivers/mmc/host/mxcmmc.c:	dev_dbg(mmc_dev(host->mmc), "mxcmci_softreset\n");
drivers/mmc/host/mxcmmc.c:	writew(STR_STP_CLK_RESET, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:			host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:	writew(0xff, host->base + MMC_REG_RES_TO);
drivers/mmc/host/mxcmmc.c:	host->data = data;
drivers/mmc/host/mxcmmc.c:	writew(nob, host->base + MMC_REG_NOB);
drivers/mmc/host/mxcmmc.c:	writew(blksz, host->base + MMC_REG_BLK_LEN);
drivers/mmc/host/mxcmmc.c:	host->datasize = datasize;
drivers/mmc/host/mxcmmc.c:			host->do_dma = 0;
drivers/mmc/host/mxcmmc.c:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/mxcmmc.c:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/mxcmmc.c:	nents = dma_map_sg(host->dma->device->dev, data->sg,
drivers/mmc/host/mxcmmc.c:				     data->sg_len,  host->dma_dir);
drivers/mmc/host/mxcmmc.c:	host->desc = dmaengine_prep_slave_sg(host->dma,
drivers/mmc/host/mxcmmc.c:	if (!host->desc) {
drivers/mmc/host/mxcmmc.c:		dma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,
drivers/mmc/host/mxcmmc.c:				host->dma_dir);
drivers/mmc/host/mxcmmc.c:		host->do_dma = 0;
drivers/mmc/host/mxcmmc.c:	dmaengine_submit(host->desc);
drivers/mmc/host/mxcmmc.c:	dma_async_issue_pending(host->dma);
drivers/mmc/host/mxcmmc.c:	u32 int_cntr = host->default_irq_mask;
drivers/mmc/host/mxcmmc.c:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/mxcmmc.c:	host->cmd = cmd;
drivers/mmc/host/mxcmmc.c:		dev_err(mmc_dev(host->mmc), "unhandled response type 0x%x\n",
drivers/mmc/host/mxcmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	if (host->use_sdio)
drivers/mmc/host/mxcmmc.c:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	writew(cmd->opcode, host->base + MMC_REG_CMD);
drivers/mmc/host/mxcmmc.c:	writel(cmd->arg, host->base + MMC_REG_ARG);
drivers/mmc/host/mxcmmc.c:	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
drivers/mmc/host/mxcmmc.c:	u32 int_cntr = host->default_irq_mask;
drivers/mmc/host/mxcmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	if (host->use_sdio)
drivers/mmc/host/mxcmmc.c:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	host->req = NULL;
drivers/mmc/host/mxcmmc.c:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:	host->data = NULL;
drivers/mmc/host/mxcmmc.c:	mmc_request_done(host->mmc, req);
drivers/mmc/host/mxcmmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mxcmmc.c:		dmaengine_terminate_all(host->dma);
drivers/mmc/host/mxcmmc.c:		dma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,
drivers/mmc/host/mxcmmc.c:				host->dma_dir);
drivers/mmc/host/mxcmmc.c:		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",
drivers/mmc/host/mxcmmc.c:			dev_err(mmc_dev(host->mmc), "%s: -EILSEQ\n", __func__);
drivers/mmc/host/mxcmmc.c:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:			dev_err(mmc_dev(host->mmc), "%s: -EIO\n", __func__);
drivers/mmc/host/mxcmmc.c:		data->bytes_xfered = host->datasize;
drivers/mmc/host/mxcmmc.c:	host->data = NULL;
drivers/mmc/host/mxcmmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxcmmc.c:		dev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");
drivers/mmc/host/mxcmmc.c:		dev_dbg(mmc_dev(host->mmc), "cmd crc error\n");
drivers/mmc/host/mxcmmc.c:				a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:				b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:			a = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:			b = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:			c = readw(host->base + MMC_REG_RES_FIFO);
drivers/mmc/host/mxcmmc.c:		stat = readl(host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:			mxcmci_set_clk_rate(host, host->clock);
drivers/mmc/host/mxcmmc.c:		*buf++ = readl(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:		tmp = readl(host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:		writel(*buf++, host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:		writel(tmp, host->base + MMC_REG_BUFFER_ACCESS);
drivers/mmc/host/mxcmmc.c:	struct mmc_data *data = host->req->data;
drivers/mmc/host/mxcmmc.c:	host->data = data;
drivers/mmc/host/mxcmmc.c:	host->datasize = 0;
drivers/mmc/host/mxcmmc.c:			host->datasize += sg->length;
drivers/mmc/host/mxcmmc.c:			host->datasize += sg->length;
drivers/mmc/host/mxcmmc.c:		host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:	if (host->req->stop) {
drivers/mmc/host/mxcmmc.c:		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
drivers/mmc/host/mxcmmc.c:			mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mxcmmc.c:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:	if (host->req->stop) {
drivers/mmc/host/mxcmmc.c:		if (mxcmci_start_cmd(host, host->req->stop, 0)) {
drivers/mmc/host/mxcmmc.c:			mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:	host->cmd = NULL;
drivers/mmc/host/mxcmmc.c:	if (!host->data && host->req) {
drivers/mmc/host/mxcmmc.c:		mxcmci_finish_request(host, host->req);
drivers/mmc/host/mxcmmc.c:	if (!mxcmci_use_dma(host) && host->data)
drivers/mmc/host/mxcmmc.c:		schedule_work(&host->datawork);
drivers/mmc/host/mxcmmc.c:	stat = readl(host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:			STATUS_WRITE_OP_DONE), host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:	dev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);
drivers/mmc/host/mxcmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	sdio_irq = (stat & STATUS_SDIO_INT_ACTIVE) && host->use_sdio;
drivers/mmc/host/mxcmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:			host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:		writel(STATUS_SDIO_INT_ACTIVE, host->base + MMC_REG_STATUS);
drivers/mmc/host/mxcmmc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mxcmmc.c:	if (host->default_irq_mask &&
drivers/mmc/host/mxcmmc.c:		mmc_detect_change(host->mmc, msecs_to_jiffies(200));
drivers/mmc/host/mxcmmc.c:	unsigned int cmdat = host->cmdat;
drivers/mmc/host/mxcmmc.c:	WARN_ON(host->req != NULL);
drivers/mmc/host/mxcmmc.c:	host->req = req;
drivers/mmc/host/mxcmmc.c:	host->cmdat &= ~CMD_DAT_CONT_INIT;
drivers/mmc/host/mxcmmc.c:	if (host->dma)
drivers/mmc/host/mxcmmc.c:		host->do_dma = 1;
drivers/mmc/host/mxcmmc.c:	unsigned int clk_in = clk_get_rate(host->clk);
drivers/mmc/host/mxcmmc.c:	writew((prescaler << 4) | divider, host->base + MMC_REG_CLK_RATE);
drivers/mmc/host/mxcmmc.c:	dev_dbg(mmc_dev(host->mmc), "scaler: %d divider: %d in: %d out: %d\n",
drivers/mmc/host/mxcmmc.c:	struct dma_slave_config *config = &host->dma_slave_config;
drivers/mmc/host/mxcmmc.c:	config->dst_addr = host->res->start + MMC_REG_BUFFER_ACCESS;
drivers/mmc/host/mxcmmc.c:	config->src_addr = host->res->start + MMC_REG_BUFFER_ACCESS;
drivers/mmc/host/mxcmmc.c:	config->dst_maxburst = host->burstlen;
drivers/mmc/host/mxcmmc.c:	config->src_maxburst = host->burstlen;
drivers/mmc/host/mxcmmc.c:	return dmaengine_slave_config(host->dma, config);
drivers/mmc/host/mxcmmc.c:	if (mxcmci_use_dma(host) && burstlen != host->burstlen) {
drivers/mmc/host/mxcmmc.c:		host->burstlen = burstlen;
drivers/mmc/host/mxcmmc.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxcmmc.c:			dma_release_channel(host->dma);
drivers/mmc/host/mxcmmc.c:			host->do_dma = 0;
drivers/mmc/host/mxcmmc.c:			host->dma = NULL;
drivers/mmc/host/mxcmmc.c:		host->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;
drivers/mmc/host/mxcmmc.c:		host->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;
drivers/mmc/host/mxcmmc.c:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/mxcmmc.c:		host->power_mode = ios->power_mode;
drivers/mmc/host/mxcmmc.c:			host->cmdat |= CMD_DAT_CONT_INIT;
drivers/mmc/host/mxcmmc.c:		writew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:		writew(STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
drivers/mmc/host/mxcmmc.c:	host->clock = ios->clock;
drivers/mmc/host/mxcmmc.c:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/mxcmmc.c:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/mxcmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:	host->use_sdio = enable;
drivers/mmc/host/mxcmmc.c:	int_cntr = readl(host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:	writel(int_cntr, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxcmmc.c:		host->caps &= ~MMC_CAP_4_BIT_DATA;
drivers/mmc/host/mxcmmc.c:		host->caps |= MMC_CAP_4_BIT_DATA;
drivers/mmc/host/mxcmmc.c:	chan->private = &host->dma_data;
drivers/mmc/host/mxcmmc.c:	host->base = ioremap(r->start, resource_size(r));
drivers/mmc/host/mxcmmc.c:	if (!host->base) {
drivers/mmc/host/mxcmmc.c:	host->mmc = mmc;
drivers/mmc/host/mxcmmc.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/mxcmmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/mxcmmc.c:	if (host->pdata && host->pdata->dat3_card_detect)
drivers/mmc/host/mxcmmc.c:		host->default_irq_mask =
drivers/mmc/host/mxcmmc.c:		host->default_irq_mask = 0;
drivers/mmc/host/mxcmmc.c:	host->res = r;
drivers/mmc/host/mxcmmc.c:	host->irq = irq;
drivers/mmc/host/mxcmmc.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/mxcmmc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/mxcmmc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/mxcmmc.c:	clk_enable(host->clk);
drivers/mmc/host/mxcmmc.c:	host->rev_no = readw(host->base + MMC_REG_REV_NO);
drivers/mmc/host/mxcmmc.c:	if (host->rev_no != 0x400) {
drivers/mmc/host/mxcmmc.c:		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
drivers/mmc/host/mxcmmc.c:			host->rev_no);
drivers/mmc/host/mxcmmc.c:	mmc->f_min = clk_get_rate(host->clk) >> 16;
drivers/mmc/host/mxcmmc.c:	mmc->f_max = clk_get_rate(host->clk) >> 1;
drivers/mmc/host/mxcmmc.c:	writew(0x2db4, host->base + MMC_REG_READ_TO);
drivers/mmc/host/mxcmmc.c:	writel(host->default_irq_mask, host->base + MMC_REG_INT_CNTR);
drivers/mmc/host/mxcmmc.c:		host->dmareq = r->start;
drivers/mmc/host/mxcmmc.c:		host->dma_data.peripheral_type = IMX_DMATYPE_SDHC;
drivers/mmc/host/mxcmmc.c:		host->dma_data.priority = DMA_PRIO_LOW;
drivers/mmc/host/mxcmmc.c:		host->dma_data.dma_request = host->dmareq;
drivers/mmc/host/mxcmmc.c:		host->dma = dma_request_channel(mask, filter, host);
drivers/mmc/host/mxcmmc.c:		if (host->dma)
drivers/mmc/host/mxcmmc.c:					host->dma->device->dev);
drivers/mmc/host/mxcmmc.c:	if (!host->dma)
drivers/mmc/host/mxcmmc.c:		dev_info(mmc_dev(host->mmc), "dma not available. Using PIO\n");
drivers/mmc/host/mxcmmc.c:	INIT_WORK(&host->datawork, mxcmci_datawork);
drivers/mmc/host/mxcmmc.c:	ret = request_irq(host->irq, mxcmci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/mxcmmc.c:	if (host->pdata && host->pdata->init) {
drivers/mmc/host/mxcmmc.c:		ret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,
drivers/mmc/host/mxcmmc.c:				host->mmc);
drivers/mmc/host/mxcmmc.c:	free_irq(host->irq, host);
drivers/mmc/host/mxcmmc.c:	if (host->dma)
drivers/mmc/host/mxcmmc.c:		dma_release_channel(host->dma);
drivers/mmc/host/mxcmmc.c:	clk_disable(host->clk);
drivers/mmc/host/mxcmmc.c:	clk_put(host->clk);
drivers/mmc/host/mxcmmc.c:	iounmap(host->base);
drivers/mmc/host/mxcmmc.c:	if (host->vcc)
drivers/mmc/host/mxcmmc.c:		regulator_put(host->vcc);
drivers/mmc/host/mxcmmc.c:	if (host->pdata && host->pdata->exit)
drivers/mmc/host/mxcmmc.c:		host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/mxcmmc.c:	free_irq(host->irq, host);
drivers/mmc/host/mxcmmc.c:	iounmap(host->base);
drivers/mmc/host/mxcmmc.c:	if (host->dma)
drivers/mmc/host/mxcmmc.c:		dma_release_channel(host->dma);
drivers/mmc/host/mxcmmc.c:	clk_disable(host->clk);
drivers/mmc/host/mxcmmc.c:	clk_put(host->clk);
drivers/mmc/host/mxcmmc.c:	release_mem_region(host->res->start, resource_size(host->res));
drivers/mmc/host/mxcmmc.c:	clk_disable(host->clk);
drivers/mmc/host/mxcmmc.c:	clk_enable(host->clk);
drivers/mmc/host/mxs-mmc.c:#define ssp_is_old()		(host->version < SSP_VERSION_LATEST)
drivers/mmc/host/mxs-mmc.c:		mmc_dev(host->mmc)->platform_data;
drivers/mmc/host/mxs-mmc.c:	return !(readl(host->base + HW_SSP_STATUS) &
drivers/mmc/host/mxs-mmc.c:	mxs_reset_block(host->base);
drivers/mmc/host/mxs-mmc.c:	       host->base + HW_SSP_TIMING);
drivers/mmc/host/mxs-mmc.c:	if (host->sdio_irq_en) {
drivers/mmc/host/mxs-mmc.c:	writel(ctrl0, host->base + HW_SSP_CTRL0);
drivers/mmc/host/mxs-mmc.c:	writel(ctrl1, host->base + HW_SSP_CTRL1);
drivers/mmc/host/mxs-mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxs-mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mxs-mmc.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/mxs-mmc.c:			cmd->resp[3] = readl(host->base + HW_SSP_SDRESP0);
drivers/mmc/host/mxs-mmc.c:			cmd->resp[2] = readl(host->base + HW_SSP_SDRESP1);
drivers/mmc/host/mxs-mmc.c:			cmd->resp[1] = readl(host->base + HW_SSP_SDRESP2);
drivers/mmc/host/mxs-mmc.c:			cmd->resp[0] = readl(host->base + HW_SSP_SDRESP3);
drivers/mmc/host/mxs-mmc.c:			cmd->resp[0] = readl(host->base + HW_SSP_SDRESP0);
drivers/mmc/host/mxs-mmc.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mxs-mmc.c:			     data->sg_len, host->dma_dir);
drivers/mmc/host/mxs-mmc.c:		host->data = NULL;
drivers/mmc/host/mxs-mmc.c:	host->mrq = NULL;
drivers/mmc/host/mxs-mmc.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/mxs-mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxs-mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mxs-mmc.c:	spin_lock(&host->lock);
drivers/mmc/host/mxs-mmc.c:	stat = readl(host->base + HW_SSP_CTRL1);
drivers/mmc/host/mxs-mmc.c:	       host->base + HW_SSP_CTRL1 + MXS_CLR_ADDR);
drivers/mmc/host/mxs-mmc.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mxs-mmc.c:	spin_unlock(&host->lock);
drivers/mmc/host/mxs-mmc.c:	struct mmc_data *data = host->data;
drivers/mmc/host/mxs-mmc.c:		dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mxs-mmc.c:			   data->sg_len, host->dma_dir);
drivers/mmc/host/mxs-mmc.c:		sgl = (struct scatterlist *) host->ssp_pio_words;
drivers/mmc/host/mxs-mmc.c:	desc = dmaengine_prep_slave_sg(host->dmach,
drivers/mmc/host/mxs-mmc.c:				sgl, sg_len, host->slave_dirn, flags);
drivers/mmc/host/mxs-mmc.c:			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/mxs-mmc.c:				     data->sg_len, host->dma_dir);
drivers/mmc/host/mxs-mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxs-mmc.c:	if (host->sdio_irq_en) {
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[0] = ctrl0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[1] = cmd0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[2] = cmd1;
drivers/mmc/host/mxs-mmc.c:	host->dma_dir = DMA_NONE;
drivers/mmc/host/mxs-mmc.c:	host->slave_dirn = DMA_TRANS_NONE;
drivers/mmc/host/mxs-mmc.c:	dma_async_issue_pending(host->dmach);
drivers/mmc/host/mxs-mmc.c:	dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxs-mmc.c:	if (host->sdio_irq_en) {
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[0] = ctrl0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[1] = cmd0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[2] = cmd1;
drivers/mmc/host/mxs-mmc.c:	host->dma_dir = DMA_NONE;
drivers/mmc/host/mxs-mmc.c:	host->slave_dirn = DMA_TRANS_NONE;
drivers/mmc/host/mxs-mmc.c:	dma_async_issue_pending(host->dmach);
drivers/mmc/host/mxs-mmc.c:	dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/mxs-mmc.c:	ctrl0 = BF_SSP(host->bus_width, CTRL0_BUS_WIDTH) |
drivers/mmc/host/mxs-mmc.c:		writel(data_size, host->base + HW_SSP_XFER_SIZE);
drivers/mmc/host/mxs-mmc.c:		       host->base + HW_SSP_BLOCK_SIZE);
drivers/mmc/host/mxs-mmc.c:	if (host->sdio_irq_en) {
drivers/mmc/host/mxs-mmc.c:	timeout = mxs_ns_to_ssp_ticks(host->clk_rate, data->timeout_ns);
drivers/mmc/host/mxs-mmc.c:	val = readl(host->base + HW_SSP_TIMING);
drivers/mmc/host/mxs-mmc.c:	writel(val, host->base + HW_SSP_TIMING);
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[0] = ctrl0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[1] = cmd0;
drivers/mmc/host/mxs-mmc.c:	host->ssp_pio_words[2] = cmd1;
drivers/mmc/host/mxs-mmc.c:	host->dma_dir = DMA_NONE;
drivers/mmc/host/mxs-mmc.c:	host->slave_dirn = DMA_TRANS_NONE;
drivers/mmc/host/mxs-mmc.c:	WARN_ON(host->data != NULL);
drivers/mmc/host/mxs-mmc.c:	host->data = data;
drivers/mmc/host/mxs-mmc.c:	host->dma_dir = dma_data_dir;
drivers/mmc/host/mxs-mmc.c:	host->slave_dirn = slave_dirn;
drivers/mmc/host/mxs-mmc.c:	dma_async_issue_pending(host->dmach);
drivers/mmc/host/mxs-mmc.c:	dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	host->cmd = cmd;
drivers/mmc/host/mxs-mmc.c:		dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/mxs-mmc.c:	host->mrq = mrq;
drivers/mmc/host/mxs-mmc.c:	ssp_clk = clk_get_rate(host->clk);
drivers/mmc/host/mxs-mmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	val = readl(host->base + HW_SSP_TIMING);
drivers/mmc/host/mxs-mmc.c:	writel(val, host->base + HW_SSP_TIMING);
drivers/mmc/host/mxs-mmc.c:	host->clk_rate = ssp_sck;
drivers/mmc/host/mxs-mmc.c:	dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:		host->bus_width = 2;
drivers/mmc/host/mxs-mmc.c:		host->bus_width = 1;
drivers/mmc/host/mxs-mmc.c:		host->bus_width = 0;
drivers/mmc/host/mxs-mmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/mxs-mmc.c:	host->sdio_irq_en = enable;
drivers/mmc/host/mxs-mmc.c:		       host->base + HW_SSP_CTRL0 + MXS_SET_ADDR);
drivers/mmc/host/mxs-mmc.c:		       host->base + HW_SSP_CTRL1 + MXS_SET_ADDR);
drivers/mmc/host/mxs-mmc.c:		if (readl(host->base + HW_SSP_STATUS) & BM_SSP_STATUS_SDIO_IRQ)
drivers/mmc/host/mxs-mmc.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/mxs-mmc.c:		       host->base + HW_SSP_CTRL0 + MXS_CLR_ADDR);
drivers/mmc/host/mxs-mmc.c:		       host->base + HW_SSP_CTRL1 + MXS_CLR_ADDR);
drivers/mmc/host/mxs-mmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/mxs-mmc.c:	if (chan->chan_id != host->dma_res->start)
drivers/mmc/host/mxs-mmc.c:	chan->private = &host->dma_data;
drivers/mmc/host/mxs-mmc.c:	host->base = ioremap(r->start, resource_size(r));
drivers/mmc/host/mxs-mmc.c:	if (!host->base) {
drivers/mmc/host/mxs-mmc.c:	host->version = readl(host->base + HW_SSP_VERSION) >>
drivers/mmc/host/mxs-mmc.c:	host->mmc = mmc;
drivers/mmc/host/mxs-mmc.c:	host->res = r;
drivers/mmc/host/mxs-mmc.c:	host->dma_res = dmares;
drivers/mmc/host/mxs-mmc.c:	host->irq = irq_err;
drivers/mmc/host/mxs-mmc.c:	host->sdio_irq_en = 0;
drivers/mmc/host/mxs-mmc.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/mxs-mmc.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/mxs-mmc.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/mxs-mmc.c:	clk_prepare_enable(host->clk);
drivers/mmc/host/mxs-mmc.c:	host->dma_data.chan_irq = irq_dma;
drivers/mmc/host/mxs-mmc.c:	host->dmach = dma_request_channel(mask, mxs_mmc_dma_filter, host);
drivers/mmc/host/mxs-mmc.c:	if (!host->dmach) {
drivers/mmc/host/mxs-mmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/mxs-mmc.c:	pdata =	mmc_dev(host->mmc)->platform_data;
drivers/mmc/host/mxs-mmc.c:	mmc->max_seg_size = dma_get_max_seg_size(host->dmach->device->dev);
drivers/mmc/host/mxs-mmc.c:	ret = request_irq(host->irq, mxs_mmc_irq_handler, 0, DRIVER_NAME, host);
drivers/mmc/host/mxs-mmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/mxs-mmc.c:	dev_info(mmc_dev(host->mmc), "initialized\n");
drivers/mmc/host/mxs-mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/mxs-mmc.c:	if (host->dmach)
drivers/mmc/host/mxs-mmc.c:		dma_release_channel(host->dmach);
drivers/mmc/host/mxs-mmc.c:	clk_disable_unprepare(host->clk);
drivers/mmc/host/mxs-mmc.c:	clk_put(host->clk);
drivers/mmc/host/mxs-mmc.c:	iounmap(host->base);
drivers/mmc/host/mxs-mmc.c:	struct resource *res = host->res;
drivers/mmc/host/mxs-mmc.c:	free_irq(host->irq, host);
drivers/mmc/host/mxs-mmc.c:	if (host->dmach)
drivers/mmc/host/mxs-mmc.c:		dma_release_channel(host->dmach);
drivers/mmc/host/mxs-mmc.c:	clk_disable_unprepare(host->clk);
drivers/mmc/host/mxs-mmc.c:	clk_put(host->clk);
drivers/mmc/host/mxs-mmc.c:	iounmap(host->base);
drivers/mmc/host/mxs-mmc.c:	clk_disable_unprepare(host->clk);
drivers/mmc/host/mxs-mmc.c:	clk_prepare_enable(host->clk);
drivers/mmc/host/omap.c:	if (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->clk_lock, flags);
drivers/mmc/host/omap.c:	if (host->fclk_enabled != enable) {
drivers/mmc/host/omap.c:		host->fclk_enabled = enable;
drivers/mmc/host/omap.c:			clk_enable(host->fclk);
drivers/mmc/host/omap.c:			clk_disable(host->fclk);
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->clk_lock, flags);
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	while (host->mmc != NULL) {
drivers/mmc/host/omap.c:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:		wait_event(host->slot_wq, host->mmc == NULL);
drivers/mmc/host/omap.c:		spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	host->mmc = slot->mmc;
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	del_timer(&host->clk_timer);
drivers/mmc/host/omap.c:	if (host->current_slot != slot || !claimed)
drivers/mmc/host/omap.c:		mmc_omap_fclk_offdelay(host->current_slot);
drivers/mmc/host/omap.c:	if (host->current_slot != slot) {
drivers/mmc/host/omap.c:		if (host->pdata->switch_slot != NULL)
drivers/mmc/host/omap.c:			host->pdata->switch_slot(mmc_dev(slot->mmc), slot->id);
drivers/mmc/host/omap.c:		host->current_slot = slot;
drivers/mmc/host/omap.c:	struct mmc_omap_slot *next_slot = host->next_slot;
drivers/mmc/host/omap.c:	host->next_slot = NULL;
drivers/mmc/host/omap.c:	BUG_ON(slot == NULL || host->mmc == NULL);
drivers/mmc/host/omap.c:		mod_timer(&host->clk_timer, jiffies  + HZ/10);
drivers/mmc/host/omap.c:		del_timer(&host->clk_timer);
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:		if (host->slots[i] == NULL || host->slots[i]->mrq == NULL)
drivers/mmc/host/omap.c:		BUG_ON(host->next_slot != NULL);
drivers/mmc/host/omap.c:		new_slot = host->slots[i];
drivers/mmc/host/omap.c:		BUG_ON(new_slot == host->current_slot);
drivers/mmc/host/omap.c:		host->next_slot = new_slot;
drivers/mmc/host/omap.c:		host->mmc = new_slot->mmc;
drivers/mmc/host/omap.c:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:		queue_work(mmc_omap_wq, &host->slot_release_work);
drivers/mmc/host/omap.c:	host->mmc = NULL;
drivers/mmc/host/omap.c:	wake_up(&host->slot_wq);
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	host->cmd = cmd;
drivers/mmc/host/omap.c:		dev_err(mmc_dev(host->mmc), "Invalid response type: %04x\n", mmc_resp_type(cmd));
drivers/mmc/host/omap.c:	if (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)
drivers/mmc/host/omap.c:	if (host->data && !(host->data->flags & MMC_DATA_WRITE))
drivers/mmc/host/omap.c:	mod_timer(&host->cmd_abort_timer, jiffies + HZ/2);
drivers/mmc/host/omap.c:	BUG_ON(host->dma_ch < 0);
drivers/mmc/host/omap.c:		omap_stop_dma(host->dma_ch);
drivers/mmc/host/omap.c:	mod_timer(&host->dma_timer, jiffies + HZ);
drivers/mmc/host/omap.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
drivers/mmc/host/omap.c:	struct mmc_omap_slot *slot = host->current_slot;
drivers/mmc/host/omap.c:	struct mmc_data *data = host->stop_data;
drivers/mmc/host/omap.c:	if (host->dma_in_use)
drivers/mmc/host/omap.c:	host->data = NULL;
drivers/mmc/host/omap.c:	host->sg_len = 0;
drivers/mmc/host/omap.c:		host->mrq = NULL;
drivers/mmc/host/omap.c:		mmc = host->mmc;
drivers/mmc/host/omap.c:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:	host->stop_data = data;
drivers/mmc/host/omap.c:	queue_work(mmc_omap_wq, &host->send_stop_work);
drivers/mmc/host/omap.c:	struct mmc_omap_slot *slot = host->current_slot;
drivers/mmc/host/omap.c:	if (host->dma_in_use)
drivers/mmc/host/omap.c:	host->data = NULL;
drivers/mmc/host/omap.c:	host->sg_len = 0;
drivers/mmc/host/omap.c:	if (!host->dma_in_use) {
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->dma_lock, flags);
drivers/mmc/host/omap.c:	if (host->dma_done)
drivers/mmc/host/omap.c:		host->brs_received = 1;
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->dma_lock, flags);
drivers/mmc/host/omap.c:	BUG_ON(host->dma_ch < 0);
drivers/mmc/host/omap.c:	omap_free_dma(host->dma_ch);
drivers/mmc/host/omap.c:	host->dma_ch = -1;
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->dma_lock, flags);
drivers/mmc/host/omap.c:	if (host->brs_received)
drivers/mmc/host/omap.c:		host->dma_done = 1;
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->dma_lock, flags);
drivers/mmc/host/omap.c:	host->cmd = NULL;
drivers/mmc/host/omap.c:	del_timer(&host->cmd_abort_timer);
drivers/mmc/host/omap.c:	if (host->data == NULL || cmd->error) {
drivers/mmc/host/omap.c:		if (host->data != NULL)
drivers/mmc/host/omap.c:			mmc_omap_abort_xfer(host, host->data);
drivers/mmc/host/omap.c:		host->mrq = NULL;
drivers/mmc/host/omap.c:		mmc = host->mmc;
drivers/mmc/host/omap.c:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:	BUG_ON(!host->cmd);
drivers/mmc/host/omap.c:	dev_dbg(mmc_dev(host->mmc), "Aborting stuck command CMD%d\n",
drivers/mmc/host/omap.c:		host->cmd->opcode);
drivers/mmc/host/omap.c:	if (host->cmd->error == 0)
drivers/mmc/host/omap.c:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:	if (host->data == NULL) {
drivers/mmc/host/omap.c:		cmd = host->cmd;
drivers/mmc/host/omap.c:		host->cmd = NULL;
drivers/mmc/host/omap.c:		host->mrq = NULL;
drivers/mmc/host/omap.c:		mmc = host->mmc;
drivers/mmc/host/omap.c:		mmc_omap_release_slot(host->current_slot, 1);
drivers/mmc/host/omap.c:		mmc_omap_cmd_done(host, host->cmd);
drivers/mmc/host/omap.c:	host->abort = 0;
drivers/mmc/host/omap.c:	enable_irq(host->irq);
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	if (host->cmd != NULL && !host->abort) {
drivers/mmc/host/omap.c:		disable_irq(host->irq);
drivers/mmc/host/omap.c:		host->abort = 1;
drivers/mmc/host/omap.c:		queue_work(mmc_omap_wq, &host->cmd_abort_work);
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	sg = host->data->sg + host->sg_idx;
drivers/mmc/host/omap.c:	host->buffer_bytes_left = sg->length;
drivers/mmc/host/omap.c:	host->buffer = sg_virt(sg);
drivers/mmc/host/omap.c:	if (host->buffer_bytes_left > host->total_bytes_left)
drivers/mmc/host/omap.c:		host->buffer_bytes_left = host->total_bytes_left;
drivers/mmc/host/omap.c:	if (host->buffer_bytes_left == 0) {
drivers/mmc/host/omap.c:		host->sg_idx++;
drivers/mmc/host/omap.c:		BUG_ON(host->sg_idx == host->sg_len);
drivers/mmc/host/omap.c:	if (n > host->buffer_bytes_left)
drivers/mmc/host/omap.c:		n = host->buffer_bytes_left;
drivers/mmc/host/omap.c:	host->buffer_bytes_left -= n;
drivers/mmc/host/omap.c:	host->total_bytes_left -= n;
drivers/mmc/host/omap.c:	host->data->bytes_xfered += n;
drivers/mmc/host/omap.c:		__raw_writesw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);
drivers/mmc/host/omap.c:		__raw_readsw(host->virt_base + OMAP_MMC_REG(host, DATA), host->buffer, n);
drivers/mmc/host/omap.c:	if (host->cmd == NULL && host->data == NULL) {
drivers/mmc/host/omap.c:		dev_info(mmc_dev(host->slots[0]->mmc),
drivers/mmc/host/omap.c:		if (host->cmd != NULL)
drivers/mmc/host/omap.c:			cmd = host->cmd->opcode;
drivers/mmc/host/omap.c:		dev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD %d): ",
drivers/mmc/host/omap.c:		if (host->total_bytes_left) {
drivers/mmc/host/omap.c:			dev_dbg(mmc_dev(host->mmc), "data timeout (CMD%d)\n",
drivers/mmc/host/omap.c:			if (host->data) {
drivers/mmc/host/omap.c:				host->data->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:			if (host->data) {
drivers/mmc/host/omap.c:				host->data->error = -EILSEQ;
drivers/mmc/host/omap.c:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:					host->total_bytes_left);
drivers/mmc/host/omap.c:				dev_dbg(mmc_dev(host->mmc), "data CRC error\n");
drivers/mmc/host/omap.c:			if (host->cmd) {
drivers/mmc/host/omap.c:					host->current_slot;
drivers/mmc/host/omap.c:					dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap.c:			if (host->cmd) {
drivers/mmc/host/omap.c:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:					cmd, host->cmd->arg);
drivers/mmc/host/omap.c:				host->cmd->error = -EILSEQ;
drivers/mmc/host/omap.c:				dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:	if (cmd_error && host->data) {
drivers/mmc/host/omap.c:		del_timer(&host->cmd_abort_timer);
drivers/mmc/host/omap.c:		host->abort = 1;
drivers/mmc/host/omap.c:		disable_irq_nosync(host->irq);
drivers/mmc/host/omap.c:		queue_work(mmc_omap_wq, &host->cmd_abort_work);
drivers/mmc/host/omap.c:	if (end_command && host->cmd)
drivers/mmc/host/omap.c:		mmc_omap_cmd_done(host, host->cmd);
drivers/mmc/host/omap.c:	if (host->data != NULL) {
drivers/mmc/host/omap.c:			mmc_omap_xfer_done(host, host->data);
drivers/mmc/host/omap.c:			mmc_omap_end_of_data(host, host->data);
drivers/mmc/host/omap.c:	struct mmc_omap_slot *slot = host->slots[num];
drivers/mmc/host/omap.c:	BUG_ON(num >= host->nr_slots);
drivers/mmc/host/omap.c:	if (host->nr_slots == 0 || !host->slots[num])
drivers/mmc/host/omap.c:	int dma_ch = host->dma_ch;
drivers/mmc/host/omap.c:	struct scatterlist *sg = &data->sg[host->sg_idx];
drivers/mmc/host/omap.c:	data_addr = host->phys_base + OMAP_MMC_REG(host, DATA);
drivers/mmc/host/omap.c:	host->dma_len = count;
drivers/mmc/host/omap.c:	struct mmc_data *mmcdat = host->data;
drivers/mmc/host/omap.c:	if (unlikely(host->dma_ch < 0)) {
drivers/mmc/host/omap.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap.c:		dev_err(mmc_dev(host->mmc),"DMA timeout\n");
drivers/mmc/host/omap.c:		dev_err(mmc_dev(host->mmc), "DMA sync error\n");
drivers/mmc/host/omap.c:	mmcdat->bytes_xfered += host->dma_len;
drivers/mmc/host/omap.c:	host->sg_idx++;
drivers/mmc/host/omap.c:	if (host->sg_idx < host->sg_len) {
drivers/mmc/host/omap.c:		mmc_omap_prepare_dma(host, host->data);
drivers/mmc/host/omap.c:		omap_start_dma(host->dma_ch);
drivers/mmc/host/omap.c:		mmc_omap_dma_done(host, host->data);
drivers/mmc/host/omap.c:	del_timer_sync(&host->dma_timer);
drivers/mmc/host/omap.c:	if (host->dma_ch >= 0) {
drivers/mmc/host/omap.c:		if (is_read == host->dma_is_read)
drivers/mmc/host/omap.c:		omap_free_dma(host->dma_ch);
drivers/mmc/host/omap.c:		host->dma_ch = -1;
drivers/mmc/host/omap.c:		if (host->id == 0) {
drivers/mmc/host/omap.c:		if (host->id == 0) {
drivers/mmc/host/omap.c:		dev_dbg(mmc_dev(host->mmc), "omap_request_dma() failed with %d\n", r);
drivers/mmc/host/omap.c:	host->dma_ch = dma_ch;
drivers/mmc/host/omap.c:	host->dma_is_read = is_read;
drivers/mmc/host/omap.c:	cycle_ns = 1000000000 / host->current_slot->fclk_freq;
drivers/mmc/host/omap.c:	host->data = data;
drivers/mmc/host/omap.c:		host->dma_in_use = 0;
drivers/mmc/host/omap.c:	use_dma = host->use_dma;
drivers/mmc/host/omap.c:	host->sg_idx = 0;
drivers/mmc/host/omap.c:			host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/omap.c:			host->total_bytes_left = 0;
drivers/mmc/host/omap.c:			host->brs_received = 0;
drivers/mmc/host/omap.c:			host->dma_done = 0;
drivers/mmc/host/omap.c:			host->dma_in_use = 1;
drivers/mmc/host/omap.c:		host->total_bytes_left = data->blocks * block_size;
drivers/mmc/host/omap.c:		host->sg_len = sg_len;
drivers/mmc/host/omap.c:		host->dma_in_use = 0;
drivers/mmc/host/omap.c:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/omap.c:	host->mrq = req;
drivers/mmc/host/omap.c:	if (host->dma_in_use)
drivers/mmc/host/omap.c:		omap_start_dma(host->dma_ch);
drivers/mmc/host/omap.c:	spin_lock_irqsave(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	if (host->mmc != NULL) {
drivers/mmc/host/omap.c:		spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:		host->mmc = mmc;
drivers/mmc/host/omap.c:	spin_unlock_irqrestore(&host->slot_lock, flags);
drivers/mmc/host/omap.c:	int func_clk_rate = clk_get_rate(host->fclk);
drivers/mmc/host/omap.c:	mmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);
drivers/mmc/host/omap.c:	slot->pdata = &host->pdata->slots[id];
drivers/mmc/host/omap.c:	host->slots[id] = slot;
drivers/mmc/host/omap.c:	if (host->pdata->slots[id].wires >= 4)
drivers/mmc/host/omap.c:	if (host->pdata->max_freq)
drivers/mmc/host/omap.c:		mmc->f_max = min(host->pdata->max_freq, mmc->f_max);
drivers/mmc/host/omap.c:	INIT_WORK(&host->slot_release_work, mmc_omap_slot_release_work);
drivers/mmc/host/omap.c:	INIT_WORK(&host->send_stop_work, mmc_omap_send_stop_work);
drivers/mmc/host/omap.c:	INIT_WORK(&host->cmd_abort_work, mmc_omap_abort_command);
drivers/mmc/host/omap.c:	setup_timer(&host->cmd_abort_timer, mmc_omap_cmd_timer,
drivers/mmc/host/omap.c:	spin_lock_init(&host->clk_lock);
drivers/mmc/host/omap.c:	setup_timer(&host->clk_timer, mmc_omap_clk_timer, (unsigned long) host);
drivers/mmc/host/omap.c:	spin_lock_init(&host->dma_lock);
drivers/mmc/host/omap.c:	setup_timer(&host->dma_timer, mmc_omap_dma_timer, (unsigned long) host);
drivers/mmc/host/omap.c:	spin_lock_init(&host->slot_lock);
drivers/mmc/host/omap.c:	init_waitqueue_head(&host->slot_wq);
drivers/mmc/host/omap.c:	host->pdata = pdata;
drivers/mmc/host/omap.c:	host->dev = &pdev->dev;
drivers/mmc/host/omap.c:	host->id = pdev->id;
drivers/mmc/host/omap.c:	host->mem_res = res;
drivers/mmc/host/omap.c:	host->irq = irq;
drivers/mmc/host/omap.c:	host->use_dma = 1;
drivers/mmc/host/omap.c:	host->dev->dma_mask = &pdata->dma_mask;
drivers/mmc/host/omap.c:	host->dma_ch = -1;
drivers/mmc/host/omap.c:	host->irq = irq;
drivers/mmc/host/omap.c:	host->phys_base = host->mem_res->start;
drivers/mmc/host/omap.c:	host->virt_base = ioremap(res->start, resource_size(res));
drivers/mmc/host/omap.c:	if (!host->virt_base)
drivers/mmc/host/omap.c:	host->iclk = clk_get(&pdev->dev, "ick");
drivers/mmc/host/omap.c:	if (IS_ERR(host->iclk)) {
drivers/mmc/host/omap.c:		ret = PTR_ERR(host->iclk);
drivers/mmc/host/omap.c:	clk_enable(host->iclk);
drivers/mmc/host/omap.c:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap.c:	if (IS_ERR(host->fclk)) {
drivers/mmc/host/omap.c:		ret = PTR_ERR(host->fclk);
drivers/mmc/host/omap.c:	ret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/omap.c:	host->nr_slots = pdata->nr_slots;
drivers/mmc/host/omap.c:				mmc_omap_remove_slot(host->slots[i]);
drivers/mmc/host/omap.c:	host->reg_shift = (cpu_is_omap7xx() ? 1 : 2);
drivers/mmc/host/omap.c:	free_irq(host->irq, host);
drivers/mmc/host/omap.c:	clk_put(host->fclk);
drivers/mmc/host/omap.c:	clk_disable(host->iclk);
drivers/mmc/host/omap.c:	clk_put(host->iclk);
drivers/mmc/host/omap.c:	iounmap(host->virt_base);
drivers/mmc/host/omap.c:	for (i = 0; i < host->nr_slots; i++)
drivers/mmc/host/omap.c:		mmc_omap_remove_slot(host->slots[i]);
drivers/mmc/host/omap.c:	if (host->pdata->cleanup)
drivers/mmc/host/omap.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap.c:	free_irq(host->irq, host);
drivers/mmc/host/omap.c:	clk_put(host->fclk);
drivers/mmc/host/omap.c:	clk_disable(host->iclk);
drivers/mmc/host/omap.c:	clk_put(host->iclk);
drivers/mmc/host/omap.c:	iounmap(host->virt_base);
drivers/mmc/host/omap.c:	if (host == NULL || host->suspended)
drivers/mmc/host/omap.c:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:		slot = host->slots[i];
drivers/mmc/host/omap.c:				slot = host->slots[i];
drivers/mmc/host/omap.c:	host->suspended = 1;
drivers/mmc/host/omap.c:	if (host == NULL || !host->suspended)
drivers/mmc/host/omap.c:	for (i = 0; i < host->nr_slots; i++) {
drivers/mmc/host/omap.c:		slot = host->slots[i];
drivers/mmc/host/omap.c:		host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:#define mmc_slot(host)		(host->pdata->slots[host->slot_id])
drivers/mmc/host/omap_hsmmc.c:	if (!host->vcc)
drivers/mmc/host/omap_hsmmc.c:		ret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);
drivers/mmc/host/omap_hsmmc.c:		if (ret == 0 && host->vcc_aux) {
drivers/mmc/host/omap_hsmmc.c:			ret = regulator_enable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:				ret = mmc_regulator_set_ocr(host->mmc,
drivers/mmc/host/omap_hsmmc.c:							host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:		if (host->vcc_aux)
drivers/mmc/host/omap_hsmmc.c:			ret = regulator_disable(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:			ret = mmc_regulator_set_ocr(host->mmc,
drivers/mmc/host/omap_hsmmc.c:						host->vcc, 0);
drivers/mmc/host/omap_hsmmc.c:	reg = regulator_get(host->dev, "vmmc");
drivers/mmc/host/omap_hsmmc.c:		dev_dbg(host->dev, "vmmc regulator missing\n");
drivers/mmc/host/omap_hsmmc.c:		host->vcc = reg;
drivers/mmc/host/omap_hsmmc.c:				dev_err(host->dev, "ocrmask %x is not supported\n",
drivers/mmc/host/omap_hsmmc.c:		reg = regulator_get(host->dev, "vmmc_aux");
drivers/mmc/host/omap_hsmmc.c:		host->vcc_aux = IS_ERR(reg) ? NULL : reg;
drivers/mmc/host/omap_hsmmc.c:		if (regulator_is_enabled(host->vcc) > 0 ||
drivers/mmc/host/omap_hsmmc.c:		    (host->vcc_aux && regulator_is_enabled(host->vcc_aux))) {
drivers/mmc/host/omap_hsmmc.c:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:	regulator_put(host->vcc);
drivers/mmc/host/omap_hsmmc.c:	regulator_put(host->vcc_aux);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
drivers/mmc/host/omap_hsmmc.c:	if ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)
drivers/mmc/host/omap_hsmmc.c:		dev_dbg(mmc_dev(host->mmc), "MMC Clock is not stoped\n");
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma)
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, ISE, irq_mask);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, IE, irq_mask);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, ISE, 0);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, IE, 0);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:		dsor = DIV_ROUND_UP(clk_get_rate(host->fclk), ios->clock);
drivers/mmc/host/omap_hsmmc.c:	struct mmc_ios *ios = &host->mmc->ios;
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "Set clock to %uHz\n", ios->clock);
drivers/mmc/host/omap_hsmmc.c:	regval = OMAP_HSMMC_READ(host->base, SYSCTL);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL, regval);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, SYSCTL) | ICE);
drivers/mmc/host/omap_hsmmc.c:	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS
drivers/mmc/host/omap_hsmmc.c:	struct mmc_ios *ios = &host->mmc->ios;
drivers/mmc/host/omap_hsmmc.c:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, CON, con | DW8);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);
drivers/mmc/host/omap_hsmmc.c:	struct mmc_ios *ios = &host->mmc->ios;
drivers/mmc/host/omap_hsmmc.c:	con = OMAP_HSMMC_READ(host->base, CON);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, CON, con | OD);
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, CON, con & ~OD);
drivers/mmc/host/omap_hsmmc.c:	struct mmc_ios *ios = &host->mmc->ios;
drivers/mmc/host/omap_hsmmc.c:	struct omap_mmc_platform_data *pdata = host->pdata;
drivers/mmc/host/omap_hsmmc.c:		context_loss = pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "context was %slost\n",
drivers/mmc/host/omap_hsmmc.c:		context_loss == host->context_loss ? "not " : "");
drivers/mmc/host/omap_hsmmc.c:	if (host->context_loss == context_loss)
drivers/mmc/host/omap_hsmmc.c:	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG, SOFTRESET);
drivers/mmc/host/omap_hsmmc.c:	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {
drivers/mmc/host/omap_hsmmc.c:		if (host->power_mode != MMC_POWER_OFF &&
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, HCTL) | hctl);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CAPA,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, CAPA) | capa);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
drivers/mmc/host/omap_hsmmc.c:	while ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP
drivers/mmc/host/omap_hsmmc.c:	if (host->power_mode == MMC_POWER_OFF)
drivers/mmc/host/omap_hsmmc.c:	host->context_loss = context_loss;
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "context is restored\n");
drivers/mmc/host/omap_hsmmc.c:	struct omap_mmc_platform_data *pdata = host->pdata;
drivers/mmc/host/omap_hsmmc.c:		context_loss = pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:		host->context_loss = context_loss;
drivers/mmc/host/omap_hsmmc.c:	if (host->protect_card)
drivers/mmc/host/omap_hsmmc.c:	disable_irq(host->irq);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CON,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);
drivers/mmc/host/omap_hsmmc.c:		reg = OMAP_HSMMC_READ(host->base, STAT) & CC;
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CON,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:	enable_irq(host->irq);
drivers/mmc/host/omap_hsmmc.c:		r = mmc_slot(host).get_cover_state(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "%s: CMD%d, argument 0x%08x\n",
drivers/mmc/host/omap_hsmmc.c:		mmc_hostname(host->mmc), cmd->opcode, cmd->arg);
drivers/mmc/host/omap_hsmmc.c:	host->cmd = cmd;
drivers/mmc/host/omap_hsmmc.c:	host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:			host->response_busy = 1;
drivers/mmc/host/omap_hsmmc.c:	if (cmd == host->mrq->stop)
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma)
drivers/mmc/host/omap_hsmmc.c:	host->req_in_progress = 1;
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CMD, cmdreg);
drivers/mmc/host/omap_hsmmc.c:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	host->req_in_progress = 0;
drivers/mmc/host/omap_hsmmc.c:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	if (mrq->data && host->use_dma && dma_ch != -1)
drivers/mmc/host/omap_hsmmc.c:	host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/omap_hsmmc.c:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/omap_hsmmc.c:		if (host->cmd && host->cmd->opcode == 6 &&
drivers/mmc/host/omap_hsmmc.c:		    host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:			host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:	host->data = NULL;
drivers/mmc/host/omap_hsmmc.c:	host->cmd = NULL;
drivers/mmc/host/omap_hsmmc.c:			cmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);
drivers/mmc/host/omap_hsmmc.c:			cmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);
drivers/mmc/host/omap_hsmmc.c:			cmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);
drivers/mmc/host/omap_hsmmc.c:			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);
drivers/mmc/host/omap_hsmmc.c:			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);
drivers/mmc/host/omap_hsmmc.c:	if ((host->data == NULL && !host->response_busy) || cmd->error)
drivers/mmc/host/omap_hsmmc.c:	host->data->error = errno;
drivers/mmc/host/omap_hsmmc.c:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:	host->dma_ch = -1;
drivers/mmc/host/omap_hsmmc.c:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma && dma_ch != -1) {
drivers/mmc/host/omap_hsmmc.c:		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg,
drivers/mmc/host/omap_hsmmc.c:			host->data->sg_len,
drivers/mmc/host/omap_hsmmc.c:			omap_hsmmc_get_dma_dir(host, host->data));
drivers/mmc/host/omap_hsmmc.c:		host->data->host_cookie = 0;
drivers/mmc/host/omap_hsmmc.c:	host->data = NULL;
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "%s\n", res);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL,
drivers/mmc/host/omap_hsmmc.c:			 OMAP_HSMMC_READ(host->base, SYSCTL) | bit);
drivers/mmc/host/omap_hsmmc.c:		while ((!(OMAP_HSMMC_READ(host->base, SYSCTL) & bit))
drivers/mmc/host/omap_hsmmc.c:	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & bit) &&
drivers/mmc/host/omap_hsmmc.c:	if (OMAP_HSMMC_READ(host->base, SYSCTL) & bit)
drivers/mmc/host/omap_hsmmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:	if (!host->req_in_progress) {
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_WRITE(host->base, STAT, status);
drivers/mmc/host/omap_hsmmc.c:			status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:	data = host->data;
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "IRQ Status is %x\n", status);
drivers/mmc/host/omap_hsmmc.c:			if (host->cmd) {
drivers/mmc/host/omap_hsmmc.c:					host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/omap_hsmmc.c:					host->cmd->error = -EILSEQ;
drivers/mmc/host/omap_hsmmc.c:			if (host->data || host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:				if (host->data)
drivers/mmc/host/omap_hsmmc.c:				host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:			if (host->data || host->response_busy) {
drivers/mmc/host/omap_hsmmc.c:				if (host->data)
drivers/mmc/host/omap_hsmmc.c:					host->mrq->cmd->error = err;
drivers/mmc/host/omap_hsmmc.c:				host->response_busy = 0;
drivers/mmc/host/omap_hsmmc.c:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:				"Ignoring card err CMD%d\n", host->cmd->opcode);
drivers/mmc/host/omap_hsmmc.c:			if (host->cmd)
drivers/mmc/host/omap_hsmmc.c:			if (host->data)
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, STAT, status);
drivers/mmc/host/omap_hsmmc.c:	if (end_cmd || ((status & CC) && host->cmd))
drivers/mmc/host/omap_hsmmc.c:		omap_hsmmc_cmd_done(host, host->cmd);
drivers/mmc/host/omap_hsmmc.c:	if ((end_trans || (status & TC)) && host->mrq)
drivers/mmc/host/omap_hsmmc.c:	status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:		status = OMAP_HSMMC_READ(host->base, STAT);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:			 OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
drivers/mmc/host/omap_hsmmc.c:		if (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
drivers/mmc/host/omap_hsmmc.c:		ret = mmc_slot(host).set_power(host->dev, host->slot_id, 1,
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:		clk_enable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
drivers/mmc/host/omap_hsmmc.c:	reg_val = OMAP_HSMMC_READ(host->base, HCTL);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL, reg_val);
drivers/mmc/host/omap_hsmmc.c:	dev_dbg(mmc_dev(host->mmc), "Unable to switch operating voltage\n");
drivers/mmc/host/omap_hsmmc.c:	host->reqs_blocked = 0;
drivers/mmc/host/omap_hsmmc.c:	if (mmc_slot(host).get_cover_state(host->dev, host->slot_id)) {
drivers/mmc/host/omap_hsmmc.c:		if (host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:			dev_info(host->dev, "%s: cover is closed, "
drivers/mmc/host/omap_hsmmc.c:					 mmc_hostname(host->mmc));
drivers/mmc/host/omap_hsmmc.c:			host->protect_card = 0;
drivers/mmc/host/omap_hsmmc.c:		if (!host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:			dev_info(host->dev, "%s: cover is open, "
drivers/mmc/host/omap_hsmmc.c:					 mmc_hostname(host->mmc));
drivers/mmc/host/omap_hsmmc.c:			host->protect_card = 1;
drivers/mmc/host/omap_hsmmc.c:	if (host->suspended)
drivers/mmc/host/omap_hsmmc.c:	sysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");
drivers/mmc/host/omap_hsmmc.c:		carddetect = slot->card_detect(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
drivers/mmc/host/omap_hsmmc.c:		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
drivers/mmc/host/omap_hsmmc.c:		sync_dev = host->dma_line_tx;
drivers/mmc/host/omap_hsmmc.c:		sync_dev = host->dma_line_rx;
drivers/mmc/host/omap_hsmmc.c:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
drivers/mmc/host/omap_hsmmc.c:			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
drivers/mmc/host/omap_hsmmc.c:	blksz = host->data->blksz;
drivers/mmc/host/omap_hsmmc.c:		dev_warn(mmc_dev(host->mmc), "unexpected dma status %x\n",
drivers/mmc/host/omap_hsmmc.c:	spin_lock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	if (host->dma_ch < 0) {
drivers/mmc/host/omap_hsmmc.c:		spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	data = host->mrq->data;
drivers/mmc/host/omap_hsmmc.c:	host->dma_sg_idx++;
drivers/mmc/host/omap_hsmmc.c:	if (host->dma_sg_idx < host->dma_len) {
drivers/mmc/host/omap_hsmmc.c:					   data->sg + host->dma_sg_idx);
drivers/mmc/host/omap_hsmmc.c:		spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:		dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/omap_hsmmc.c:	req_in_progress = host->req_in_progress;
drivers/mmc/host/omap_hsmmc.c:	dma_ch = host->dma_ch;
drivers/mmc/host/omap_hsmmc.c:	host->dma_ch = -1;
drivers/mmc/host/omap_hsmmc.c:	spin_unlock(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:		struct mmc_request *mrq = host->mrq;
drivers/mmc/host/omap_hsmmc.c:		host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:		mmc_request_done(host->mmc, mrq);
drivers/mmc/host/omap_hsmmc.c:	    data->host_cookie != host->next_data.cookie) {
drivers/mmc/host/omap_hsmmc.c:		dev_warn(host->dev, "[%s] invalid cookie: data->host_cookie %d"
drivers/mmc/host/omap_hsmmc.c:		       " host->next_data.cookie %d\n",
drivers/mmc/host/omap_hsmmc.c:		       __func__, data->host_cookie, host->next_data.cookie);
drivers/mmc/host/omap_hsmmc.c:	    (!next && data->host_cookie != host->next_data.cookie)) {
drivers/mmc/host/omap_hsmmc.c:		dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/omap_hsmmc.c:		dma_len = host->next_data.dma_len;
drivers/mmc/host/omap_hsmmc.c:		host->next_data.dma_len = 0;
drivers/mmc/host/omap_hsmmc.c:		host->dma_len = dma_len;
drivers/mmc/host/omap_hsmmc.c:	BUG_ON(host->dma_ch != -1);
drivers/mmc/host/omap_hsmmc.c:		dev_err(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:			mmc_hostname(host->mmc), ret);
drivers/mmc/host/omap_hsmmc.c:	host->dma_ch = dma_ch;
drivers/mmc/host/omap_hsmmc.c:	host->dma_sg_idx = 0;
drivers/mmc/host/omap_hsmmc.c:	reg = OMAP_HSMMC_READ(host->base, SYSCTL);
drivers/mmc/host/omap_hsmmc.c:	cycle_ns = 1000000000 / (clk_get_rate(host->fclk) / clkd);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCTL, reg);
drivers/mmc/host/omap_hsmmc.c:	host->data = req->data;
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, BLK, 0);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma) {
drivers/mmc/host/omap_hsmmc.c:			dev_dbg(mmc_dev(host->mmc), "MMC start dma failure\n");
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma) {
drivers/mmc/host/omap_hsmmc.c:			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/omap_hsmmc.c:	if (host->use_dma)
drivers/mmc/host/omap_hsmmc.c:						&host->next_data))
drivers/mmc/host/omap_hsmmc.c:	BUG_ON(host->req_in_progress);
drivers/mmc/host/omap_hsmmc.c:	BUG_ON(host->dma_ch != -1);
drivers/mmc/host/omap_hsmmc.c:	if (host->protect_card) {
drivers/mmc/host/omap_hsmmc.c:		if (host->reqs_blocked < 3) {
drivers/mmc/host/omap_hsmmc.c:			host->reqs_blocked += 1;
drivers/mmc/host/omap_hsmmc.c:	} else if (host->reqs_blocked)
drivers/mmc/host/omap_hsmmc.c:		host->reqs_blocked = 0;
drivers/mmc/host/omap_hsmmc.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/omap_hsmmc.c:	host->mrq = req;
drivers/mmc/host/omap_hsmmc.c:		host->mrq = NULL;
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (ios->power_mode != host->power_mode) {
drivers/mmc/host/omap_hsmmc.c:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:			host->vdd = 0;
drivers/mmc/host/omap_hsmmc.c:			mmc_slot(host).set_power(host->dev, host->slot_id,
drivers/mmc/host/omap_hsmmc.c:			host->vdd = ios->vdd;
drivers/mmc/host/omap_hsmmc.c:		host->power_mode = ios->power_mode;
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {
drivers/mmc/host/omap_hsmmc.c:		if ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&
drivers/mmc/host/omap_hsmmc.c:			!host->dev->of_node) {
drivers/mmc/host/omap_hsmmc.c:				dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_autosuspend(host->dev);
drivers/mmc/host/omap_hsmmc.c:	return mmc_slot(host).card_detect(host->dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:	return mmc_slot(host).get_ro(host->dev, 0);
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {
drivers/mmc/host/omap_hsmmc.c:	value = OMAP_HSMMC_READ(host->base, HCTL) & ~SDVS_MASK;
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, HCTL, value | hctl);
drivers/mmc/host/omap_hsmmc.c:	value = OMAP_HSMMC_READ(host->base, CAPA);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, CAPA, value | capa);
drivers/mmc/host/omap_hsmmc.c:	value = OMAP_HSMMC_READ(host->base, SYSCONFIG);
drivers/mmc/host/omap_hsmmc.c:	OMAP_HSMMC_WRITE(host->base, SYSCONFIG, value | AUTOIDLE);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_mark_last_busy(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_autosuspend(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->get_context_loss_count)
drivers/mmc/host/omap_hsmmc.c:		context_loss = host->pdata->get_context_loss_count(host->dev);
drivers/mmc/host/omap_hsmmc.c:			mmc->index, host->context_loss, context_loss);
drivers/mmc/host/omap_hsmmc.c:	if (host->suspended) {
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, SYSCONFIG));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, CON));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, HCTL));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, SYSCTL));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, IE));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, ISE));
drivers/mmc/host/omap_hsmmc.c:			OMAP_HSMMC_READ(host->base, CAPA));
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_mark_last_busy(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_autosuspend(host->dev);
drivers/mmc/host/omap_hsmmc.c:	host->mmc	= mmc;
drivers/mmc/host/omap_hsmmc.c:	host->pdata	= pdata;
drivers/mmc/host/omap_hsmmc.c:	host->dev	= &pdev->dev;
drivers/mmc/host/omap_hsmmc.c:	host->use_dma	= 1;
drivers/mmc/host/omap_hsmmc.c:	host->dev->dma_mask = &pdata->dma_mask;
drivers/mmc/host/omap_hsmmc.c:	host->dma_ch	= -1;
drivers/mmc/host/omap_hsmmc.c:	host->irq	= irq;
drivers/mmc/host/omap_hsmmc.c:	host->slot_id	= 0;
drivers/mmc/host/omap_hsmmc.c:	host->mapbase	= res->start + pdata->reg_offset;
drivers/mmc/host/omap_hsmmc.c:	host->base	= ioremap(host->mapbase, SZ_4K);
drivers/mmc/host/omap_hsmmc.c:	host->power_mode = MMC_POWER_OFF;
drivers/mmc/host/omap_hsmmc.c:	host->next_data.cookie = 1;
drivers/mmc/host/omap_hsmmc.c:	spin_lock_init(&host->irq_lock);
drivers/mmc/host/omap_hsmmc.c:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap_hsmmc.c:	if (IS_ERR(host->fclk)) {
drivers/mmc/host/omap_hsmmc.c:		ret = PTR_ERR(host->fclk);
drivers/mmc/host/omap_hsmmc.c:		host->fclk = NULL;
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->controller_flags & OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) {
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_enable(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_set_autosuspend_delay(host->dev, MMC_AUTOSUSPEND_DELAY);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_use_autosuspend(host->dev);
drivers/mmc/host/omap_hsmmc.c:		host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
drivers/mmc/host/omap_hsmmc.c:		if (IS_ERR(host->dbclk))
drivers/mmc/host/omap_hsmmc.c:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:			host->got_dbclk = 1;
drivers/mmc/host/omap_hsmmc.c:		if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:			if (clk_enable(host->dbclk) != 0)
drivers/mmc/host/omap_hsmmc.c:				dev_dbg(mmc_dev(host->mmc), "Enabling debounce"
drivers/mmc/host/omap_hsmmc.c:		dev_err(mmc_dev(host->mmc), "cannot get DMA TX channel\n");
drivers/mmc/host/omap_hsmmc.c:	host->dma_line_tx = res->start;
drivers/mmc/host/omap_hsmmc.c:		dev_err(mmc_dev(host->mmc), "cannot get DMA RX channel\n");
drivers/mmc/host/omap_hsmmc.c:	host->dma_line_rx = res->start;
drivers/mmc/host/omap_hsmmc.c:	ret = request_irq(host->irq, omap_hsmmc_irq, 0,
drivers/mmc/host/omap_hsmmc.c:		dev_dbg(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");
drivers/mmc/host/omap_hsmmc.c:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:		host->use_reg = 1;
drivers/mmc/host/omap_hsmmc.c:			dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_mark_last_busy(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_autosuspend(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host->use_reg)
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->cleanup)
drivers/mmc/host/omap_hsmmc.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:	free_irq(host->irq, host);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_disable(host->dev);
drivers/mmc/host/omap_hsmmc.c:	clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk) {
drivers/mmc/host/omap_hsmmc.c:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:		clk_put(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	iounmap(host->base);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	mmc_remove_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:	if (host->use_reg)
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->cleanup)
drivers/mmc/host/omap_hsmmc.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:	free_irq(host->irq, host);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_disable(host->dev);
drivers/mmc/host/omap_hsmmc.c:	clk_put(host->fclk);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk) {
drivers/mmc/host/omap_hsmmc.c:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:		clk_put(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	mmc_free_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:	iounmap(host->base);
drivers/mmc/host/omap_hsmmc.c:	if (host && host->suspended)
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	host->suspended = 1;
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->suspend) {
drivers/mmc/host/omap_hsmmc.c:		ret = host->pdata->suspend(dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:			host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:		host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:		if (host->pdata->resume) {
drivers/mmc/host/omap_hsmmc.c:			ret = host->pdata->resume(dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:	if (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER)) {
drivers/mmc/host/omap_hsmmc.c:		OMAP_HSMMC_WRITE(host->base, HCTL,
drivers/mmc/host/omap_hsmmc.c:				OMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:		clk_disable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host && !host->suspended)
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_get_sync(host->dev);
drivers/mmc/host/omap_hsmmc.c:	if (host->got_dbclk)
drivers/mmc/host/omap_hsmmc.c:		clk_enable(host->dbclk);
drivers/mmc/host/omap_hsmmc.c:	if (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER))
drivers/mmc/host/omap_hsmmc.c:	if (host->pdata->resume) {
drivers/mmc/host/omap_hsmmc.c:		ret = host->pdata->resume(dev, host->slot_id);
drivers/mmc/host/omap_hsmmc.c:	ret = mmc_resume_host(host->mmc);
drivers/mmc/host/omap_hsmmc.c:		host->suspended = 0;
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_mark_last_busy(host->dev);
drivers/mmc/host/omap_hsmmc.c:	pm_runtime_put_autosuspend(host->dev);
drivers/mmc/host/pxamci.c:	host->vcc = regulator_get(mmc_dev(host->mmc), "vmmc");
drivers/mmc/host/pxamci.c:	if (IS_ERR(host->vcc))
drivers/mmc/host/pxamci.c:		host->vcc = NULL;
drivers/mmc/host/pxamci.c:		host->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);
drivers/mmc/host/pxamci.c:		if (host->pdata && host->pdata->ocr_mask)
drivers/mmc/host/pxamci.c:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/pxamci.c:	if (host->vcc == NULL) {
drivers/mmc/host/pxamci.c:		host->mmc->ocr_avail = host->pdata ?
drivers/mmc/host/pxamci.c:			host->pdata->ocr_mask :
drivers/mmc/host/pxamci.c:	if (host->vcc) {
drivers/mmc/host/pxamci.c:			ret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);
drivers/mmc/host/pxamci.c:			ret = mmc_regulator_set_ocr(host->mmc, host->vcc, 0);
drivers/mmc/host/pxamci.c:	if (!host->vcc && host->pdata &&
drivers/mmc/host/pxamci.c:	    gpio_is_valid(host->pdata->gpio_power)) {
drivers/mmc/host/pxamci.c:		on = ((1 << vdd) & host->pdata->ocr_mask);
drivers/mmc/host/pxamci.c:		gpio_set_value(host->pdata->gpio_power,
drivers/mmc/host/pxamci.c:			       !!on ^ host->pdata->gpio_power_invert);
drivers/mmc/host/pxamci.c:	if (!host->vcc && host->pdata && host->pdata->setpower)
drivers/mmc/host/pxamci.c:		host->pdata->setpower(mmc_dev(host->mmc), vdd);
drivers/mmc/host/pxamci.c:	if (readl(host->base + MMC_STAT) & STAT_CLK_EN) {
drivers/mmc/host/pxamci.c:		writel(STOP_CLOCK, host->base + MMC_STRPCL);
drivers/mmc/host/pxamci.c:			v = readl(host->base + MMC_STAT);
drivers/mmc/host/pxamci.c:			dev_err(mmc_dev(host->mmc), "unable to stop clock\n");
drivers/mmc/host/pxamci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/pxamci.c:	host->imask &= ~mask;
drivers/mmc/host/pxamci.c:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/pxamci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/pxamci.c:	host->imask |= mask;
drivers/mmc/host/pxamci.c:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/pxamci.c:	host->data = data;
drivers/mmc/host/pxamci.c:	writel(nob, host->base + MMC_NOB);
drivers/mmc/host/pxamci.c:	writel(data->blksz, host->base + MMC_BLKLEN);
drivers/mmc/host/pxamci.c:	clks = (unsigned long long)data->timeout_ns * host->clkrate;
drivers/mmc/host/pxamci.c:	timeout = (unsigned int)clks + (data->timeout_clks << host->clkrt);
drivers/mmc/host/pxamci.c:	writel((timeout + 255) / 256, host->base + MMC_RDTO);
drivers/mmc/host/pxamci.c:		host->dma_dir = DMA_FROM_DEVICE;
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrtx) = 0;
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrrx) = host->dma | DRCMR_MAPVLD;
drivers/mmc/host/pxamci.c:		host->dma_dir = DMA_TO_DEVICE;
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrrx) = 0;
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrtx) = host->dma | DRCMR_MAPVLD;
drivers/mmc/host/pxamci.c:	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/pxamci.c:				   host->dma_dir);
drivers/mmc/host/pxamci.c:	for (i = 0; i < host->dma_len; i++) {
drivers/mmc/host/pxamci.c:		host->sg_cpu[i].dcmd = dcmd | length;
drivers/mmc/host/pxamci.c:			host->sg_cpu[i].dcmd |= DCMD_ENDIRQEN;
drivers/mmc/host/pxamci.c:			host->sg_cpu[i].dsadr = host->res->start + MMC_RXFIFO;
drivers/mmc/host/pxamci.c:			host->sg_cpu[i].dtadr = sg_dma_address(&data->sg[i]);
drivers/mmc/host/pxamci.c:			host->sg_cpu[i].dsadr = sg_dma_address(&data->sg[i]);
drivers/mmc/host/pxamci.c:			host->sg_cpu[i].dtadr = host->res->start + MMC_TXFIFO;
drivers/mmc/host/pxamci.c:		host->sg_cpu[i].ddadr = host->sg_dma + (i + 1) *
drivers/mmc/host/pxamci.c:	host->sg_cpu[host->dma_len - 1].ddadr = DDADR_STOP;
drivers/mmc/host/pxamci.c:		DALGN |= (1 << host->dma);
drivers/mmc/host/pxamci.c:		DALGN &= ~(1 << host->dma);
drivers/mmc/host/pxamci.c:	DDADR(host->dma) = host->sg_dma;
drivers/mmc/host/pxamci.c:		DCSR(host->dma) = DCSR_RUN;
drivers/mmc/host/pxamci.c:	WARN_ON(host->cmd != NULL);
drivers/mmc/host/pxamci.c:	host->cmd = cmd;
drivers/mmc/host/pxamci.c:	writel(cmd->opcode, host->base + MMC_CMD);
drivers/mmc/host/pxamci.c:	writel(cmd->arg >> 16, host->base + MMC_ARGH);
drivers/mmc/host/pxamci.c:	writel(cmd->arg & 0xffff, host->base + MMC_ARGL);
drivers/mmc/host/pxamci.c:	writel(cmdat, host->base + MMC_CMDAT);
drivers/mmc/host/pxamci.c:	writel(host->clkrt, host->base + MMC_CLKRT);
drivers/mmc/host/pxamci.c:	writel(START_CLOCK, host->base + MMC_STRPCL);
drivers/mmc/host/pxamci.c:	host->mrq = NULL;
drivers/mmc/host/pxamci.c:	host->cmd = NULL;
drivers/mmc/host/pxamci.c:	host->data = NULL;
drivers/mmc/host/pxamci.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/pxamci.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/pxamci.c:	host->cmd = NULL;
drivers/mmc/host/pxamci.c:	v = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:		u32 w1 = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:		u32 w2 = readl(host->base + MMC_RES) & 0xffff;
drivers/mmc/host/pxamci.c:	if (host->data && !cmd->error) {
drivers/mmc/host/pxamci.c:		if (cpu_is_pxa27x() && host->data->flags & MMC_DATA_WRITE)
drivers/mmc/host/pxamci.c:			DCSR(host->dma) = DCSR_RUN;
drivers/mmc/host/pxamci.c:		pxamci_finish_request(host, host->mrq);
drivers/mmc/host/pxamci.c:	struct mmc_data *data = host->data;
drivers/mmc/host/pxamci.c:	DCSR(host->dma) = 0;
drivers/mmc/host/pxamci.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/pxamci.c:		     host->dma_dir);
drivers/mmc/host/pxamci.c:	host->data = NULL;
drivers/mmc/host/pxamci.c:	if (host->mrq->stop) {
drivers/mmc/host/pxamci.c:		pxamci_start_cmd(host, host->mrq->stop, host->cmdat);
drivers/mmc/host/pxamci.c:		pxamci_finish_request(host, host->mrq);
drivers/mmc/host/pxamci.c:	ireg = readl(host->base + MMC_I_REG) & ~readl(host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:		unsigned stat = readl(host->base + MMC_STAT);
drivers/mmc/host/pxamci.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/pxamci.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/pxamci.c:	host->mrq = mrq;
drivers/mmc/host/pxamci.c:	cmdat = host->cmdat;
drivers/mmc/host/pxamci.c:	host->cmdat &= ~CMDAT_INIT;
drivers/mmc/host/pxamci.c:	if (host->pdata && gpio_is_valid(host->pdata->gpio_card_ro)) {
drivers/mmc/host/pxamci.c:		if (host->pdata->gpio_card_ro_invert)
drivers/mmc/host/pxamci.c:			return !gpio_get_value(host->pdata->gpio_card_ro);
drivers/mmc/host/pxamci.c:			return gpio_get_value(host->pdata->gpio_card_ro);
drivers/mmc/host/pxamci.c:	if (host->pdata && host->pdata->get_ro)
drivers/mmc/host/pxamci.c:		return !!host->pdata->get_ro(mmc_dev(mmc));
drivers/mmc/host/pxamci.c:		unsigned long rate = host->clkrate;
drivers/mmc/host/pxamci.c:		if (host->clkrt == CLKRT_OFF)
drivers/mmc/host/pxamci.c:			clk_enable(host->clk);
drivers/mmc/host/pxamci.c:			host->clkrt = 7;
drivers/mmc/host/pxamci.c:			host->clkrt = fls(clk) - 1;
drivers/mmc/host/pxamci.c:		if (host->clkrt != CLKRT_OFF) {
drivers/mmc/host/pxamci.c:			host->clkrt = CLKRT_OFF;
drivers/mmc/host/pxamci.c:			clk_disable(host->clk);
drivers/mmc/host/pxamci.c:	if (host->power_mode != ios->power_mode) {
drivers/mmc/host/pxamci.c:		host->power_mode = ios->power_mode;
drivers/mmc/host/pxamci.c:			host->cmdat |= CMDAT_INIT;
drivers/mmc/host/pxamci.c:		host->cmdat |= CMDAT_SD_4DAT;
drivers/mmc/host/pxamci.c:		host->cmdat &= ~CMDAT_SD_4DAT;
drivers/mmc/host/pxamci.c:		host->clkrt, host->cmdat);
drivers/mmc/host/pxamci.c:		writel(BUF_PART_FULL, host->base + MMC_PRTBUF);
drivers/mmc/host/pxamci.c:		       mmc_hostname(host->mmc), dma, dcsr);
drivers/mmc/host/pxamci.c:		host->data->error = -EIO;
drivers/mmc/host/pxamci.c:	mmc_detect_change(devid, msecs_to_jiffies(host->pdata->detect_delay_ms));
drivers/mmc/host/pxamci.c:	host->mmc = mmc;
drivers/mmc/host/pxamci.c:	host->dma = -1;
drivers/mmc/host/pxamci.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/pxamci.c:	host->clkrt = CLKRT_OFF;
drivers/mmc/host/pxamci.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/pxamci.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/pxamci.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/pxamci.c:		host->clk = NULL;
drivers/mmc/host/pxamci.c:	host->clkrate = clk_get_rate(host->clk);
drivers/mmc/host/pxamci.c:	mmc->f_min = (host->clkrate + 63) / 64;
drivers/mmc/host/pxamci.c:	mmc->f_max = (mmc_has_26MHz()) ? 26000000 : host->clkrate;
drivers/mmc/host/pxamci.c:	host->cmdat = 0;
drivers/mmc/host/pxamci.c:		host->cmdat |= CMDAT_SDIO_INT_EN;
drivers/mmc/host/pxamci.c:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/pxamci.c:	if (!host->sg_cpu) {
drivers/mmc/host/pxamci.c:	spin_lock_init(&host->lock);
drivers/mmc/host/pxamci.c:	host->res = r;
drivers/mmc/host/pxamci.c:	host->irq = irq;
drivers/mmc/host/pxamci.c:	host->imask = MMC_I_MASK_ALL;
drivers/mmc/host/pxamci.c:	host->base = ioremap(r->start, SZ_4K);
drivers/mmc/host/pxamci.c:	if (!host->base) {
drivers/mmc/host/pxamci.c:	writel(0, host->base + MMC_SPI);
drivers/mmc/host/pxamci.c:	writel(64, host->base + MMC_RESTO);
drivers/mmc/host/pxamci.c:	writel(host->imask, host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:	host->dma = pxa_request_dma(DRIVER_NAME, DMA_PRIO_LOW,
drivers/mmc/host/pxamci.c:	if (host->dma < 0) {
drivers/mmc/host/pxamci.c:	ret = request_irq(host->irq, pxamci_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/pxamci.c:	host->dma_drcmrrx = dmarx->start;
drivers/mmc/host/pxamci.c:	host->dma_drcmrtx = dmatx->start;
drivers/mmc/host/pxamci.c:	if (host->pdata) {
drivers/mmc/host/pxamci.c:		gpio_cd = host->pdata->gpio_card_detect;
drivers/mmc/host/pxamci.c:		gpio_ro = host->pdata->gpio_card_ro;
drivers/mmc/host/pxamci.c:		gpio_power = host->pdata->gpio_power;
drivers/mmc/host/pxamci.c:				      host->pdata->gpio_power_invert);
drivers/mmc/host/pxamci.c:	if (host->pdata && host->pdata->init)
drivers/mmc/host/pxamci.c:		host->pdata->init(&pdev->dev, pxamci_detect_irq, mmc);
drivers/mmc/host/pxamci.c:	if (gpio_is_valid(gpio_power) && host->pdata->setpower)
drivers/mmc/host/pxamci.c:	if (gpio_is_valid(gpio_ro) && host->pdata->get_ro)
drivers/mmc/host/pxamci.c:		if (host->dma >= 0)
drivers/mmc/host/pxamci.c:			pxa_free_dma(host->dma);
drivers/mmc/host/pxamci.c:		if (host->base)
drivers/mmc/host/pxamci.c:			iounmap(host->base);
drivers/mmc/host/pxamci.c:		if (host->sg_cpu)
drivers/mmc/host/pxamci.c:			dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/pxamci.c:		if (host->clk)
drivers/mmc/host/pxamci.c:			clk_put(host->clk);
drivers/mmc/host/pxamci.c:		if (host->pdata) {
drivers/mmc/host/pxamci.c:			gpio_cd = host->pdata->gpio_card_detect;
drivers/mmc/host/pxamci.c:			gpio_ro = host->pdata->gpio_card_ro;
drivers/mmc/host/pxamci.c:			gpio_power = host->pdata->gpio_power;
drivers/mmc/host/pxamci.c:		if (host->vcc)
drivers/mmc/host/pxamci.c:			regulator_put(host->vcc);
drivers/mmc/host/pxamci.c:		if (host->pdata && host->pdata->exit)
drivers/mmc/host/pxamci.c:			host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/pxamci.c:		       host->base + MMC_I_MASK);
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrrx) = 0;
drivers/mmc/host/pxamci.c:		DRCMR(host->dma_drcmrtx) = 0;
drivers/mmc/host/pxamci.c:		free_irq(host->irq, host);
drivers/mmc/host/pxamci.c:		pxa_free_dma(host->dma);
drivers/mmc/host/pxamci.c:		iounmap(host->base);
drivers/mmc/host/pxamci.c:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/pxamci.c:		clk_put(host->clk);
drivers/mmc/host/pxamci.c:		release_resource(host->res);
drivers/mmc/host/s3cmci.c:		dev_err(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:		dev_info(&host->pdev->dev, args); \
drivers/mmc/host/s3cmci.c:		dev_dbg(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:	con 	= readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	pre 	= readl(host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:	cmdarg 	= readl(host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:	cmdcon 	= readl(host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:	cmdsta 	= readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:	r0 	= readl(host->base + S3C2410_SDIRSP0);
drivers/mmc/host/s3cmci.c:	r1 	= readl(host->base + S3C2410_SDIRSP1);
drivers/mmc/host/s3cmci.c:	r2 	= readl(host->base + S3C2410_SDIRSP2);
drivers/mmc/host/s3cmci.c:	r3 	= readl(host->base + S3C2410_SDIRSP3);
drivers/mmc/host/s3cmci.c:	timer 	= readl(host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:	bsize 	= readl(host->base + S3C2410_SDIBSIZE);
drivers/mmc/host/s3cmci.c:	datcon 	= readl(host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:	datcnt 	= readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:	datsta 	= readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:	fsta 	= readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:	imask   = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	snprintf(host->dbgmsg_cmd, 300,
drivers/mmc/host/s3cmci.c:		 host->ccnt, (stop ? " (STOP)" : ""),
drivers/mmc/host/s3cmci.c:		snprintf(host->dbgmsg_dat, 300,
drivers/mmc/host/s3cmci.c:			 host->dcnt, cmd->data->blksz,
drivers/mmc/host/s3cmci.c:		host->dbgmsg_dat[0] = '\0';
drivers/mmc/host/s3cmci.c:			host->dbgmsg_cmd, cmd->resp[0]);
drivers/mmc/host/s3cmci.c:			cmd->error, host->dbgmsg_cmd, host->status);
drivers/mmc/host/s3cmci.c:		dbg(host, dbglvl, "DAT[OK] %s\n", host->dbgmsg_dat);
drivers/mmc/host/s3cmci.c:			cmd->data->error, host->dbgmsg_dat,
drivers/mmc/host/s3cmci.c:			readl(host->base + S3C2410_SDIDCNT));
drivers/mmc/host/s3cmci.c:	return host->dodma;
drivers/mmc/host/s3cmci.c:	newmask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	writel(newmask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	newmask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	writel(newmask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	u32 mask = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	writel(mask, host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:	if (host->sdio_irqen) {
drivers/mmc/host/s3cmci.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/s3cmci.c:	if (host->pio_active == XFER_NONE)
drivers/mmc/host/s3cmci.c:	if ((!host->mrq) || (!host->mrq->data))
drivers/mmc/host/s3cmci.c:	if (host->pio_sgptr >= host->mrq->data->sg_len) {
drivers/mmc/host/s3cmci.c:		      host->pio_sgptr, host->mrq->data->sg_len);
drivers/mmc/host/s3cmci.c:	sg = &host->mrq->data->sg[host->pio_sgptr];
drivers/mmc/host/s3cmci.c:	host->pio_sgptr++;
drivers/mmc/host/s3cmci.c:	    host->pio_sgptr, host->mrq->data->sg_len);
drivers/mmc/host/s3cmci.c:	u32 fifostat = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:	u32 fifostat = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:	host->irq_enabled = more;
drivers/mmc/host/s3cmci.c:	host->irq_disabled = false;
drivers/mmc/host/s3cmci.c:	enable = more | host->sdio_irqen;
drivers/mmc/host/s3cmci.c:	if (host->irq_state != enable) {
drivers/mmc/host/s3cmci.c:		host->irq_state = enable;
drivers/mmc/host/s3cmci.c:			enable_irq(host->irq);
drivers/mmc/host/s3cmci.c:			disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:	host->irq_disabled = transfer;
drivers/mmc/host/s3cmci.c:	if (transfer && host->irq_state) {
drivers/mmc/host/s3cmci.c:		host->irq_state = false;
drivers/mmc/host/s3cmci.c:		disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:	from_ptr = host->base + host->sdidata;
drivers/mmc/host/s3cmci.c:		if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:			res = get_data_buffer(host, &host->pio_bytes,
drivers/mmc/host/s3cmci.c:					      &host->pio_ptr);
drivers/mmc/host/s3cmci.c:				host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:				host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:			    host->pio_bytes, host->pio_ptr);
drivers/mmc/host/s3cmci.c:		    fifo, host->pio_bytes,
drivers/mmc/host/s3cmci.c:		    readl(host->base + S3C2410_SDIDCNT));
drivers/mmc/host/s3cmci.c:		if (fifo >= host->pio_bytes)
drivers/mmc/host/s3cmci.c:			fifo = host->pio_bytes;
drivers/mmc/host/s3cmci.c:		host->pio_bytes -= fifo;
drivers/mmc/host/s3cmci.c:		host->pio_count += fifo;
drivers/mmc/host/s3cmci.c:		ptr = host->pio_ptr;
drivers/mmc/host/s3cmci.c:		host->pio_ptr = ptr;
drivers/mmc/host/s3cmci.c:			u8 *p = (u8 *)host->pio_ptr;
drivers/mmc/host/s3cmci.c:	if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:		res = get_data_buffer(host, &host->pio_bytes, &host->pio_ptr);
drivers/mmc/host/s3cmci.c:			host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:			host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:	to_ptr = host->base + host->sdidata;
drivers/mmc/host/s3cmci.c:		if (!host->pio_bytes) {
drivers/mmc/host/s3cmci.c:			res = get_data_buffer(host, &host->pio_bytes,
drivers/mmc/host/s3cmci.c:							&host->pio_ptr);
drivers/mmc/host/s3cmci.c:				host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:			    host->pio_bytes, host->pio_ptr);
drivers/mmc/host/s3cmci.c:		if (fifo >= host->pio_bytes)
drivers/mmc/host/s3cmci.c:			fifo = host->pio_bytes;
drivers/mmc/host/s3cmci.c:		host->pio_bytes -= fifo;
drivers/mmc/host/s3cmci.c:		host->pio_count += fifo;
drivers/mmc/host/s3cmci.c:		ptr = host->pio_ptr;
drivers/mmc/host/s3cmci.c:		host->pio_ptr = ptr;
drivers/mmc/host/s3cmci.c:	if (host->pio_active == XFER_WRITE)
drivers/mmc/host/s3cmci.c:	if (host->pio_active == XFER_READ)
drivers/mmc/host/s3cmci.c:	if (host->complete_what == COMPLETION_FINALIZE) {
drivers/mmc/host/s3cmci.c:		if (host->pio_active != XFER_NONE) {
drivers/mmc/host/s3cmci.c:			    (host->pio_active == XFER_READ) ? "read" : "write",
drivers/mmc/host/s3cmci.c:			    host->pio_count, host->pio_bytes);
drivers/mmc/host/s3cmci.c:			if (host->mrq->data)
drivers/mmc/host/s3cmci.c:				host->mrq->data->error = -EINVAL;
drivers/mmc/host/s3cmci.c: *   host->mrq 			points to current request
drivers/mmc/host/s3cmci.c: *   host->complete_what	Indicates when the request is considered done
drivers/mmc/host/s3cmci.c: *   host->complete_request	is the completion-object the driver waits for
drivers/mmc/host/s3cmci.c: * 1) Driver sets up host->mrq and host->complete_what
drivers/mmc/host/s3cmci.c: * 5) Driver waits for host->complete_rquest
drivers/mmc/host/s3cmci.c: * 6) ISR sets host->mrq->cmd->error and host->mrq->data->error
drivers/mmc/host/s3cmci.c: * 7) ISR completes host->complete_request
drivers/mmc/host/s3cmci.c:	mci_dsta = readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:	mci_imsk = readl(host->base + host->sdiimsk);
drivers/mmc/host/s3cmci.c:			writel(mci_dclear, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:			mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/s3cmci.c:	spin_lock_irqsave(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:	mci_csta = readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:	mci_dcnt = readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:	mci_fsta = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:	if ((host->complete_what == COMPLETION_NONE) ||
drivers/mmc/host/s3cmci.c:	    (host->complete_what == COMPLETION_FINALIZE)) {
drivers/mmc/host/s3cmci.c:		host->status = "nothing to complete";
drivers/mmc/host/s3cmci.c:	if (!host->mrq) {
drivers/mmc/host/s3cmci.c:		host->status = "no active mrq";
drivers/mmc/host/s3cmci.c:	cmd = host->cmd_is_stop ? host->mrq->stop : host->mrq->cmd;
drivers/mmc/host/s3cmci.c:		host->status = "no active cmd";
drivers/mmc/host/s3cmci.c:		if ((host->pio_active == XFER_WRITE) &&
drivers/mmc/host/s3cmci.c:			tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:			host->status = "pio tx";
drivers/mmc/host/s3cmci.c:		if ((host->pio_active == XFER_READ) &&
drivers/mmc/host/s3cmci.c:			tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:			host->status = "pio rx";
drivers/mmc/host/s3cmci.c:		host->status = "error: command timeout";
drivers/mmc/host/s3cmci.c:		if (host->complete_what == COMPLETION_CMDSENT) {
drivers/mmc/host/s3cmci.c:			host->status = "ok: command sent";
drivers/mmc/host/s3cmci.c:			if (host->mrq->cmd->flags & MMC_RSP_136) {
drivers/mmc/host/s3cmci.c:				 * host->status = "error: bad command crc";
drivers/mmc/host/s3cmci.c:		if (host->complete_what == COMPLETION_RSPFIN) {
drivers/mmc/host/s3cmci.c:			host->status = "ok: command response received";
drivers/mmc/host/s3cmci.c:		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
drivers/mmc/host/s3cmci.c:			host->complete_what = COMPLETION_XFERFINISH;
drivers/mmc/host/s3cmci.c:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:			host->mrq->data->error = -EILSEQ;
drivers/mmc/host/s3cmci.c:			host->status = "error: 2440 fifo failure";
drivers/mmc/host/s3cmci.c:			host->status = "error:  fifo failure";
drivers/mmc/host/s3cmci.c:		host->status = "error: bad data crc (outgoing)";
drivers/mmc/host/s3cmci.c:		host->status = "error: bad data crc (incoming)";
drivers/mmc/host/s3cmci.c:		host->status = "error: data timeout";
drivers/mmc/host/s3cmci.c:		if (host->complete_what == COMPLETION_XFERFINISH) {
drivers/mmc/host/s3cmci.c:			host->status = "ok: data transfer completed";
drivers/mmc/host/s3cmci.c:		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
drivers/mmc/host/s3cmci.c:			host->complete_what = COMPLETION_RSPFIN;
drivers/mmc/host/s3cmci.c:	writel(mci_cclear, host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:	writel(mci_dclear, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:	host->pio_active = XFER_NONE;
drivers/mmc/host/s3cmci.c:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:	tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:	    mci_csta, mci_dsta, mci_fsta, mci_dcnt, host->status);
drivers/mmc/host/s3cmci.c:	spin_unlock_irqrestore(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/s3cmci.c:	mci_csta = readl(host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:	mci_dsta = readl(host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:	mci_fsta = readl(host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:	mci_dcnt = readl(host->base + S3C2410_SDIDCNT);
drivers/mmc/host/s3cmci.c:	BUG_ON(!host->mrq);
drivers/mmc/host/s3cmci.c:	BUG_ON(!host->mrq->data);
drivers/mmc/host/s3cmci.c:	BUG_ON(!host->dmatogo);
drivers/mmc/host/s3cmci.c:	spin_lock_irqsave(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:			mci_dcnt, result, host->dmatogo);
drivers/mmc/host/s3cmci.c:	host->dmatogo--;
drivers/mmc/host/s3cmci.c:	if (host->dmatogo) {
drivers/mmc/host/s3cmci.c:			size, mci_dsta, mci_dcnt, host->dmatogo);
drivers/mmc/host/s3cmci.c:	host->dma_complete = 1;
drivers/mmc/host/s3cmci.c:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:	tasklet_schedule(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:	spin_unlock_irqrestore(&host->complete_lock, iflags);
drivers/mmc/host/s3cmci.c:	host->mrq->data->error = -EINVAL;
drivers/mmc/host/s3cmci.c:	host->complete_what = COMPLETION_FINALIZE;
drivers/mmc/host/s3cmci.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/s3cmci.c:	if (host->complete_what != COMPLETION_FINALIZE)
drivers/mmc/host/s3cmci.c:	cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
drivers/mmc/host/s3cmci.c:		if (s3cmci_host_usedma(host) && (!host->dma_complete)) {
drivers/mmc/host/s3cmci.c:			    host->dma_complete);
drivers/mmc/host/s3cmci.c:	cmd->resp[0] = readl(host->base + S3C2410_SDIRSP0);
drivers/mmc/host/s3cmci.c:	cmd->resp[1] = readl(host->base + S3C2410_SDIRSP1);
drivers/mmc/host/s3cmci.c:	cmd->resp[2] = readl(host->base + S3C2410_SDIRSP2);
drivers/mmc/host/s3cmci.c:	cmd->resp[3] = readl(host->base + S3C2410_SDIRSP3);
drivers/mmc/host/s3cmci.c:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:	writel(0, host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:	writel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:	writel(0, host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:	if (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {
drivers/mmc/host/s3cmci.c:		host->cmd_is_stop = 1;
drivers/mmc/host/s3cmci.c:		s3cmci_send_request(host->mmc);
drivers/mmc/host/s3cmci.c:			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:		if (host->is2440) {
drivers/mmc/host/s3cmci.c:			       host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:			mci_con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:			writel(mci_con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	host->complete_what = COMPLETION_NONE;
drivers/mmc/host/s3cmci.c:	host->mrq = NULL;
drivers/mmc/host/s3cmci.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/s3cmci.c:	s3c2410_dma_devconfig(host->dma, source,
drivers/mmc/host/s3cmci.c:			      host->mem->start + host->sdidata);
drivers/mmc/host/s3cmci.c:		s3c2410_dma_config(host->dma, 4);
drivers/mmc/host/s3cmci.c:		s3c2410_dma_set_buffdone_fn(host->dma,
drivers/mmc/host/s3cmci.c:		s3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);
drivers/mmc/host/s3cmci.c:		host->complete_what = COMPLETION_XFERFINISH_RSPFIN;
drivers/mmc/host/s3cmci.c:		host->complete_what = COMPLETION_RSPFIN;
drivers/mmc/host/s3cmci.c:		host->complete_what = COMPLETION_CMDSENT;
drivers/mmc/host/s3cmci.c:	writel(cmd->arg, host->base + S3C2410_SDICMDARG);
drivers/mmc/host/s3cmci.c:	writel(ccon, host->base + S3C2410_SDICMDCON);
drivers/mmc/host/s3cmci.c:		writel(0, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:	while (readl(host->base + S3C2410_SDIDSTA) &
drivers/mmc/host/s3cmci.c:		writel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:	if (host->bus_width == MMC_BUS_WIDTH_4)
drivers/mmc/host/s3cmci.c:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:	writel(dcon, host->base + S3C2410_SDIDCON);
drivers/mmc/host/s3cmci.c:	writel(data->blksz, host->base + S3C2410_SDIBSIZE);
drivers/mmc/host/s3cmci.c:	if (host->is2440) {
drivers/mmc/host/s3cmci.c:		writel(0x007FFFFF, host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:		writel(0x0000FFFF, host->base + S3C2410_SDITIMER);
drivers/mmc/host/s3cmci.c:			writel(0xFF, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:	host->pio_sgptr = 0;
drivers/mmc/host/s3cmci.c:	host->pio_bytes = 0;
drivers/mmc/host/s3cmci.c:	host->pio_count = 0;
drivers/mmc/host/s3cmci.c:	host->pio_active = rw ? XFER_WRITE : XFER_READ;
drivers/mmc/host/s3cmci.c:	s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:	dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/s3cmci.c:	host->dma_complete = 0;
drivers/mmc/host/s3cmci.c:	host->dmatogo = dma_len;
drivers/mmc/host/s3cmci.c:		res = s3c2410_dma_enqueue(host->dma, host,
drivers/mmc/host/s3cmci.c:			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
drivers/mmc/host/s3cmci.c:	s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_START);
drivers/mmc/host/s3cmci.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/s3cmci.c:	struct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
drivers/mmc/host/s3cmci.c:	host->ccnt++;
drivers/mmc/host/s3cmci.c:	prepare_dbgmsg(host, cmd, host->cmd_is_stop);
drivers/mmc/host/s3cmci.c:	writel(0xFFFFFFFF, host->base + S3C2410_SDICMDSTAT);
drivers/mmc/host/s3cmci.c:	writel(0xFFFFFFFF, host->base + S3C2410_SDIDSTA);
drivers/mmc/host/s3cmci.c:	writel(0xFFFFFFFF, host->base + S3C2410_SDIFSTA);
drivers/mmc/host/s3cmci.c:		host->dcnt++;
drivers/mmc/host/s3cmci.c:	struct s3c24xx_mci_pdata *pdata = host->pdata;
drivers/mmc/host/s3cmci.c:	host->status = "mmc request";
drivers/mmc/host/s3cmci.c:	host->cmd_is_stop = 0;
drivers/mmc/host/s3cmci.c:	host->mrq = mrq;
drivers/mmc/host/s3cmci.c:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/s3cmci.c:		host->real_rate = host->clk_rate / (host->clk_div*(mci_psc+1));
drivers/mmc/host/s3cmci.c:		if (host->real_rate <= ios->clock)
drivers/mmc/host/s3cmci.c:	host->prescaler = mci_psc;
drivers/mmc/host/s3cmci.c:	writel(host->prescaler, host->base + S3C2410_SDIPRE);
drivers/mmc/host/s3cmci.c:		host->real_rate = 0;
drivers/mmc/host/s3cmci.c:	mci_con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:		if (host->pdata->set_power)
drivers/mmc/host/s3cmci.c:			host->pdata->set_power(ios->power_mode, ios->vdd);
drivers/mmc/host/s3cmci.c:		if (!host->is2440)
drivers/mmc/host/s3cmci.c:		if (host->is2440)
drivers/mmc/host/s3cmci.c:		if (host->pdata->set_power)
drivers/mmc/host/s3cmci.c:			host->pdata->set_power(ios->power_mode, ios->vdd);
drivers/mmc/host/s3cmci.c:	writel(mci_con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:			host->real_rate/1000, ios->clock/1000);
drivers/mmc/host/s3cmci.c:	host->bus_width = ios->bus_width;
drivers/mmc/host/s3cmci.c:	u32 con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	writel(con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	struct s3c24xx_mci_pdata *pdata = host->pdata;
drivers/mmc/host/s3cmci.c:	con = readl(host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	host->sdio_irqen = enable;
drivers/mmc/host/s3cmci.c:	if (enable == host->sdio_irqen)
drivers/mmc/host/s3cmci.c:		if (!host->irq_state && !host->irq_disabled) {
drivers/mmc/host/s3cmci.c:			host->irq_state = true;
drivers/mmc/host/s3cmci.c:			enable_irq(host->irq);
drivers/mmc/host/s3cmci.c:		if (!host->irq_enabled && host->irq_state) {
drivers/mmc/host/s3cmci.c:			disable_irq_nosync(host->irq);
drivers/mmc/host/s3cmci.c:			host->irq_state = false;
drivers/mmc/host/s3cmci.c:	writel(con, host->base + S3C2410_SDICON);
drivers/mmc/host/s3cmci.c:	/* This is currently here to avoid a number of if (host->pdata)
drivers/mmc/host/s3cmci.c:	newclk = clk_get_rate(host->clk);
drivers/mmc/host/s3cmci.c:	mmc = host->mmc;
drivers/mmc/host/s3cmci.c:	if ((val == CPUFREQ_PRECHANGE && newclk > host->clk_rate) ||
drivers/mmc/host/s3cmci.c:	    (val == CPUFREQ_POSTCHANGE && newclk < host->clk_rate)) {
drivers/mmc/host/s3cmci.c:		host->clk_rate = newclk;
drivers/mmc/host/s3cmci.c:	host->freq_transition.notifier_call = s3cmci_cpufreq_transition;
drivers/mmc/host/s3cmci.c:	return cpufreq_register_notifier(&host->freq_transition,
drivers/mmc/host/s3cmci.c:	cpufreq_unregister_notifier(&host->freq_transition,
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "Register base = 0x%08x\n", (u32)host->base);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "Clock rate = %ld\n", host->clk_rate);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "Prescale = %d\n", host->prescaler);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "is2440 = %d\n", host->is2440);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "IRQ = %d\n", host->irq);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "IRQ enabled = %d\n", host->irq_enabled);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "IRQ disabled = %d\n", host->irq_disabled);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "IRQ state = %d\n", host->irq_state);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "CD IRQ = %d\n", host->irq_cd);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "SDIIMSK at %d\n", host->sdiimsk);
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "SDIDATA at %d\n", host->sdidata);
drivers/mmc/host/s3cmci.c:			   readl(host->base + rptr->addr));
drivers/mmc/host/s3cmci.c:	seq_printf(seq, "SDIIMSK\t=0x%08x\n", readl(host->base + host->sdiimsk));
drivers/mmc/host/s3cmci.c:	struct device *dev = &host->pdev->dev;
drivers/mmc/host/s3cmci.c:	host->debug_root = debugfs_create_dir(dev_name(dev), NULL);
drivers/mmc/host/s3cmci.c:	if (IS_ERR(host->debug_root)) {
drivers/mmc/host/s3cmci.c:	host->debug_state = debugfs_create_file("state", 0444,
drivers/mmc/host/s3cmci.c:						host->debug_root, host,
drivers/mmc/host/s3cmci.c:	if (IS_ERR(host->debug_state))
drivers/mmc/host/s3cmci.c:	host->debug_regs = debugfs_create_file("regs", 0444,
drivers/mmc/host/s3cmci.c:					       host->debug_root, host,
drivers/mmc/host/s3cmci.c:	if (IS_ERR(host->debug_regs))
drivers/mmc/host/s3cmci.c:	debugfs_remove(host->debug_regs);
drivers/mmc/host/s3cmci.c:	debugfs_remove(host->debug_state);
drivers/mmc/host/s3cmci.c:	debugfs_remove(host->debug_root);
drivers/mmc/host/s3cmci.c:	host->mmc 	= mmc;
drivers/mmc/host/s3cmci.c:	host->pdev	= pdev;
drivers/mmc/host/s3cmci.c:	host->is2440	= is2440;
drivers/mmc/host/s3cmci.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/s3cmci.c:	if (!host->pdata) {
drivers/mmc/host/s3cmci.c:		host->pdata = &s3cmci_def_pdata;
drivers/mmc/host/s3cmci.c:	spin_lock_init(&host->complete_lock);
drivers/mmc/host/s3cmci.c:	tasklet_init(&host->pio_tasklet, pio_tasklet, (unsigned long) host);
drivers/mmc/host/s3cmci.c:		host->sdiimsk	= S3C2440_SDIIMSK;
drivers/mmc/host/s3cmci.c:		host->sdidata	= S3C2440_SDIDATA;
drivers/mmc/host/s3cmci.c:		host->clk_div	= 1;
drivers/mmc/host/s3cmci.c:		host->sdiimsk	= S3C2410_SDIIMSK;
drivers/mmc/host/s3cmci.c:		host->sdidata	= S3C2410_SDIDATA;
drivers/mmc/host/s3cmci.c:		host->clk_div	= 2;
drivers/mmc/host/s3cmci.c:	host->complete_what 	= COMPLETION_NONE;
drivers/mmc/host/s3cmci.c:	host->pio_active 	= XFER_NONE;
drivers/mmc/host/s3cmci.c:	host->dodma		= host->pdata->use_dma;
drivers/mmc/host/s3cmci.c:	host->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/s3cmci.c:	if (!host->mem) {
drivers/mmc/host/s3cmci.c:	host->mem = request_mem_region(host->mem->start,
drivers/mmc/host/s3cmci.c:				       resource_size(host->mem), pdev->name);
drivers/mmc/host/s3cmci.c:	if (!host->mem) {
drivers/mmc/host/s3cmci.c:	host->base = ioremap(host->mem->start, resource_size(host->mem));
drivers/mmc/host/s3cmci.c:	if (!host->base) {
drivers/mmc/host/s3cmci.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/s3cmci.c:	if (host->irq == 0) {
drivers/mmc/host/s3cmci.c:	if (request_irq(host->irq, s3cmci_irq, 0, DRIVER_NAME, host)) {
drivers/mmc/host/s3cmci.c:	disable_irq(host->irq);
drivers/mmc/host/s3cmci.c:	host->irq_state = false;
drivers/mmc/host/s3cmci.c:	if (!host->pdata->no_detect) {
drivers/mmc/host/s3cmci.c:		ret = gpio_request(host->pdata->gpio_detect, "s3cmci detect");
drivers/mmc/host/s3cmci.c:		host->irq_cd = gpio_to_irq(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:		if (host->irq_cd >= 0) {
drivers/mmc/host/s3cmci.c:			if (request_irq(host->irq_cd, s3cmci_irq_cd,
drivers/mmc/host/s3cmci.c:			gpio_direction_input(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:		host->irq_cd = -1;
drivers/mmc/host/s3cmci.c:	if (!host->pdata->no_wprotect) {
drivers/mmc/host/s3cmci.c:		ret = gpio_request(host->pdata->gpio_wprotect, "s3cmci wp");
drivers/mmc/host/s3cmci.c:		gpio_direction_input(host->pdata->gpio_wprotect);
drivers/mmc/host/s3cmci.c:		host->dma = s3c2410_dma_request(DMACH_SDI, &s3cmci_dma_client,
drivers/mmc/host/s3cmci.c:		if (host->dma < 0) {
drivers/mmc/host/s3cmci.c:				host->dodma = 0;
drivers/mmc/host/s3cmci.c:	host->clk = clk_get(&pdev->dev, "sdi");
drivers/mmc/host/s3cmci.c:	if (IS_ERR(host->clk)) {
drivers/mmc/host/s3cmci.c:		ret = PTR_ERR(host->clk);
drivers/mmc/host/s3cmci.c:		host->clk = NULL;
drivers/mmc/host/s3cmci.c:	ret = clk_enable(host->clk);
drivers/mmc/host/s3cmci.c:	host->clk_rate = clk_get_rate(host->clk);
drivers/mmc/host/s3cmci.c:	mmc->f_min 	= host->clk_rate / (host->clk_div * 256);
drivers/mmc/host/s3cmci.c:	mmc->f_max 	= host->clk_rate / host->clk_div;
drivers/mmc/host/s3cmci.c:	if (host->pdata->ocr_avail)
drivers/mmc/host/s3cmci.c:		mmc->ocr_avail = host->pdata->ocr_avail;
drivers/mmc/host/s3cmci.c:	    (host->is2440?"2440":""),
drivers/mmc/host/s3cmci.c:	    host->base, host->irq, host->irq_cd, host->dma);
drivers/mmc/host/s3cmci.c:	clk_disable(host->clk);
drivers/mmc/host/s3cmci.c:	clk_put(host->clk);
drivers/mmc/host/s3cmci.c:		s3c2410_dma_free(host->dma, &s3cmci_dma_client);
drivers/mmc/host/s3cmci.c:	if (!host->pdata->no_wprotect)
drivers/mmc/host/s3cmci.c:		gpio_free(host->pdata->gpio_wprotect);
drivers/mmc/host/s3cmci.c:	if (!host->pdata->no_detect)
drivers/mmc/host/s3cmci.c:		gpio_free(host->pdata->gpio_detect);
drivers/mmc/host/s3cmci.c:	if (host->irq_cd >= 0)
drivers/mmc/host/s3cmci.c:		free_irq(host->irq_cd, host);
drivers/mmc/host/s3cmci.c:	free_irq(host->irq, host);
drivers/mmc/host/s3cmci.c:	iounmap(host->base);
drivers/mmc/host/s3cmci.c:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/s3cmci.c:	if (host->irq_cd >= 0)
drivers/mmc/host/s3cmci.c:		free_irq(host->irq_cd, host);
drivers/mmc/host/s3cmci.c:	clk_disable(host->clk);
drivers/mmc/host/s3cmci.c:	struct s3c24xx_mci_pdata *pd = host->pdata;
drivers/mmc/host/s3cmci.c:	clk_put(host->clk);
drivers/mmc/host/s3cmci.c:	tasklet_disable(&host->pio_tasklet);
drivers/mmc/host/s3cmci.c:		s3c2410_dma_free(host->dma, &s3cmci_dma_client);
drivers/mmc/host/s3cmci.c:	free_irq(host->irq, host);
drivers/mmc/host/s3cmci.c:	iounmap(host->base);
drivers/mmc/host/s3cmci.c:	release_mem_region(host->mem->start, resource_size(host->mem));
drivers/mmc/host/sdhci-cns3xxx.c:	struct device *dev = mmc_dev(host->mmc);
drivers/mmc/host/sdhci-cns3xxx.c:	if (clock == host->clock)
drivers/mmc/host/sdhci-cns3xxx.c:	while (host->max_clk / div > clock) {
drivers/mmc/host/sdhci-cns3xxx.c:		clock, host->max_clk / div);
drivers/mmc/host/sdhci-cns3xxx.c:	host->clock = clock;
drivers/mmc/host/sdhci-dove.c:		ret = readw(host->ioaddr + reg);
drivers/mmc/host/sdhci-dove.c:		ret = readl(host->ioaddr + reg);
drivers/mmc/host/sdhci-dove.c:		ret = readl(host->ioaddr + reg);
drivers/mmc/host/sdhci-esdhc-imx.c:	void __iomem *base = host->ioaddr + (reg & ~0x3);
drivers/mmc/host/sdhci-esdhc-imx.c:	struct pltfm_imx_data *imx_data = pltfm_host->priv;
drivers/mmc/host/sdhci-esdhc-imx.c:	u32 val = readl(host->ioaddr + reg);
drivers/mmc/host/sdhci-esdhc-imx.c:	struct pltfm_imx_data *imx_data = pltfm_host->priv;
drivers/mmc/host/sdhci-esdhc-imx.c:			data = readl(host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-esdhc-imx.c:			writel(data, host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-esdhc-imx.c:			writel(data, host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-esdhc-imx.c:			v = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
drivers/mmc/host/sdhci-esdhc-imx.c:			writel(v, host->ioaddr + SDHCI_VENDOR_SPEC);
drivers/mmc/host/sdhci-esdhc-imx.c:	writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci-esdhc-imx.c:		u16 val = readw(host->ioaddr + (reg ^ 2));
drivers/mmc/host/sdhci-esdhc-imx.c:	return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci-esdhc-imx.c:	struct pltfm_imx_data *imx_data = pltfm_host->priv;
drivers/mmc/host/sdhci-esdhc-imx.c:				&& (host->cmd->opcode == SD_IO_RW_EXTENDED)
drivers/mmc/host/sdhci-esdhc-imx.c:				&& (host->cmd->data->blocks > 1)
drivers/mmc/host/sdhci-esdhc-imx.c:				&& (host->cmd->data->flags & MMC_DATA_READ)) {
drivers/mmc/host/sdhci-esdhc-imx.c:			v = readl(host->ioaddr + SDHCI_VENDOR_SPEC);
drivers/mmc/host/sdhci-esdhc-imx.c:			writel(v, host->ioaddr + SDHCI_VENDOR_SPEC);
drivers/mmc/host/sdhci-esdhc-imx.c:		if ((host->cmd->opcode == MMC_STOP_TRANSMISSION ||
drivers/mmc/host/sdhci-esdhc-imx.c:		     host->cmd->opcode == MMC_SET_BLOCK_COUNT) &&
drivers/mmc/host/sdhci-esdhc-imx.c:			u32 m = readl(host->ioaddr + SDHCI_MIX_CTRL);
drivers/mmc/host/sdhci-esdhc-imx.c:			writel(m, host->ioaddr + SDHCI_MIX_CTRL);
drivers/mmc/host/sdhci-esdhc-imx.c:			       host->ioaddr + SDHCI_TRANSFER_MODE);
drivers/mmc/host/sdhci-esdhc-imx.c:			       host->ioaddr + SDHCI_TRANSFER_MODE);
drivers/mmc/host/sdhci-esdhc-imx.c:	return clk_get_rate(pltfm_host->clk);
drivers/mmc/host/sdhci-esdhc-imx.c:	return clk_get_rate(pltfm_host->clk) / 256 / 16;
drivers/mmc/host/sdhci-esdhc-imx.c:	struct pltfm_imx_data *imx_data = pltfm_host->priv;
drivers/mmc/host/sdhci-esdhc-imx.c:		return !(readl(host->ioaddr + SDHCI_PRESENT_STATE) &
drivers/mmc/host/sdhci-esdhc-imx.c:	tasklet_schedule(&sdhost->card_tasklet);
drivers/mmc/host/sdhci-esdhc-imx.c:	pltfm_host->priv = imx_data;
drivers/mmc/host/sdhci-esdhc-imx.c:	clk = clk_get(mmc_dev(host->mmc), NULL);
drivers/mmc/host/sdhci-esdhc-imx.c:		dev_err(mmc_dev(host->mmc), "clk err\n");
drivers/mmc/host/sdhci-esdhc-imx.c:	pltfm_host->clk = clk;
drivers/mmc/host/sdhci-esdhc-imx.c:	host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
drivers/mmc/host/sdhci-esdhc-imx.c:		host->quirks |= SDHCI_QUIRK_NO_MULTIBLOCK
drivers/mmc/host/sdhci-esdhc-imx.c:		writel(0x08100810, host->ioaddr + SDHCI_WTMK_LVL);
drivers/mmc/host/sdhci-esdhc-imx.c:		if (!host->mmc->parent->platform_data) {
drivers/mmc/host/sdhci-esdhc-imx.c:			dev_err(mmc_dev(host->mmc), "no board data!\n");
drivers/mmc/host/sdhci-esdhc-imx.c:					host->mmc->parent->platform_data);
drivers/mmc/host/sdhci-esdhc-imx.c:			dev_warn(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-esdhc-imx.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-esdhc-imx.c:				 mmc_hostname(host->mmc), host);
drivers/mmc/host/sdhci-esdhc-imx.c:			dev_err(mmc_dev(host->mmc), "request irq error\n");
drivers/mmc/host/sdhci-esdhc-imx.c:		host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-esdhc-imx.c:		host->mmc->caps = MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-esdhc-imx.c:	clk_disable_unprepare(pltfm_host->clk);
drivers/mmc/host/sdhci-esdhc-imx.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci-esdhc-imx.c:	struct pltfm_imx_data *imx_data = pltfm_host->priv;
drivers/mmc/host/sdhci-esdhc-imx.c:	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
drivers/mmc/host/sdhci-esdhc-imx.c:	clk_disable_unprepare(pltfm_host->clk);
drivers/mmc/host/sdhci-esdhc-imx.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci-esdhc.h:	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
drivers/mmc/host/sdhci-esdhc.h:	while (host->max_clk / pre_div / div > clock && div < 16)
drivers/mmc/host/sdhci-esdhc.h:	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
drivers/mmc/host/sdhci-esdhc.h:		clock, host->max_clk / pre_div / div);
drivers/mmc/host/sdhci-esdhc.h:	host->clock = clock;
drivers/mmc/host/sdhci-of-esdhc.c:		ret = in_be32(host->ioaddr + base) & 0xffff;
drivers/mmc/host/sdhci-of-esdhc.c:		ret = (in_be32(host->ioaddr + base) >> shift) & 0xffff;
drivers/mmc/host/sdhci-of-esdhc.c:	u8 ret = (in_be32(host->ioaddr + base) >> shift) & 0xff;
drivers/mmc/host/sdhci-of-esdhc.c:		dma_bits = in_be32(host->ioaddr + reg);
drivers/mmc/host/sdhci-of-esdhc.c:		clrsetbits_be32(host->ioaddr + reg , SDHCI_CTRL_DMA_MASK << 5,
drivers/mmc/host/sdhci-of-esdhc.c:		val |= in_be32(host->ioaddr + reg) & SDHCI_CTRL_DMA_MASK;
drivers/mmc/host/sdhci-of-esdhc.c:	setbits32(host->ioaddr + ESDHC_DMA_SYSCTL, ESDHC_DMA_SNOOP);
drivers/mmc/host/sdhci-of-esdhc.c:	return pltfm_host->clock;
drivers/mmc/host/sdhci-of-esdhc.c:	return pltfm_host->clock / 256 / 16;
drivers/mmc/host/sdhci-pci.c:	slot->host->caps =
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-pci.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC |
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-pci.c:	scratch = readb(host->ioaddr + 0xC0);
drivers/mmc/host/sdhci-pci.c:	writeb(scratch, host->ioaddr + 0xC0);
drivers/mmc/host/sdhci-pci.c:		version = readl(slot->host->ioaddr + SDHCI_HOST_VERSION);
drivers/mmc/host/sdhci-pci.c:			slot->host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;
drivers/mmc/host/sdhci-pci.c:		slot->host->ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34 |
drivers/mmc/host/sdhci-pci.c:		slot->host->ocr_avail_mmc = MMC_VDD_32_33 | MMC_VDD_33_34 |
drivers/mmc/host/sdhci-pci.c:	slot->host->mmc->caps |= MMC_CAP_BUS_WIDTH_TEST;
drivers/mmc/host/sdhci-pci.c:	u8 board_rev = readb(slot->host->ioaddr + SYSKT_BOARD_REV);
drivers/mmc/host/sdhci-pci.c:	u8  chip_rev = readb(slot->host->ioaddr + SYSKT_CHIP_REV);
drivers/mmc/host/sdhci-pci.c:		slot->host->quirks |= SDHCI_QUIRK_FORCE_DMA;
drivers/mmc/host/sdhci-pci.c:	writeb(SYSKT_POWER_330, slot->host->ioaddr + SYSKT_POWER_DATA);
drivers/mmc/host/sdhci-pci.c:	writeb(SYSKT_POWER_START, slot->host->ioaddr + SYSKT_POWER_CMD);
drivers/mmc/host/sdhci-pci.c:		ps = readw(slot->host->ioaddr + SYSKT_POWER_STATUS);
drivers/mmc/host/sdhci-pci.c:		writeb(0, slot->host->ioaddr + SYSKT_POWER_CMD);
drivers/mmc/host/sdhci-pci.c:		(host->flags & SDHCI_USE_SDMA)) {
drivers/mmc/host/sdhci-pci.c:		slot_pm_flags = slot->host->mmc->pm_flags;
drivers/mmc/host/sdhci-pci.c:	host->hw_name = "PCI";
drivers/mmc/host/sdhci-pci.c:	host->ops = &sdhci_pci_ops;
drivers/mmc/host/sdhci-pci.c:	host->quirks = chip->quirks;
drivers/mmc/host/sdhci-pci.c:	host->quirks2 = chip->quirks2;
drivers/mmc/host/sdhci-pci.c:	host->irq = pdev->irq;
drivers/mmc/host/sdhci-pci.c:	ret = pci_request_region(pdev, bar, mmc_hostname(host->mmc));
drivers/mmc/host/sdhci-pci.c:	host->ioaddr = pci_ioremap_bar(pdev, bar);
drivers/mmc/host/sdhci-pci.c:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-pci.c:			slot->host->mmc->caps |= MMC_CAP_HW_RESET;
drivers/mmc/host/sdhci-pci.c:	host->mmc->pm_caps = MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;
drivers/mmc/host/sdhci-pci.c:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-pci.c:	scratch = readl(slot->host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci-pltfm.c:			host->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
drivers/mmc/host/sdhci-pltfm.c:			host->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;
drivers/mmc/host/sdhci-pltfm.c:			host->quirks |= SDHCI_QUIRK_INVERTED_WRITE_PROTECT;
drivers/mmc/host/sdhci-pltfm.c:			host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
drivers/mmc/host/sdhci-pltfm.c:			host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
drivers/mmc/host/sdhci-pltfm.c:			pltfm_host->clock = be32_to_cpup(clk);
drivers/mmc/host/sdhci-pltfm.c:	host->hw_name = dev_name(&pdev->dev);
drivers/mmc/host/sdhci-pltfm.c:		host->ops = pdata->ops;
drivers/mmc/host/sdhci-pltfm.c:		host->ops = &sdhci_pltfm_ops;
drivers/mmc/host/sdhci-pltfm.c:		host->quirks = pdata->quirks;
drivers/mmc/host/sdhci-pltfm.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/sdhci-pltfm.c:		mmc_hostname(host->mmc))) {
drivers/mmc/host/sdhci-pltfm.c:	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
drivers/mmc/host/sdhci-pltfm.c:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-pltfm.c:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-pltfm.c:	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
drivers/mmc/host/sdhci-pltfm.h:	return in_be32(host->ioaddr + reg);
drivers/mmc/host/sdhci-pltfm.h:	return in_be16(host->ioaddr + (reg ^ 0x2));
drivers/mmc/host/sdhci-pltfm.h:	return in_8(host->ioaddr + (reg ^ 0x3));
drivers/mmc/host/sdhci-pltfm.h:	out_be32(host->ioaddr + reg, val);
drivers/mmc/host/sdhci-pltfm.h:		pltfm_host->xfer_mode_shadow = val;
drivers/mmc/host/sdhci-pltfm.h:				    val << 16 | pltfm_host->xfer_mode_shadow,
drivers/mmc/host/sdhci-pltfm.h:	clrsetbits_be32(host->ioaddr + base, 0xffff << shift, val << shift);
drivers/mmc/host/sdhci-pltfm.h:	clrsetbits_be32(host->ioaddr + base , 0xff << shift, val << shift);
drivers/mmc/host/sdhci-pxav2.c:	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
drivers/mmc/host/sdhci-pxav2.c:			tmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
drivers/mmc/host/sdhci-pxav2.c:			writew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
drivers/mmc/host/sdhci-pxav2.c:			tmp = readw(host->ioaddr + SD_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav2.c:			writew(tmp, host->ioaddr + SD_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav2.c:			tmp = readw(host->ioaddr + SD_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav2.c:			writew(tmp, host->ioaddr + SD_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav2.c:	ctrl = readb(host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-pxav2.c:	tmp = readw(host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav2.c:	writew(tmp, host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav2.c:	writeb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
drivers/mmc/host/sdhci-pxav2.c:	return clk_get_rate(pltfm_host->clk);
drivers/mmc/host/sdhci-pxav2.c:	pltfm_host->priv = pxa;
drivers/mmc/host/sdhci-pxav2.c:	pltfm_host->clk = clk;
drivers/mmc/host/sdhci-pxav2.c:	host->quirks = SDHCI_QUIRK_BROKEN_ADMA
drivers/mmc/host/sdhci-pxav2.c:			host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-pxav2.c:			host->mmc->caps |= MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-pxav2.c:			host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-pxav2.c:			host->quirks |= pdata->quirks;
drivers/mmc/host/sdhci-pxav2.c:			host->mmc->caps |= pdata->host_caps;
drivers/mmc/host/sdhci-pxav2.c:			host->mmc->pm_caps |= pdata->pm_caps;
drivers/mmc/host/sdhci-pxav2.c:	host->ops = &pxav2_sdhci_ops;
drivers/mmc/host/sdhci-pxav2.c:	struct sdhci_pxa *pxa = pltfm_host->priv;
drivers/mmc/host/sdhci-pxav2.c:	clk_disable(pltfm_host->clk);
drivers/mmc/host/sdhci-pxav2.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci-pxav3.c:	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
drivers/mmc/host/sdhci-pxav3.c:			tmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
drivers/mmc/host/sdhci-pxav3.c:			writew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
drivers/mmc/host/sdhci-pxav3.c:	struct sdhci_pxa *pxa = pltfm_host->priv;
drivers/mmc/host/sdhci-pxav3.c:		dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-pxav3.c:		tmp = readw(host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav3.c:		writew(tmp, host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav3.c:		tmp = readw(host->ioaddr + SD_CFG_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav3.c:		writew(tmp, host->ioaddr + SD_CFG_FIFO_PARAM);
drivers/mmc/host/sdhci-pxav3.c:			if ((readw(host->ioaddr + SD_CE_ATA_2)
drivers/mmc/host/sdhci-pxav3.c:			dev_warn(mmc_dev(host->mmc), "74 clock interrupt not cleared\n");
drivers/mmc/host/sdhci-pxav3.c:		tmp = readw(host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav3.c:		writew(tmp, host->ioaddr + SD_CE_ATA_2);
drivers/mmc/host/sdhci-pxav3.c:	dev_dbg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-pxav3.c:	pltfm_host->priv = pxa;
drivers/mmc/host/sdhci-pxav3.c:	pltfm_host->clk = clk;
drivers/mmc/host/sdhci-pxav3.c:	host->quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
drivers/mmc/host/sdhci-pxav3.c:	host->mmc->caps |= MMC_CAP_1_8V_DDR;
drivers/mmc/host/sdhci-pxav3.c:			host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-pxav3.c:			host->mmc->caps |= MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-pxav3.c:			host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-pxav3.c:			host->quirks |= pdata->quirks;
drivers/mmc/host/sdhci-pxav3.c:			host->mmc->caps |= pdata->host_caps;
drivers/mmc/host/sdhci-pxav3.c:			host->mmc->pm_caps |= pdata->pm_caps;
drivers/mmc/host/sdhci-pxav3.c:	host->ops = &pxav3_sdhci_ops;
drivers/mmc/host/sdhci-pxav3.c:	struct sdhci_pxa *pxa = pltfm_host->priv;
drivers/mmc/host/sdhci-pxav3.c:	clk_disable(pltfm_host->clk);
drivers/mmc/host/sdhci-pxav3.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci-s3c.c:	u32 tmp = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:	if (get_curclk(tmp) != ourhost->cur_clk) {
drivers/mmc/host/sdhci-s3c.c:		dev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");
drivers/mmc/host/sdhci-s3c.c:		tmp |= ourhost->cur_clk << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
drivers/mmc/host/sdhci-s3c.c:		writel(tmp, host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:		busclk = ourhost->clk_bus[clk];
drivers/mmc/host/sdhci-s3c.c:	struct clk *clksrc = ourhost->clk_bus[src];
drivers/mmc/host/sdhci-s3c.c:	if (ourhost->host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK) {
drivers/mmc/host/sdhci-s3c.c:	dev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",
drivers/mmc/host/sdhci-s3c.c:	dev_dbg(&ourhost->pdev->dev,
drivers/mmc/host/sdhci-s3c.c:	if (ourhost->cur_clk != best_src) {
drivers/mmc/host/sdhci-s3c.c:		struct clk *clk = ourhost->clk_bus[best_src];
drivers/mmc/host/sdhci-s3c.c:		writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
drivers/mmc/host/sdhci-s3c.c:		ourhost->cur_clk = best_src;
drivers/mmc/host/sdhci-s3c.c:		host->max_clk = clk_get_rate(clk);
drivers/mmc/host/sdhci-s3c.c:		ctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:		writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:		host->ioaddr + S3C64XX_SDHCI_CONTROL4);
drivers/mmc/host/sdhci-s3c.c:	ctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:	writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);
drivers/mmc/host/sdhci-s3c.c:	writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL3);
drivers/mmc/host/sdhci-s3c.c:	return clk_round_rate(ourhost->clk_bus[ourhost->cur_clk], UINT_MAX);
drivers/mmc/host/sdhci-s3c.c:	return clk_round_rate(ourhost->clk_bus[ourhost->cur_clk], 400000);
drivers/mmc/host/sdhci-s3c.c:	clk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);
drivers/mmc/host/sdhci-s3c.c:	host->clock = clock;
drivers/mmc/host/sdhci-s3c.c:				"stabilised.\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci-s3c.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci-s3c.c:			host->flags &= ~SDHCI_DEVICE_DEAD;
drivers/mmc/host/sdhci-s3c.c:			host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-s3c.c:			host->flags |= SDHCI_DEVICE_DEAD;
drivers/mmc/host/sdhci-s3c.c:			host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-s3c.c:		tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/sdhci-s3c.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci-s3c.c:	host->ioaddr = devm_request_and_ioremap(&pdev->dev, res);
drivers/mmc/host/sdhci-s3c.c:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-s3c.c:	host->hw_name = "samsung-hsmmc";
drivers/mmc/host/sdhci-s3c.c:	host->ops = &sdhci_s3c_ops;
drivers/mmc/host/sdhci-s3c.c:	host->quirks = 0;
drivers/mmc/host/sdhci-s3c.c:	host->irq = irq;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_NO_HISPD_BIT;
drivers/mmc/host/sdhci-s3c.c:		host->quirks |= drv_data->sdhci_quirks;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_NO_BUSY_IRQ;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC;
drivers/mmc/host/sdhci-s3c.c:		host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
drivers/mmc/host/sdhci-s3c.c:		host->mmc->caps = MMC_CAP_NONREMOVABLE;
drivers/mmc/host/sdhci-s3c.c:		host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-s3c.c:		host->mmc->caps |= MMC_CAP_4_BIT_DATA;
drivers/mmc/host/sdhci-s3c.c:		host->mmc->pm_caps |= pdata->pm_caps;
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |
drivers/mmc/host/sdhci-s3c.c:	host->quirks |= SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;
drivers/mmc/host/sdhci-s3c.c:	if (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK) {
drivers/mmc/host/sdhci-s3c.c:		host->mmc->caps |= pdata->host_caps;
drivers/mmc/host/sdhci-s3c.c:		host->mmc->caps2 |= pdata->host_caps2;
drivers/mmc/host/sdhci-spear.c:	tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/sdhci-spear.c:	host->hw_name = "sdhci";
drivers/mmc/host/sdhci-spear.c:	host->ops = &sdhci_pltfm_ops;
drivers/mmc/host/sdhci-spear.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mmc/host/sdhci-spear.c:	host->quirks = SDHCI_QUIRK_BROKEN_ADMA;
drivers/mmc/host/sdhci-spear.c:	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
drivers/mmc/host/sdhci-spear.c:	if (!host->ioaddr) {
drivers/mmc/host/sdhci-spear.c:				mmc_hostname(host->mmc), pdev);
drivers/mmc/host/sdhci-spear.c:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-spear.c:	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
drivers/mmc/host/sdhci-spear.c:	iounmap(host->ioaddr);
drivers/mmc/host/sdhci-tegra.c:		val = readl(host->ioaddr + reg);
drivers/mmc/host/sdhci-tegra.c:	return readl(host->ioaddr + reg);
drivers/mmc/host/sdhci-tegra.c:	struct sdhci_tegra *tegra_host = pltfm_host->priv;
drivers/mmc/host/sdhci-tegra.c:	const struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;
drivers/mmc/host/sdhci-tegra.c:	return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci-tegra.c:	struct sdhci_tegra *tegra_host = pltfm_host->priv;
drivers/mmc/host/sdhci-tegra.c:	const struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;
drivers/mmc/host/sdhci-tegra.c:	writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci-tegra.c:		u8 gap_ctrl = readb(host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);
drivers/mmc/host/sdhci-tegra.c:		writeb(gap_ctrl, host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);
drivers/mmc/host/sdhci-tegra.c:	struct sdhci_tegra *tegra_host = pltfm_host->priv;
drivers/mmc/host/sdhci-tegra.c:	const struct tegra_sdhci_platform_data *plat = tegra_host->plat;
drivers/mmc/host/sdhci-tegra.c:	tasklet_schedule(&sdhost->card_tasklet);
drivers/mmc/host/sdhci-tegra.c:	struct sdhci_tegra *tegra_host = pltfm_host->priv;
drivers/mmc/host/sdhci-tegra.c:	const struct tegra_sdhci_platform_data *plat = tegra_host->plat;
drivers/mmc/host/sdhci-tegra.c:		dev_err(mmc_dev(host->mmc), "missing platform data\n");
drivers/mmc/host/sdhci-tegra.c:		dev_err(mmc_dev(host->mmc), "failed to allocate tegra_host\n");
drivers/mmc/host/sdhci-tegra.c:	tegra_host->plat = plat;
drivers/mmc/host/sdhci-tegra.c:	tegra_host->soc_data = soc_data;
drivers/mmc/host/sdhci-tegra.c:	pltfm_host->priv = tegra_host;
drivers/mmc/host/sdhci-tegra.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-tegra.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-tegra.c:				 mmc_hostname(host->mmc), host);
drivers/mmc/host/sdhci-tegra.c:			dev_err(mmc_dev(host->mmc), "request irq error\n");
drivers/mmc/host/sdhci-tegra.c:			dev_err(mmc_dev(host->mmc),
drivers/mmc/host/sdhci-tegra.c:	clk = clk_get(mmc_dev(host->mmc), NULL);
drivers/mmc/host/sdhci-tegra.c:		dev_err(mmc_dev(host->mmc), "clk err\n");
drivers/mmc/host/sdhci-tegra.c:	pltfm_host->clk = clk;
drivers/mmc/host/sdhci-tegra.c:	host->mmc->pm_caps = plat->pm_flags;
drivers/mmc/host/sdhci-tegra.c:		host->mmc->caps |= MMC_CAP_8_BIT_DATA;
drivers/mmc/host/sdhci-tegra.c:	clk_disable(pltfm_host->clk);
drivers/mmc/host/sdhci-tegra.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci-tegra.c:	struct sdhci_tegra *tegra_host = pltfm_host->priv;
drivers/mmc/host/sdhci-tegra.c:	const struct tegra_sdhci_platform_data *plat = tegra_host->plat;
drivers/mmc/host/sdhci-tegra.c:	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
drivers/mmc/host/sdhci-tegra.c:	clk_disable(pltfm_host->clk);
drivers/mmc/host/sdhci-tegra.c:	clk_put(pltfm_host->clk);
drivers/mmc/host/sdhci.c:		mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
drivers/mmc/host/sdhci.c:		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
drivers/mmc/host/sdhci.c:	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) ||
drivers/mmc/host/sdhci.c:	    (host->mmc->caps & MMC_CAP_NONREMOVABLE))
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_NO_CARD_NO_RESET) {
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
drivers/mmc/host/sdhci.c:	if (host->ops->platform_reset_enter)
drivers/mmc/host/sdhci.c:		host->ops->platform_reset_enter(host, mask);
drivers/mmc/host/sdhci.c:		host->clock = 0;
drivers/mmc/host/sdhci.c:				mmc_hostname(host->mmc), (int)mask);
drivers/mmc/host/sdhci.c:	if (host->ops->platform_reset_exit)
drivers/mmc/host/sdhci.c:		host->ops->platform_reset_exit(host, mask);
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_RESTORE_IRQS_AFTER_RESET)
drivers/mmc/host/sdhci.c:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:		if ((host->ops->enable_dma) && (mask & SDHCI_RESET_ALL))
drivers/mmc/host/sdhci.c:			host->ops->enable_dma(host);
drivers/mmc/host/sdhci.c:		host->clock = 0;
drivers/mmc/host/sdhci.c:		sdhci_set_ios(host->mmc, &host->mmc->ios);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->runtime_suspended)
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	blksize = host->data->blksz;
drivers/mmc/host/sdhci.c:		if (!sg_miter_next(&host->sg_miter))
drivers/mmc/host/sdhci.c:		len = min(host->sg_miter.length, blksize);
drivers/mmc/host/sdhci.c:		host->sg_miter.consumed = len;
drivers/mmc/host/sdhci.c:		buf = host->sg_miter.addr;
drivers/mmc/host/sdhci.c:	sg_miter_stop(&host->sg_miter);
drivers/mmc/host/sdhci.c:	blksize = host->data->blksz;
drivers/mmc/host/sdhci.c:		if (!sg_miter_next(&host->sg_miter))
drivers/mmc/host/sdhci.c:		len = min(host->sg_miter.length, blksize);
drivers/mmc/host/sdhci.c:		host->sg_miter.consumed = len;
drivers/mmc/host/sdhci.c:		buf = host->sg_miter.addr;
drivers/mmc/host/sdhci.c:	sg_miter_stop(&host->sg_miter);
drivers/mmc/host/sdhci.c:	BUG_ON(!host->data);
drivers/mmc/host/sdhci.c:	if (host->blocks == 0)
drivers/mmc/host/sdhci.c:	if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:	if ((host->quirks & SDHCI_QUIRK_BROKEN_SMALL_PIO) &&
drivers/mmc/host/sdhci.c:		(host->data->blocks == 1))
drivers/mmc/host/sdhci.c:		if (host->quirks & SDHCI_QUIRK_PIO_NEEDS_DELAY)
drivers/mmc/host/sdhci.c:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:		host->blocks--;
drivers/mmc/host/sdhci.c:		if (host->blocks == 0)
drivers/mmc/host/sdhci.c:	host->align_addr = dma_map_single(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:		host->align_buffer, 128 * 4, direction);
drivers/mmc/host/sdhci.c:	if (dma_mapping_error(mmc_dev(host->mmc), host->align_addr))
drivers/mmc/host/sdhci.c:	BUG_ON(host->align_addr & 0x3);
drivers/mmc/host/sdhci.c:	host->sg_count = dma_map_sg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:	if (host->sg_count == 0)
drivers/mmc/host/sdhci.c:	desc = host->adma_desc;
drivers/mmc/host/sdhci.c:	align = host->align_buffer;
drivers/mmc/host/sdhci.c:	align_addr = host->align_addr;
drivers/mmc/host/sdhci.c:	for_each_sg(data->sg, sg, host->sg_count, i) {
drivers/mmc/host/sdhci.c:		WARN_ON((desc - host->adma_desc) > (128 * 2 + 1) * 4);
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC) {
drivers/mmc/host/sdhci.c:		if (desc != host->adma_desc) {
drivers/mmc/host/sdhci.c:		dma_sync_single_for_device(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:			host->align_addr, 128 * 4, direction);
drivers/mmc/host/sdhci.c:	host->adma_addr = dma_map_single(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:		host->adma_desc, (128 * 2 + 1) * 4, DMA_TO_DEVICE);
drivers/mmc/host/sdhci.c:	if (dma_mapping_error(mmc_dev(host->mmc), host->adma_addr))
drivers/mmc/host/sdhci.c:	BUG_ON(host->adma_addr & 0x3);
drivers/mmc/host/sdhci.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:	dma_unmap_single(mmc_dev(host->mmc), host->align_addr,
drivers/mmc/host/sdhci.c:	dma_unmap_single(mmc_dev(host->mmc), host->adma_addr,
drivers/mmc/host/sdhci.c:	dma_unmap_single(mmc_dev(host->mmc), host->align_addr,
drivers/mmc/host/sdhci.c:		dma_sync_sg_for_cpu(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:		align = host->align_buffer;
drivers/mmc/host/sdhci.c:		for_each_sg(data->sg, sg, host->sg_count, i) {
drivers/mmc/host/sdhci.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_BROKEN_TIMEOUT_VAL)
drivers/mmc/host/sdhci.c:		if (host->clock)
drivers/mmc/host/sdhci.c:			target_timeout += data->timeout_clks / host->clock;
drivers/mmc/host/sdhci.c:	 * (2) host->timeout_clk < 2^16
drivers/mmc/host/sdhci.c:	current_timeout = (1 << 13) * 1000 / host->timeout_clk;
drivers/mmc/host/sdhci.c:		       mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA)
drivers/mmc/host/sdhci.c:	WARN_ON(host->data);
drivers/mmc/host/sdhci.c:	BUG_ON(data->blksz > host->mmc->max_blk_size);
drivers/mmc/host/sdhci.c:	host->data = data;
drivers/mmc/host/sdhci.c:	host->data_early = 0;
drivers/mmc/host/sdhci.c:	host->data->bytes_xfered = 0;
drivers/mmc/host/sdhci.c:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA))
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:			if (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE)
drivers/mmc/host/sdhci.c:			if (host->quirks & SDHCI_QUIRK_32BIT_DMA_SIZE)
drivers/mmc/host/sdhci.c:					host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:			if (host->quirks & SDHCI_QUIRK_32BIT_ADMA_SIZE)
drivers/mmc/host/sdhci.c:			if (host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR)
drivers/mmc/host/sdhci.c:					host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:		if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:				host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:				sdhci_writel(host, host->adma_addr,
drivers/mmc/host/sdhci.c:			sg_cnt = dma_map_sg(mmc_dev(host->mmc),
drivers/mmc/host/sdhci.c:				host->flags &= ~SDHCI_REQ_USE_DMA;
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_200) {
drivers/mmc/host/sdhci.c:		if ((host->flags & SDHCI_REQ_USE_DMA) &&
drivers/mmc/host/sdhci.c:			(host->flags & SDHCI_USE_ADMA))
drivers/mmc/host/sdhci.c:	if (!(host->flags & SDHCI_REQ_USE_DMA)) {
drivers/mmc/host/sdhci.c:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/sdhci.c:		sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
drivers/mmc/host/sdhci.c:		host->blocks = data->blocks;
drivers/mmc/host/sdhci.c:	WARN_ON(!host->data);
drivers/mmc/host/sdhci.c:		if (!host->mrq->sbc && (host->flags & SDHCI_AUTO_CMD12))
drivers/mmc/host/sdhci.c:		else if (host->mrq->sbc && (host->flags & SDHCI_AUTO_CMD23)) {
drivers/mmc/host/sdhci.c:			sdhci_writel(host, host->mrq->sbc->arg, SDHCI_ARGUMENT2);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA)
drivers/mmc/host/sdhci.c:	BUG_ON(!host->data);
drivers/mmc/host/sdhci.c:	data = host->data;
drivers/mmc/host/sdhci.c:	host->data = NULL;
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_REQ_USE_DMA) {
drivers/mmc/host/sdhci.c:		if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
drivers/mmc/host/sdhci.c:	     !host->mrq->sbc)) {
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	WARN_ON(host->cmd);
drivers/mmc/host/sdhci.c:	if (host->mrq->data && (cmd == host->mrq->data->stop))
drivers/mmc/host/sdhci.c:				"inhibit bit(s).\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	mod_timer(&host->timer, jiffies + 10 * HZ);
drivers/mmc/host/sdhci.c:	host->cmd = cmd;
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	BUG_ON(host->cmd == NULL);
drivers/mmc/host/sdhci.c:	if (host->cmd->flags & MMC_RSP_PRESENT) {
drivers/mmc/host/sdhci.c:		if (host->cmd->flags & MMC_RSP_136) {
drivers/mmc/host/sdhci.c:				host->cmd->resp[i] = sdhci_readl(host,
drivers/mmc/host/sdhci.c:					host->cmd->resp[i] |=
drivers/mmc/host/sdhci.c:			host->cmd->resp[0] = sdhci_readl(host, SDHCI_RESPONSE);
drivers/mmc/host/sdhci.c:	host->cmd->error = 0;
drivers/mmc/host/sdhci.c:	if (host->cmd == host->mrq->sbc) {
drivers/mmc/host/sdhci.c:		host->cmd = NULL;
drivers/mmc/host/sdhci.c:		sdhci_send_command(host, host->mrq->cmd);
drivers/mmc/host/sdhci.c:		if (host->data && host->data_early)
drivers/mmc/host/sdhci.c:		if (!host->cmd->data)
drivers/mmc/host/sdhci.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:		host->cmd = NULL;
drivers/mmc/host/sdhci.c:	if (clock && clock == host->clock)
drivers/mmc/host/sdhci.c:	host->mmc->actual_clock = 0;
drivers/mmc/host/sdhci.c:	if (host->ops->set_clock) {
drivers/mmc/host/sdhci.c:		host->ops->set_clock(host, clock);
drivers/mmc/host/sdhci.c:		if (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK)
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300) {
drivers/mmc/host/sdhci.c:		if (host->clk_mul) {
drivers/mmc/host/sdhci.c:					if (((host->max_clk * host->clk_mul) /
drivers/mmc/host/sdhci.c:				clk_mul = host->clk_mul;
drivers/mmc/host/sdhci.c:			if (host->max_clk <= clock)
drivers/mmc/host/sdhci.c:					if ((host->max_clk / div) <= clock)
drivers/mmc/host/sdhci.c:			if ((host->max_clk / div) <= clock)
drivers/mmc/host/sdhci.c:		host->mmc->actual_clock = (host->max_clk * clk_mul) / real_div;
drivers/mmc/host/sdhci.c:				"stabilised.\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:	host->clock = clock;
drivers/mmc/host/sdhci.c:	if (host->pwr == pwr)
drivers/mmc/host/sdhci.c:	host->pwr = pwr;
drivers/mmc/host/sdhci.c:	if (!(host->quirks & SDHCI_QUIRK_SINGLE_POWER_WRITE))
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER)
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_DELAY_AFTER_POWER)
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/sdhci.c:	if (!mrq->sbc && (host->flags & SDHCI_AUTO_CMD12)) {
drivers/mmc/host/sdhci.c:	host->mrq = mrq;
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
drivers/mmc/host/sdhci.c:	if (!present || host->flags & SDHCI_DEVICE_DEAD) {
drivers/mmc/host/sdhci.c:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:		if ((host->flags & SDHCI_NEEDS_RETUNING) &&
drivers/mmc/host/sdhci.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:			spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:			host->mrq = mrq;
drivers/mmc/host/sdhci.c:		if (mrq->sbc && !(host->flags & SDHCI_AUTO_CMD23))
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_DEVICE_DEAD) {
drivers/mmc/host/sdhci.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:		if (host->vmmc && ios->power_mode == MMC_POWER_OFF)
drivers/mmc/host/sdhci.c:			mmc_regulator_set_ocr(host->mmc, host->vmmc, 0);
drivers/mmc/host/sdhci.c:	if (host->vmmc && vdd_bit != -1) {
drivers/mmc/host/sdhci.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:		mmc_regulator_set_ocr(host->mmc, host->vmmc, vdd_bit);
drivers/mmc/host/sdhci.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->ops->platform_send_init_74_clocks)
drivers/mmc/host/sdhci.c:		host->ops->platform_send_init_74_clocks(host, ios->power_mode);
drivers/mmc/host/sdhci.c:	if (host->ops->platform_8bit_width)
drivers/mmc/host/sdhci.c:		host->ops->platform_8bit_width(host, ios->bus_width);
drivers/mmc/host/sdhci.c:			if (host->version >= SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:			if (host->version >= SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:	    && !(host->quirks & SDHCI_QUIRK_NO_HISPD_BIT))
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300) {
drivers/mmc/host/sdhci.c:			clock = host->clock;
drivers/mmc/host/sdhci.c:			host->clock = 0;
drivers/mmc/host/sdhci.c:		if (host->ops->set_uhs_signaling)
drivers/mmc/host/sdhci.c:			host->ops->set_uhs_signaling(host, ios->timing);
drivers/mmc/host/sdhci.c:		clock = host->clock;
drivers/mmc/host/sdhci.c:		host->clock = 0;
drivers/mmc/host/sdhci.c:	if(host->quirks & SDHCI_QUIRK_RESET_CMD_DATA_ON_IOS)
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_DEVICE_DEAD)
drivers/mmc/host/sdhci.c:	else if (host->ops->get_ro)
drivers/mmc/host/sdhci.c:		is_readonly = host->ops->get_ro(host);
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	return host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT ?
drivers/mmc/host/sdhci.c:	if (!(host->quirks & SDHCI_QUIRK_UNSTABLE_RO_DETECT))
drivers/mmc/host/sdhci.c:	if (host->ops && host->ops->hw_reset)
drivers/mmc/host/sdhci.c:		host->ops->hw_reset(host);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_DEVICE_DEAD)
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_SDIO_IRQ_ENABLED;
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_SDIO_IRQ_ENABLED;
drivers/mmc/host/sdhci.c:	if (host->runtime_suspended)
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->version < SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:	if (host->version < SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:	disable_irq(host->irq);
drivers/mmc/host/sdhci.c:	spin_lock(&host->lock);
drivers/mmc/host/sdhci.c:	    (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
drivers/mmc/host/sdhci.c:	     host->flags & SDHCI_HS200_NEEDS_TUNING))
drivers/mmc/host/sdhci.c:		spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:		enable_irq(host->irq);
drivers/mmc/host/sdhci.c:		host->mrq = &mrq;
drivers/mmc/host/sdhci.c:		host->cmd = NULL;
drivers/mmc/host/sdhci.c:		host->mrq = NULL;
drivers/mmc/host/sdhci.c:		spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:		enable_irq(host->irq);
drivers/mmc/host/sdhci.c:		wait_event_interruptible_timeout(host->buf_ready_int,
drivers/mmc/host/sdhci.c:					(host->tuning_done == 1),
drivers/mmc/host/sdhci.c:		disable_irq(host->irq);
drivers/mmc/host/sdhci.c:		spin_lock(&host->lock);
drivers/mmc/host/sdhci.c:		if (!host->tuning_done) {
drivers/mmc/host/sdhci.c:		host->tuning_done = 0;
drivers/mmc/host/sdhci.c:	if (!(host->flags & SDHCI_NEEDS_RETUNING) && host->tuning_count &&
drivers/mmc/host/sdhci.c:	    (host->tuning_mode == SDHCI_TUNING_MODE_1)) {
drivers/mmc/host/sdhci.c:		mod_timer(&host->tuning_timer, jiffies +
drivers/mmc/host/sdhci.c:			host->tuning_count * HZ);
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:		if (host->tuning_mode == SDHCI_TUNING_MODE_1)
drivers/mmc/host/sdhci.c:			mod_timer(&host->tuning_timer, jiffies +
drivers/mmc/host/sdhci.c:				host->tuning_count * HZ);
drivers/mmc/host/sdhci.c:	if (err && host->tuning_count &&
drivers/mmc/host/sdhci.c:	    host->tuning_mode == SDHCI_TUNING_MODE_1)
drivers/mmc/host/sdhci.c:	spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:	enable_irq(host->irq);
drivers/mmc/host/sdhci.c:	if (host->version < SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_PV_ENABLED;
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_PV_ENABLED;
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	/* Check host->mrq first in case we are runtime suspended */
drivers/mmc/host/sdhci.c:	if (host->mrq &&
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (!host->mrq) {
drivers/mmc/host/sdhci.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	del_timer(&host->timer);
drivers/mmc/host/sdhci.c:	mrq = host->mrq;
drivers/mmc/host/sdhci.c:	if (!(host->flags & SDHCI_DEVICE_DEAD) &&
drivers/mmc/host/sdhci.c:		   (host->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
drivers/mmc/host/sdhci.c:		if (host->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET) {
drivers/mmc/host/sdhci.c:			clock = host->clock;
drivers/mmc/host/sdhci.c:			host->clock = 0;
drivers/mmc/host/sdhci.c:	host->mrq = NULL;
drivers/mmc/host/sdhci.c:	host->cmd = NULL;
drivers/mmc/host/sdhci.c:	host->data = NULL;
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (host->mrq) {
drivers/mmc/host/sdhci.c:			"interrupt.\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:		if (host->data) {
drivers/mmc/host/sdhci.c:			host->data->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:			if (host->cmd)
drivers/mmc/host/sdhci.c:				host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:				host->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	host->flags |= SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	if (!host->cmd) {
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc), (unsigned)intmask);
drivers/mmc/host/sdhci.c:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:		host->cmd->error = -EILSEQ;
drivers/mmc/host/sdhci.c:	if (host->cmd->error) {
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	if (host->cmd->flags & MMC_RSP_BUSY) {
drivers/mmc/host/sdhci.c:		if (host->cmd->data)
drivers/mmc/host/sdhci.c:		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
drivers/mmc/host/sdhci.c:	const char *name = mmc_hostname(host->mmc);
drivers/mmc/host/sdhci.c:	u8 *desc = host->adma_desc;
drivers/mmc/host/sdhci.c:			host->tuning_done = 1;
drivers/mmc/host/sdhci.c:			wake_up(&host->buf_ready_int);
drivers/mmc/host/sdhci.c:	if (!host->data) {
drivers/mmc/host/sdhci.c:		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc), (unsigned)intmask);
drivers/mmc/host/sdhci.c:		host->data->error = -ETIMEDOUT;
drivers/mmc/host/sdhci.c:		host->data->error = -EILSEQ;
drivers/mmc/host/sdhci.c:		host->data->error = -EILSEQ;
drivers/mmc/host/sdhci.c:		pr_err("%s: ADMA error\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:		host->data->error = -EIO;
drivers/mmc/host/sdhci.c:	if (host->data->error)
drivers/mmc/host/sdhci.c:			dmastart = sg_dma_address(host->data->sg);
drivers/mmc/host/sdhci.c:			dmanow = dmastart + host->data->bytes_xfered;
drivers/mmc/host/sdhci.c:			host->data->bytes_xfered = dmanow - dmastart;
drivers/mmc/host/sdhci.c:				mmc_hostname(host->mmc), dmastart,
drivers/mmc/host/sdhci.c:				host->data->bytes_xfered, dmanow);
drivers/mmc/host/sdhci.c:			if (host->cmd) {
drivers/mmc/host/sdhci.c:				host->data_early = 1;
drivers/mmc/host/sdhci.c:	spin_lock(&host->lock);
drivers/mmc/host/sdhci.c:	if (host->runtime_suspended) {
drivers/mmc/host/sdhci.c:		spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:		       mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:		mmc_hostname(host->mmc), intmask);
drivers/mmc/host/sdhci.c:		tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/sdhci.c:			mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:	spin_unlock(&host->lock);
drivers/mmc/host/sdhci.c:			   mmc_hostname(host->mmc), unexpected);
drivers/mmc/host/sdhci.c:		mmc_signal_sdio_irq(host->mmc);
drivers/mmc/host/sdhci.c:	if (host->ops->platform_suspend)
drivers/mmc/host/sdhci.c:		host->ops->platform_suspend(host);
drivers/mmc/host/sdhci.c:	has_tuning_timer = host->version >= SDHCI_SPEC_300 &&
drivers/mmc/host/sdhci.c:		host->tuning_count && host->tuning_mode == SDHCI_TUNING_MODE_1;
drivers/mmc/host/sdhci.c:		del_timer_sync(&host->tuning_timer);
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/sdhci.c:			host->flags |= SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:			mod_timer(&host->tuning_timer, jiffies +
drivers/mmc/host/sdhci.c:					host->tuning_count * HZ);
drivers/mmc/host/sdhci.c:	free_irq(host->irq, host);
drivers/mmc/host/sdhci.c:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:		if (host->ops->enable_dma)
drivers/mmc/host/sdhci.c:			host->ops->enable_dma(host);
drivers/mmc/host/sdhci.c:	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
drivers/mmc/host/sdhci.c:			  mmc_hostname(host->mmc), host);
drivers/mmc/host/sdhci.c:	if ((host->mmc->pm_flags & MMC_PM_KEEP_POWER) &&
drivers/mmc/host/sdhci.c:	    (host->quirks2 & SDHCI_QUIRK2_HOST_OFF_CARD_ON)) {
drivers/mmc/host/sdhci.c:		host->pwr = 0;
drivers/mmc/host/sdhci.c:		host->clock = 0;
drivers/mmc/host/sdhci.c:		sdhci_do_set_ios(host, &host->mmc->ios);
drivers/mmc/host/sdhci.c:		sdhci_init(host, (host->mmc->pm_flags & MMC_PM_KEEP_POWER));
drivers/mmc/host/sdhci.c:	ret = mmc_resume_host(host->mmc);
drivers/mmc/host/sdhci.c:	if (host->ops->platform_resume)
drivers/mmc/host/sdhci.c:		host->ops->platform_resume(host);
drivers/mmc/host/sdhci.c:	if ((host->version >= SDHCI_SPEC_300) && host->tuning_count &&
drivers/mmc/host/sdhci.c:	    (host->tuning_mode == SDHCI_TUNING_MODE_1))
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:	return pm_runtime_get_sync(host->mmc->parent);
drivers/mmc/host/sdhci.c:	pm_runtime_mark_last_busy(host->mmc->parent);
drivers/mmc/host/sdhci.c:	return pm_runtime_put_autosuspend(host->mmc->parent);
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300 &&
drivers/mmc/host/sdhci.c:	    host->tuning_mode == SDHCI_TUNING_MODE_1) {
drivers/mmc/host/sdhci.c:		del_timer_sync(&host->tuning_timer);
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	synchronize_irq(host->irq);
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	host->runtime_suspended = true;
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	int ret = 0, host_flags = host->flags;
drivers/mmc/host/sdhci.c:		if (host->ops->enable_dma)
drivers/mmc/host/sdhci.c:			host->ops->enable_dma(host);
drivers/mmc/host/sdhci.c:	host->pwr = 0;
drivers/mmc/host/sdhci.c:	host->clock = 0;
drivers/mmc/host/sdhci.c:	sdhci_do_set_ios(host, &host->mmc->ios);
drivers/mmc/host/sdhci.c:	sdhci_do_start_signal_voltage_switch(host, &host->mmc->ios);
drivers/mmc/host/sdhci.c:	if ((host->version >= SDHCI_SPEC_300) && host->tuning_count &&
drivers/mmc/host/sdhci.c:	    (host->tuning_mode == SDHCI_TUNING_MODE_1))
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_NEEDS_RETUNING;
drivers/mmc/host/sdhci.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:	host->runtime_suspended = false;
drivers/mmc/host/sdhci.c:	if ((host->flags & SDHCI_SDIO_IRQ_ENABLED))
drivers/mmc/host/sdhci.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	host->mmc = mmc;
drivers/mmc/host/sdhci.c:	mmc = host->mmc;
drivers/mmc/host/sdhci.c:		host->quirks = debug_quirks;
drivers/mmc/host/sdhci.c:		host->quirks2 = debug_quirks2;
drivers/mmc/host/sdhci.c:	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
drivers/mmc/host/sdhci.c:	host->version = (host->version & SDHCI_SPEC_VER_MASK)
drivers/mmc/host/sdhci.c:	if (host->version > SDHCI_SPEC_300) {
drivers/mmc/host/sdhci.c:			host->version);
drivers/mmc/host/sdhci.c:	caps[0] = (host->quirks & SDHCI_QUIRK_MISSING_CAPS) ? host->caps :
drivers/mmc/host/sdhci.c:	caps[1] = (host->version >= SDHCI_SPEC_300) ?
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_FORCE_DMA)
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:	if ((host->quirks & SDHCI_QUIRK_BROKEN_DMA) &&
drivers/mmc/host/sdhci.c:		(host->flags & SDHCI_USE_SDMA)) {
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_USE_SDMA;
drivers/mmc/host/sdhci.c:	if ((host->version >= SDHCI_SPEC_200) &&
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:	if ((host->quirks & SDHCI_QUIRK_BROKEN_ADMA) &&
drivers/mmc/host/sdhci.c:		(host->flags & SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:		host->flags &= ~SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
drivers/mmc/host/sdhci.c:		if (host->ops->enable_dma) {
drivers/mmc/host/sdhci.c:			if (host->ops->enable_dma(host)) {
drivers/mmc/host/sdhci.c:				host->flags &=
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:		host->adma_desc = kmalloc((128 * 2 + 1) * 4, GFP_KERNEL);
drivers/mmc/host/sdhci.c:		host->align_buffer = kmalloc(128 * 4, GFP_KERNEL);
drivers/mmc/host/sdhci.c:		if (!host->adma_desc || !host->align_buffer) {
drivers/mmc/host/sdhci.c:			kfree(host->adma_desc);
drivers/mmc/host/sdhci.c:			kfree(host->align_buffer);
drivers/mmc/host/sdhci.c:			host->flags &= ~SDHCI_USE_ADMA;
drivers/mmc/host/sdhci.c:	if (!(host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA))) {
drivers/mmc/host/sdhci.c:		host->dma_mask = DMA_BIT_MASK(64);
drivers/mmc/host/sdhci.c:		mmc_dev(host->mmc)->dma_mask = &host->dma_mask;
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:		host->max_clk = (caps[0] & SDHCI_CLOCK_V3_BASE_MASK)
drivers/mmc/host/sdhci.c:		host->max_clk = (caps[0] & SDHCI_CLOCK_BASE_MASK)
drivers/mmc/host/sdhci.c:	host->max_clk *= 1000000;
drivers/mmc/host/sdhci.c:	if (host->max_clk == 0 || host->quirks &
drivers/mmc/host/sdhci.c:		if (!host->ops->get_max_clock) {
drivers/mmc/host/sdhci.c:		host->max_clk = host->ops->get_max_clock(host);
drivers/mmc/host/sdhci.c:	host->clk_mul = (caps[1] & SDHCI_CLOCK_MUL_MASK) >>
drivers/mmc/host/sdhci.c:	if (host->clk_mul)
drivers/mmc/host/sdhci.c:		host->clk_mul += 1;
drivers/mmc/host/sdhci.c:	mmc->f_max = host->max_clk;
drivers/mmc/host/sdhci.c:	if (host->ops->get_min_clock)
drivers/mmc/host/sdhci.c:		mmc->f_min = host->ops->get_min_clock(host);
drivers/mmc/host/sdhci.c:	else if (host->version >= SDHCI_SPEC_300) {
drivers/mmc/host/sdhci.c:		if (host->clk_mul) {
drivers/mmc/host/sdhci.c:			mmc->f_min = (host->max_clk * host->clk_mul) / 1024;
drivers/mmc/host/sdhci.c:			mmc->f_max = host->max_clk * host->clk_mul;
drivers/mmc/host/sdhci.c:			mmc->f_min = host->max_clk / SDHCI_MAX_DIV_SPEC_300;
drivers/mmc/host/sdhci.c:		mmc->f_min = host->max_clk / SDHCI_MAX_DIV_SPEC_200;
drivers/mmc/host/sdhci.c:	host->timeout_clk =
drivers/mmc/host/sdhci.c:	if (host->timeout_clk == 0) {
drivers/mmc/host/sdhci.c:		if (host->ops->get_timeout_clock) {
drivers/mmc/host/sdhci.c:			host->timeout_clk = host->ops->get_timeout_clock(host);
drivers/mmc/host/sdhci.c:		} else if (!(host->quirks &
drivers/mmc/host/sdhci.c:		host->timeout_clk *= 1000;
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
drivers/mmc/host/sdhci.c:		host->timeout_clk = mmc->f_max / 1000;
drivers/mmc/host/sdhci.c:	mmc->max_discard_to = (1 << 27) / host->timeout_clk;
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12)
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_AUTO_CMD12;
drivers/mmc/host/sdhci.c:	if ((host->version >= SDHCI_SPEC_300) &&
drivers/mmc/host/sdhci.c:	    ((host->flags & SDHCI_USE_ADMA) ||
drivers/mmc/host/sdhci.c:	     !(host->flags & SDHCI_USE_SDMA))) {
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_AUTO_CMD23;
drivers/mmc/host/sdhci.c:	if (!(host->quirks & SDHCI_QUIRK_FORCE_1_BIT_DATA))
drivers/mmc/host/sdhci.c:	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) &&
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_SDR50_NEEDS_TUNING;
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_HS200_NEEDS_TUNING;
drivers/mmc/host/sdhci.c:	host->tuning_count = (caps[1] & SDHCI_RETUNING_TIMER_COUNT_MASK) >>
drivers/mmc/host/sdhci.c:	if (host->tuning_count)
drivers/mmc/host/sdhci.c:		host->tuning_count = 1 << (host->tuning_count - 1);
drivers/mmc/host/sdhci.c:	host->tuning_mode = (caps[1] & SDHCI_RETUNING_MODE_MASK) >>
drivers/mmc/host/sdhci.c:	if (host->ocr_avail_sdio)
drivers/mmc/host/sdhci.c:		mmc->ocr_avail_sdio &= host->ocr_avail_sdio;
drivers/mmc/host/sdhci.c:	if (host->ocr_avail_sd)
drivers/mmc/host/sdhci.c:		mmc->ocr_avail_sd &= host->ocr_avail_sd;
drivers/mmc/host/sdhci.c:	if (host->ocr_avail_mmc)
drivers/mmc/host/sdhci.c:		mmc->ocr_avail_mmc &= host->ocr_avail_mmc;
drivers/mmc/host/sdhci.c:	spin_lock_init(&host->lock);
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_USE_ADMA)
drivers/mmc/host/sdhci.c:	else if (host->flags & SDHCI_USE_SDMA)
drivers/mmc/host/sdhci.c:	if (host->flags & SDHCI_USE_ADMA) {
drivers/mmc/host/sdhci.c:		if (host->quirks & SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC)
drivers/mmc/host/sdhci.c:	if (host->quirks & SDHCI_QUIRK_FORCE_BLK_SZ_2048) {
drivers/mmc/host/sdhci.c:	mmc->max_blk_count = (host->quirks & SDHCI_QUIRK_NO_MULTIBLOCK) ? 1 : 65535;
drivers/mmc/host/sdhci.c:	tasklet_init(&host->card_tasklet,
drivers/mmc/host/sdhci.c:	tasklet_init(&host->finish_tasklet,
drivers/mmc/host/sdhci.c:	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300) {
drivers/mmc/host/sdhci.c:		init_waitqueue_head(&host->buf_ready_int);
drivers/mmc/host/sdhci.c:		init_timer(&host->tuning_timer);
drivers/mmc/host/sdhci.c:		host->tuning_timer.data = (unsigned long)host;
drivers/mmc/host/sdhci.c:		host->tuning_timer.function = sdhci_tuning_timer;
drivers/mmc/host/sdhci.c:	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
drivers/mmc/host/sdhci.c:	host->vmmc = regulator_get(mmc_dev(mmc), "vmmc");
drivers/mmc/host/sdhci.c:	if (IS_ERR(host->vmmc)) {
drivers/mmc/host/sdhci.c:		host->vmmc = NULL;
drivers/mmc/host/sdhci.c:	snprintf(host->led_name, sizeof(host->led_name),
drivers/mmc/host/sdhci.c:	host->led.name = host->led_name;
drivers/mmc/host/sdhci.c:	host->led.brightness = LED_OFF;
drivers/mmc/host/sdhci.c:	host->led.default_trigger = mmc_hostname(mmc);
drivers/mmc/host/sdhci.c:	host->led.brightness_set = sdhci_led_control;
drivers/mmc/host/sdhci.c:	ret = led_classdev_register(mmc_dev(mmc), &host->led);
drivers/mmc/host/sdhci.c:		mmc_hostname(mmc), host->hw_name, dev_name(mmc_dev(mmc)),
drivers/mmc/host/sdhci.c:		(host->flags & SDHCI_USE_ADMA) ? "ADMA" :
drivers/mmc/host/sdhci.c:		(host->flags & SDHCI_USE_SDMA) ? "DMA" : "PIO");
drivers/mmc/host/sdhci.c:	free_irq(host->irq, host);
drivers/mmc/host/sdhci.c:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/sdhci.c:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sdhci.c:		host->flags |= SDHCI_DEVICE_DEAD;
drivers/mmc/host/sdhci.c:		if (host->mrq) {
drivers/mmc/host/sdhci.c:				" transfer!\n", mmc_hostname(host->mmc));
drivers/mmc/host/sdhci.c:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/sdhci.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sdhci.c:	mmc_remove_host(host->mmc);
drivers/mmc/host/sdhci.c:	led_classdev_unregister(&host->led);
drivers/mmc/host/sdhci.c:	free_irq(host->irq, host);
drivers/mmc/host/sdhci.c:	del_timer_sync(&host->timer);
drivers/mmc/host/sdhci.c:	if (host->version >= SDHCI_SPEC_300)
drivers/mmc/host/sdhci.c:		del_timer_sync(&host->tuning_timer);
drivers/mmc/host/sdhci.c:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/sdhci.c:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/sdhci.c:	if (host->vmmc)
drivers/mmc/host/sdhci.c:		regulator_put(host->vmmc);
drivers/mmc/host/sdhci.c:	kfree(host->adma_desc);
drivers/mmc/host/sdhci.c:	kfree(host->align_buffer);
drivers/mmc/host/sdhci.c:	host->adma_desc = NULL;
drivers/mmc/host/sdhci.c:	host->align_buffer = NULL;
drivers/mmc/host/sdhci.c:	mmc_free_host(host->mmc);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->write_l))
drivers/mmc/host/sdhci.h:		host->ops->write_l(host, val, reg);
drivers/mmc/host/sdhci.h:		writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->write_w))
drivers/mmc/host/sdhci.h:		host->ops->write_w(host, val, reg);
drivers/mmc/host/sdhci.h:		writew(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->write_b))
drivers/mmc/host/sdhci.h:		host->ops->write_b(host, val, reg);
drivers/mmc/host/sdhci.h:		writeb(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->read_l))
drivers/mmc/host/sdhci.h:		return host->ops->read_l(host, reg);
drivers/mmc/host/sdhci.h:		return readl(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->read_w))
drivers/mmc/host/sdhci.h:		return host->ops->read_w(host, reg);
drivers/mmc/host/sdhci.h:		return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	if (unlikely(host->ops->read_b))
drivers/mmc/host/sdhci.h:		return host->ops->read_b(host, reg);
drivers/mmc/host/sdhci.h:		return readb(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	writel(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	writew(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	writeb(val, host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	return readl(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	return readw(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	return readb(host->ioaddr + reg);
drivers/mmc/host/sdhci.h:	return (void *)host->private;
drivers/mmc/host/sdricoh_cs.c:	unsigned int value = readl(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:	dev_vdbg(host->dev, "rl %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:	writel(value, host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:	dev_vdbg(host->dev, "wl %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:	unsigned int value = readw(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:	writew(value, host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:	dev_vdbg(host->dev, "ww %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:	unsigned int value = readb(host->iobase + reg);
drivers/mmc/host/sdricoh_cs.c:	dev_vdbg(host->dev, "rb %x 0x%x\n", reg, value);
drivers/mmc/host/sdricoh_cs.c:	struct device *dev = host->dev;
drivers/mmc/host/sdricoh_cs.c:	dev_dbg(host->dev, "reset\n");
drivers/mmc/host/sdricoh_cs.c:	struct device *dev = host->dev;
drivers/mmc/host/sdricoh_cs.c:	if (host->app_cmd) {
drivers/mmc/host/sdricoh_cs.c:		host->app_cmd = 0;
drivers/mmc/host/sdricoh_cs.c:		host->app_cmd = 1;
drivers/mmc/host/sdricoh_cs.c:	dev_dbg(host->dev, "set_ios\n");
drivers/mmc/host/sdricoh_cs.c:	host->iobase = iobase;
drivers/mmc/host/sdricoh_cs.c:	host->dev = dev;
drivers/mmc/host/sdricoh_cs.c:	host->pci_dev = pci_dev;
drivers/mmc/host/sdricoh_cs.c:		pci_iounmap(host->pci_dev, host->iobase);
drivers/mmc/host/sdricoh_cs.c:		pci_dev_put(host->pci_dev);
drivers/mmc/host/sh_mmcif.c:	writel(val | readl(host->addr + reg), host->addr + reg);
drivers/mmc/host/sh_mmcif.c:	writel(~val & readl(host->addr + reg), host->addr + reg);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "Command completed\n");
drivers/mmc/host/sh_mmcif.c:		 dev_name(&host->pd->dev)))
drivers/mmc/host/sh_mmcif.c:		dma_unmap_sg(host->chan_rx->device->dev,
drivers/mmc/host/sh_mmcif.c:		dma_unmap_sg(host->chan_tx->device->dev,
drivers/mmc/host/sh_mmcif.c:	complete(&host->dma_complete);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/sh_mmcif.c:		host->dma_active = true;
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "%s(): mapped %d -> %d, cookie %d\n",
drivers/mmc/host/sh_mmcif.c:		host->chan_rx = NULL;
drivers/mmc/host/sh_mmcif.c:		host->dma_active = false;
drivers/mmc/host/sh_mmcif.c:		chan = host->chan_tx;
drivers/mmc/host/sh_mmcif.c:			host->chan_tx = NULL;
drivers/mmc/host/sh_mmcif.c:		dev_warn(&host->pd->dev,
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/sh_mmcif.c:		host->dma_active = true;
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "%s(): mapped %d -> %d, cookie %d\n",
drivers/mmc/host/sh_mmcif.c:		host->chan_tx = NULL;
drivers/mmc/host/sh_mmcif.c:		host->dma_active = false;
drivers/mmc/host/sh_mmcif.c:		chan = host->chan_rx;
drivers/mmc/host/sh_mmcif.c:			host->chan_rx = NULL;
drivers/mmc/host/sh_mmcif.c:		dev_warn(&host->pd->dev,
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "%s(): desc %p, cookie %d\n", __func__,
drivers/mmc/host/sh_mmcif.c:	host->dma_active = false;
drivers/mmc/host/sh_mmcif.c:		dev_warn(&host->pd->dev,
drivers/mmc/host/sh_mmcif.c:		tx = &host->dma_slave_tx;
drivers/mmc/host/sh_mmcif.c:		rx = &host->dma_slave_rx;
drivers/mmc/host/sh_mmcif.c:		host->chan_tx = dma_request_channel(mask, sh_mmcif_filter, tx);
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "%s: TX: got channel %p\n", __func__,
drivers/mmc/host/sh_mmcif.c:			host->chan_tx);
drivers/mmc/host/sh_mmcif.c:		if (!host->chan_tx)
drivers/mmc/host/sh_mmcif.c:		host->chan_rx = dma_request_channel(mask, sh_mmcif_filter, rx);
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "%s: RX: got channel %p\n", __func__,
drivers/mmc/host/sh_mmcif.c:			host->chan_rx);
drivers/mmc/host/sh_mmcif.c:		if (!host->chan_rx) {
drivers/mmc/host/sh_mmcif.c:			dma_release_channel(host->chan_tx);
drivers/mmc/host/sh_mmcif.c:			host->chan_tx = NULL;
drivers/mmc/host/sh_mmcif.c:		init_completion(&host->dma_complete);
drivers/mmc/host/sh_mmcif.c:	if (host->chan_tx) {
drivers/mmc/host/sh_mmcif.c:		struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/sh_mmcif.c:		host->chan_tx = NULL;
drivers/mmc/host/sh_mmcif.c:	if (host->chan_rx) {
drivers/mmc/host/sh_mmcif.c:		struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/sh_mmcif.c:		host->chan_rx = NULL;
drivers/mmc/host/sh_mmcif.c:	host->dma_active = false;
drivers/mmc/host/sh_mmcif.c:	struct sh_mmcif_plat_data *p = host->pd->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:	if (p->sup_pclk && clk == host->clk)
drivers/mmc/host/sh_mmcif.c:				((fls(DIV_ROUND_UP(host->clk,
drivers/mmc/host/sh_mmcif.c:	tmp = 0x010f0000 & sh_mmcif_readl(host->addr, MMCIF_CE_CLK_CTRL);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_VERSION, SOFT_RST_ON);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_VERSION, SOFT_RST_OFF);
drivers/mmc/host/sh_mmcif.c:	host->sd_error = false;
drivers/mmc/host/sh_mmcif.c:	state1 = sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS1);
drivers/mmc/host/sh_mmcif.c:	state2 = sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS2);
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "ERR HOST_STS1 = %08x\n", state1);
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&host->pd->dev, "ERR HOST_STS2 = %08x\n", state2);
drivers/mmc/host/sh_mmcif.c:			if (!(sh_mmcif_readl(host->addr, MMCIF_CE_HOST_STS1)
drivers/mmc/host/sh_mmcif.c:			dev_err(&host->pd->dev,
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "Forced end of command sequence\n");
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, ": CRC error\n");
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, ": Timeout\n");
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, ": End/Index error\n");
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	host->sg_blkidx += host->blocksize;
drivers/mmc/host/sh_mmcif.c:	/* data->sg->length must be a multiple of host->blocksize? */
drivers/mmc/host/sh_mmcif.c:	BUG_ON(host->sg_blkidx > data->sg->length);
drivers/mmc/host/sh_mmcif.c:	if (host->sg_blkidx == data->sg->length) {
drivers/mmc/host/sh_mmcif.c:		host->sg_blkidx = 0;
drivers/mmc/host/sh_mmcif.c:		if (++host->sg_idx < data->sg_len)
drivers/mmc/host/sh_mmcif.c:			host->pio_ptr = sg_virt(++data->sg);
drivers/mmc/host/sh_mmcif.c:		host->pio_ptr = p;
drivers/mmc/host/sh_mmcif.c:	if (host->sg_idx == data->sg_len)
drivers/mmc/host/sh_mmcif.c:	host->blocksize = (sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET) &
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_READ;
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:	for (i = 0; i < host->blocksize / 4; i++)
drivers/mmc/host/sh_mmcif.c:		*p++ = sh_mmcif_readl(host->addr, MMCIF_CE_DATA);
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_READ_END;
drivers/mmc/host/sh_mmcif.c:	host->blocksize = sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET) &
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_MREAD;
drivers/mmc/host/sh_mmcif.c:	host->sg_idx = 0;
drivers/mmc/host/sh_mmcif.c:	host->sg_blkidx = 0;
drivers/mmc/host/sh_mmcif.c:	host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	u32 *p = host->pio_ptr;
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:	for (i = 0; i < host->blocksize / 4; i++)
drivers/mmc/host/sh_mmcif.c:		*p++ = sh_mmcif_readl(host->addr, MMCIF_CE_DATA);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	host->blocksize = (sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET) &
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_WRITE;
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:	for (i = 0; i < host->blocksize / 4; i++)
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_DATA, *p++);
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_WRITE_END;
drivers/mmc/host/sh_mmcif.c:	host->blocksize = sh_mmcif_readl(host->addr, MMCIF_CE_BLOCK_SET) &
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_MWRITE;
drivers/mmc/host/sh_mmcif.c:	host->sg_idx = 0;
drivers/mmc/host/sh_mmcif.c:	host->sg_blkidx = 0;
drivers/mmc/host/sh_mmcif.c:	host->pio_ptr = sg_virt(data->sg);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	u32 *p = host->pio_ptr;
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:	for (i = 0; i < host->blocksize / 4; i++)
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_DATA, *p++);
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:		cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP3);
drivers/mmc/host/sh_mmcif.c:		cmd->resp[1] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP2);
drivers/mmc/host/sh_mmcif.c:		cmd->resp[2] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP1);
drivers/mmc/host/sh_mmcif.c:		cmd->resp[3] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP0);
drivers/mmc/host/sh_mmcif.c:		cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP0);
drivers/mmc/host/sh_mmcif.c:	cmd->resp[0] = sh_mmcif_readl(host->addr, MMCIF_CE_RESP_CMD12);
drivers/mmc/host/sh_mmcif.c:		dev_err(&host->pd->dev, "Unsupported response type.\n");
drivers/mmc/host/sh_mmcif.c:		switch (host->bus_width) {
drivers/mmc/host/sh_mmcif.c:			dev_err(&host->pd->dev, "Unsupported bus width.\n");
drivers/mmc/host/sh_mmcif.c:		dev_err(&host->pd->dev, "UNSUPPORTED CMD = d'%08d\n", opc);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_BLOCK_SET, 0);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_BLOCK_SET,
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_INT, 0xD80430C0);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, mask);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_ARG, cmd->arg);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_CMD_SET, opc);
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_CMD;
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:		dev_err(&host->pd->dev, "unsupported stop cmd\n");
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_STOP;
drivers/mmc/host/sh_mmcif.c:	schedule_delayed_work(&host->timeout_work, host->timeout);
drivers/mmc/host/sh_mmcif.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:	if (host->state != STATE_IDLE) {
drivers/mmc/host/sh_mmcif.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:	host->state = STATE_REQUEST;
drivers/mmc/host/sh_mmcif.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:		host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:			host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:	host->mrq = mrq;
drivers/mmc/host/sh_mmcif.c:	struct sh_mmcif_plat_data *p = host->pd->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:	if (host->state != STATE_IDLE) {
drivers/mmc/host/sh_mmcif.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:	host->state = STATE_IOS;
drivers/mmc/host/sh_mmcif.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/sh_mmcif.c:		if (!host->card_present) {
drivers/mmc/host/sh_mmcif.c:			sh_mmcif_request_dma(host, host->pd->dev.platform_data);
drivers/mmc/host/sh_mmcif.c:			host->card_present = true;
drivers/mmc/host/sh_mmcif.c:			if (host->card_present) {
drivers/mmc/host/sh_mmcif.c:				host->card_present = false;
drivers/mmc/host/sh_mmcif.c:		if (host->power) {
drivers/mmc/host/sh_mmcif.c:			pm_runtime_put(&host->pd->dev);
drivers/mmc/host/sh_mmcif.c:			host->power = false;
drivers/mmc/host/sh_mmcif.c:				p->down_pwr(host->pd);
drivers/mmc/host/sh_mmcif.c:		host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:		if (!host->power) {
drivers/mmc/host/sh_mmcif.c:				p->set_pwr(host->pd, ios->power_mode);
drivers/mmc/host/sh_mmcif.c:			pm_runtime_get_sync(&host->pd->dev);
drivers/mmc/host/sh_mmcif.c:			host->power = true;
drivers/mmc/host/sh_mmcif.c:	host->bus_width = ios->bus_width;
drivers/mmc/host/sh_mmcif.c:	host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:	struct sh_mmcif_plat_data *p = host->pd->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:		return p->get_cd(host->pd);
drivers/mmc/host/sh_mmcif.c:	struct mmc_command *cmd = host->mrq->cmd;
drivers/mmc/host/sh_mmcif.c:	struct mmc_data *data = host->mrq->data;
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:			host->sd_error = false;
drivers/mmc/host/sh_mmcif.c:			dev_dbg(&host->pd->dev, "Cmd(d'%d) error %d\n",
drivers/mmc/host/sh_mmcif.c:		if (host->chan_rx)
drivers/mmc/host/sh_mmcif.c:		if (host->chan_tx)
drivers/mmc/host/sh_mmcif.c:	if (!host->dma_active) {
drivers/mmc/host/sh_mmcif.c:		data->error = sh_mmcif_data_trans(host, host->mrq, cmd->opcode);
drivers/mmc/host/sh_mmcif.c:	time = wait_for_completion_interruptible_timeout(&host->dma_complete,
drivers/mmc/host/sh_mmcif.c:							 host->timeout);
drivers/mmc/host/sh_mmcif.c:	if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:		dev_err(host->mmc->parent,
drivers/mmc/host/sh_mmcif.c:			dmaengine_terminate_all(host->chan_rx);
drivers/mmc/host/sh_mmcif.c:			dmaengine_terminate_all(host->chan_tx);
drivers/mmc/host/sh_mmcif.c:	host->dma_active = false;
drivers/mmc/host/sh_mmcif.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/sh_mmcif.c:	cancel_delayed_work_sync(&host->timeout_work);
drivers/mmc/host/sh_mmcif.c:	switch (host->wait_for) {
drivers/mmc/host/sh_mmcif.c:		if (host->sd_error) {
drivers/mmc/host/sh_mmcif.c:		if (host->sd_error)
drivers/mmc/host/sh_mmcif.c:	if (host->wait_for != MMCIF_WAIT_FOR_STOP) {
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_REQUEST;
drivers/mmc/host/sh_mmcif.c:	host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:	host->mrq = NULL;
drivers/mmc/host/sh_mmcif.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/sh_mmcif.c:	state = sh_mmcif_readl(host->addr, MMCIF_CE_INT);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~state);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_CRSPE);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFREN);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFWEN);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_BUFRE);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~INT_DTRANE);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT,
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "Unsupported interrupt: 0x%x\n", state);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT, ~state);
drivers/mmc/host/sh_mmcif.c:		host->sd_error = true;
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "int err state = %08x\n", state);
drivers/mmc/host/sh_mmcif.c:		if (!host->dma_active)
drivers/mmc/host/sh_mmcif.c:		else if (host->sd_error)
drivers/mmc/host/sh_mmcif.c:		dev_dbg(&host->pd->dev, "Unexpected IRQ 0x%x\n", state);
drivers/mmc/host/sh_mmcif.c:	struct mmc_request *mrq = host->mrq;
drivers/mmc/host/sh_mmcif.c:	if (host->dying)
drivers/mmc/host/sh_mmcif.c:	switch (host->wait_for) {
drivers/mmc/host/sh_mmcif.c:	host->state = STATE_IDLE;
drivers/mmc/host/sh_mmcif.c:	host->wait_for = MMCIF_WAIT_FOR_REQUEST;
drivers/mmc/host/sh_mmcif.c:	host->mrq = NULL;
drivers/mmc/host/sh_mmcif.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/sh_mmcif.c:	host->mmc	= mmc;
drivers/mmc/host/sh_mmcif.c:	host->addr	= reg;
drivers/mmc/host/sh_mmcif.c:	host->timeout	= 1000;
drivers/mmc/host/sh_mmcif.c:	host->hclk = clk_get(&pdev->dev, clk_name);
drivers/mmc/host/sh_mmcif.c:	if (IS_ERR(host->hclk)) {
drivers/mmc/host/sh_mmcif.c:		ret = PTR_ERR(host->hclk);
drivers/mmc/host/sh_mmcif.c:	clk_enable(host->hclk);
drivers/mmc/host/sh_mmcif.c:	host->clk = clk_get_rate(host->hclk);
drivers/mmc/host/sh_mmcif.c:	host->pd = pdev;
drivers/mmc/host/sh_mmcif.c:	spin_lock_init(&host->lock);
drivers/mmc/host/sh_mmcif.c:	mmc->f_max = host->clk / 2;
drivers/mmc/host/sh_mmcif.c:	mmc->f_min = host->clk / 512;
drivers/mmc/host/sh_mmcif.c:	host->power = false;
drivers/mmc/host/sh_mmcif.c:	INIT_DELAYED_WORK(&host->timeout_work, mmcif_timeout_work);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, MASK_ALL);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_readl(host->addr, MMCIF_CE_VERSION) & 0x0000ffff);
drivers/mmc/host/sh_mmcif.c:	clk_disable(host->hclk);
drivers/mmc/host/sh_mmcif.c:	host->dying = true;
drivers/mmc/host/sh_mmcif.c:	mmc_remove_host(host->mmc);
drivers/mmc/host/sh_mmcif.c:	sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, MASK_ALL);
drivers/mmc/host/sh_mmcif.c:	cancel_delayed_work_sync(&host->timeout_work);
drivers/mmc/host/sh_mmcif.c:	if (host->addr)
drivers/mmc/host/sh_mmcif.c:		iounmap(host->addr);
drivers/mmc/host/sh_mmcif.c:	clk_disable(host->hclk);
drivers/mmc/host/sh_mmcif.c:	mmc_free_host(host->mmc);
drivers/mmc/host/sh_mmcif.c:	int ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/sh_mmcif.c:		sh_mmcif_writel(host->addr, MMCIF_CE_INT_MASK, MASK_ALL);
drivers/mmc/host/sh_mmcif.c:		clk_disable(host->hclk);
drivers/mmc/host/sh_mmcif.c:	clk_enable(host->hclk);
drivers/mmc/host/sh_mmcif.c:	return mmc_resume_host(host->mmc);
drivers/mmc/host/sh_mobile_sdhi.c:		dev_warn(host->pdata->dev, "timeout waiting for SD bus idle\n");
drivers/mmc/host/sh_mobile_sdhi.c:		 mmc_hostname(host->mmc), (unsigned long)
drivers/mmc/host/sh_mobile_sdhi.c:	struct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:		buf[pos++] = host->bounce_buf_data[0];
drivers/mmc/host/tifm_sd.c:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:			host->bounce_buf_data[0] = (val >> 8) & 0xff;
drivers/mmc/host/tifm_sd.c:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:		val = host->bounce_buf_data[0] | ((buf[pos++] << 8) & 0xff00);
drivers/mmc/host/tifm_sd.c:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:			host->bounce_buf_data[0] = val & 0xff;
drivers/mmc/host/tifm_sd.c:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:	struct mmc_data *r_data = host->req->cmd->data;
drivers/mmc/host/tifm_sd.c:	if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:		cnt = sg[host->sg_pos].length - host->block_pos;
drivers/mmc/host/tifm_sd.c:			host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:			host->sg_pos++;
drivers/mmc/host/tifm_sd.c:			if (host->sg_pos == host->sg_len) {
drivers/mmc/host/tifm_sd.c:				    && (host->cmd_flags & DATA_CARRY))
drivers/mmc/host/tifm_sd.c:					writel(host->bounce_buf_data[0],
drivers/mmc/host/tifm_sd.c:					       host->dev->addr
drivers/mmc/host/tifm_sd.c:			cnt = sg[host->sg_pos].length;
drivers/mmc/host/tifm_sd.c:		off = sg[host->sg_pos].offset + host->block_pos;
drivers/mmc/host/tifm_sd.c:		pg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);
drivers/mmc/host/tifm_sd.c:		host->block_pos += p_cnt;
drivers/mmc/host/tifm_sd.c:	dev_dbg(&host->dev->dev, "bouncing block\n");
drivers/mmc/host/tifm_sd.c:		cnt = sg[host->sg_pos].length - host->block_pos;
drivers/mmc/host/tifm_sd.c:			host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:			host->sg_pos++;
drivers/mmc/host/tifm_sd.c:			if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:			cnt = sg[host->sg_pos].length;
drivers/mmc/host/tifm_sd.c:		off = sg[host->sg_pos].offset + host->block_pos;
drivers/mmc/host/tifm_sd.c:		pg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);
drivers/mmc/host/tifm_sd.c:			tifm_sd_copy_page(sg_page(&host->bounce_buf),
drivers/mmc/host/tifm_sd.c:			tifm_sd_copy_page(pg, p_off, sg_page(&host->bounce_buf),
drivers/mmc/host/tifm_sd.c:		host->block_pos += p_cnt;
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:	if (host->cmd_flags & DATA_CARRY) {
drivers/mmc/host/tifm_sd.c:		host->cmd_flags &= ~DATA_CARRY;
drivers/mmc/host/tifm_sd.c:		if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:	dma_len = sg_dma_len(&r_data->sg[host->sg_pos]) - host->block_pos;
drivers/mmc/host/tifm_sd.c:		host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:		host->sg_pos++;
drivers/mmc/host/tifm_sd.c:		if (host->sg_pos == host->sg_len)
drivers/mmc/host/tifm_sd.c:		dma_len = sg_dma_len(&r_data->sg[host->sg_pos]);
drivers/mmc/host/tifm_sd.c:		dma_off = host->block_pos;
drivers/mmc/host/tifm_sd.c:		host->block_pos += dma_blk_cnt * r_data->blksz;
drivers/mmc/host/tifm_sd.c:		dma_off = host->block_pos;
drivers/mmc/host/tifm_sd.c:		host->block_pos += t_size;
drivers/mmc/host/tifm_sd.c:		sg = &r_data->sg[host->sg_pos];
drivers/mmc/host/tifm_sd.c:			host->cmd_flags |= DATA_CARRY;
drivers/mmc/host/tifm_sd.c:		sg = &host->bounce_buf;
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	if (host->open_drain)
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	struct mmc_command *cmd = host->req->cmd;
drivers/mmc/host/tifm_sd.c:	if (!(host->cmd_flags & CMD_READY))
drivers/mmc/host/tifm_sd.c:			if ((host->cmd_flags & SCMD_ACTIVE)
drivers/mmc/host/tifm_sd.c:			    && !(host->cmd_flags & SCMD_READY))
drivers/mmc/host/tifm_sd.c:		if (!(host->cmd_flags & BRS_READY))
drivers/mmc/host/tifm_sd.c:		if (!(host->no_dma || (host->cmd_flags & FIFO_READY)))
drivers/mmc/host/tifm_sd.c:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:				if (!(host->cmd_flags & SCMD_ACTIVE)) {
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:					if (!(host->cmd_flags & SCMD_READY)
drivers/mmc/host/tifm_sd.c:					    || (host->cmd_flags & CARD_BUSY))
drivers/mmc/host/tifm_sd.c:				if (host->cmd_flags & CARD_BUSY)
drivers/mmc/host/tifm_sd.c:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:				if (!(host->cmd_flags & SCMD_ACTIVE)) {
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:					if (!(host->cmd_flags & SCMD_READY))
drivers/mmc/host/tifm_sd.c:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:		fifo_status, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:	if (host->req) {
drivers/mmc/host/tifm_sd.c:		r_data = host->req->cmd->data;
drivers/mmc/host/tifm_sd.c:				host->cmd_flags |= FIFO_READY;
drivers/mmc/host/tifm_sd.c:		host_status, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:	if (host->req) {
drivers/mmc/host/tifm_sd.c:		cmd = host->req->cmd;
drivers/mmc/host/tifm_sd.c:			if (host->req->stop) {
drivers/mmc/host/tifm_sd.c:				if (host->cmd_flags & SCMD_ACTIVE) {
drivers/mmc/host/tifm_sd.c:					host->req->stop->error = cmd_error;
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= SCMD_READY;
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= SCMD_ACTIVE;
drivers/mmc/host/tifm_sd.c:					tifm_sd_exec(host, host->req->stop);
drivers/mmc/host/tifm_sd.c:				if (!(host->cmd_flags & CMD_READY)) {
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= CMD_READY;
drivers/mmc/host/tifm_sd.c:				} else if (host->cmd_flags & SCMD_ACTIVE) {
drivers/mmc/host/tifm_sd.c:					host->cmd_flags |= SCMD_READY;
drivers/mmc/host/tifm_sd.c:					tifm_sd_fetch_resp(host->req->stop,
drivers/mmc/host/tifm_sd.c:				host->cmd_flags |= BRS_READY;
drivers/mmc/host/tifm_sd.c:		if (host->no_dma && cmd->data) {
drivers/mmc/host/tifm_sd.c:			host->cmd_flags &= ~CARD_BUSY;
drivers/mmc/host/tifm_sd.c:			host->cmd_flags |= CARD_BUSY;
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:			((1000000000UL / host->clk_freq) * host->clk_div);
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	if (host->eject) {
drivers/mmc/host/tifm_sd.c:	if (host->req) {
drivers/mmc/host/tifm_sd.c:	host->cmd_flags = 0;
drivers/mmc/host/tifm_sd.c:	host->block_pos = 0;
drivers/mmc/host/tifm_sd.c:	host->sg_pos = 0;
drivers/mmc/host/tifm_sd.c:		host->no_dma = 1;
drivers/mmc/host/tifm_sd.c:		host->no_dma = no_dma ? 1 : 0;
drivers/mmc/host/tifm_sd.c:		if (host->no_dma) {
drivers/mmc/host/tifm_sd.c:			host->sg_len = r_data->sg_len;
drivers/mmc/host/tifm_sd.c:			sg_init_one(&host->bounce_buf, host->bounce_buf_data,
drivers/mmc/host/tifm_sd.c:			if(1 != tifm_map_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:			host->sg_len = tifm_map_sg(sock, r_data->sg,
drivers/mmc/host/tifm_sd.c:			if (host->sg_len < 1) {
drivers/mmc/host/tifm_sd.c:				tifm_unmap_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:	host->req = mrq;
drivers/mmc/host/tifm_sd.c:	mod_timer(&host->timer, jiffies + host->timeout_jiffies);
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	del_timer(&host->timer);
drivers/mmc/host/tifm_sd.c:	mrq = host->req;
drivers/mmc/host/tifm_sd.c:	host->req = NULL;
drivers/mmc/host/tifm_sd.c:		if (host->no_dma) {
drivers/mmc/host/tifm_sd.c:			tifm_unmap_sg(sock, &host->bounce_buf, 1,
drivers/mmc/host/tifm_sd.c:	       dev_name(&host->dev->dev), host->req->cmd->opcode, host->cmd_flags);
drivers/mmc/host/tifm_sd.c:	tifm_eject(host->dev);
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:			host->clk_freq = 20000000;
drivers/mmc/host/tifm_sd.c:			host->clk_div = clk_div1;
drivers/mmc/host/tifm_sd.c:			host->clk_freq = 24000000;
drivers/mmc/host/tifm_sd.c:			host->clk_div = clk_div2;
drivers/mmc/host/tifm_sd.c:		host->clk_div = 0;
drivers/mmc/host/tifm_sd.c:	host->clk_div &= TIFM_MMCSD_CLKMASK;
drivers/mmc/host/tifm_sd.c:	writel(host->clk_div
drivers/mmc/host/tifm_sd.c:	host->open_drain = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN);
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	struct tifm_dev *sock = host->dev;
drivers/mmc/host/tifm_sd.c:	host->clk_div = 61;
drivers/mmc/host/tifm_sd.c:	host->clk_freq = 20000000;
drivers/mmc/host/tifm_sd.c:	writel(host->clk_div | TIFM_MMCSD_POWER,
drivers/mmc/host/tifm_sd.c:	writel(host->clk_div | TIFM_MMCSD_POWER,
drivers/mmc/host/tifm_sd.c:	host->dev = sock;
drivers/mmc/host/tifm_sd.c:	host->timeout_jiffies = msecs_to_jiffies(1000);
drivers/mmc/host/tifm_sd.c:	tasklet_init(&host->finish_tasklet, tifm_sd_end_cmd,
drivers/mmc/host/tifm_sd.c:	setup_timer(&host->timer, tifm_sd_abort, (unsigned long)host);
drivers/mmc/host/tifm_sd.c:	host->eject = 1;
drivers/mmc/host/tifm_sd.c:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:	if (host->req) {
drivers/mmc/host/tifm_sd.c:		host->req->cmd->error = -ENOMEDIUM;
drivers/mmc/host/tifm_sd.c:		if (host->req->stop)
drivers/mmc/host/tifm_sd.c:			host->req->stop->error = -ENOMEDIUM;
drivers/mmc/host/tifm_sd.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/tifm_sd.c:		host->eject = 1;
drivers/mmc/host/tmio_mmc.c:	pr_info("%s at 0x%08lx irq %d\n", mmc_hostname(host->mmc),
drivers/mmc/host/tmio_mmc.c:		(unsigned long)host->ctl, irq);
drivers/mmc/host/tmio_mmc.h:	host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc.h:	host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc.h:	return readw(host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:	readsw(host->ctl + (addr << host->bus_shift), buf, count);
drivers/mmc/host/tmio_mmc.h:	return readw(host->ctl + (addr << host->bus_shift)) |
drivers/mmc/host/tmio_mmc.h:	       readw(host->ctl + ((addr + 2) << host->bus_shift)) << 16;
drivers/mmc/host/tmio_mmc.h:	if (host->pdata->write16_hook && host->pdata->write16_hook(host, addr))
drivers/mmc/host/tmio_mmc.h:	writew(val, host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:	writesw(host->ctl + (addr << host->bus_shift), buf, count);
drivers/mmc/host/tmio_mmc.h:	writew(val, host->ctl + (addr << host->bus_shift));
drivers/mmc/host/tmio_mmc.h:	writew(val >> 16, host->ctl + ((addr + 2) << host->bus_shift));
drivers/mmc/host/tmio_mmc_dma.c:	if (!host->chan_tx || !host->chan_rx)
drivers/mmc/host/tmio_mmc_dma.c:	if (host->chan_rx)
drivers/mmc/host/tmio_mmc_dma.c:		dmaengine_terminate_all(host->chan_rx);
drivers/mmc/host/tmio_mmc_dma.c:	if (host->chan_tx)
drivers/mmc/host/tmio_mmc_dma.c:		dmaengine_terminate_all(host->chan_tx);
drivers/mmc/host/tmio_mmc_dma.c:	struct scatterlist *sg = host->sg_ptr, *sg_tmp;
drivers/mmc/host/tmio_mmc_dma.c:	struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/tmio_mmc_dma.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_dma.c:	for_each_sg(sg, sg_tmp, host->sg_len, i) {
drivers/mmc/host/tmio_mmc_dma.c:	if ((!aligned && (host->sg_len > 1 || sg->length > PAGE_CACHE_SIZE ||
drivers/mmc/host/tmio_mmc_dma.c:		host->force_pio = true;
drivers/mmc/host/tmio_mmc_dma.c:		sg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);
drivers/mmc/host/tmio_mmc_dma.c:		host->sg_ptr = &host->bounce_sg;
drivers/mmc/host/tmio_mmc_dma.c:		sg = host->sg_ptr;
drivers/mmc/host/tmio_mmc_dma.c:	ret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_FROM_DEVICE);
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc_dma.c:		__func__, host->sg_len, ret, cookie, host->mrq);
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:		chan = host->chan_tx;
drivers/mmc/host/tmio_mmc_dma.c:			host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:		desc, cookie, host->sg_len);
drivers/mmc/host/tmio_mmc_dma.c:	struct scatterlist *sg = host->sg_ptr, *sg_tmp;
drivers/mmc/host/tmio_mmc_dma.c:	struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc_dma.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_dma.c:	for_each_sg(sg, sg_tmp, host->sg_len, i) {
drivers/mmc/host/tmio_mmc_dma.c:	if ((!aligned && (host->sg_len > 1 || sg->length > PAGE_CACHE_SIZE ||
drivers/mmc/host/tmio_mmc_dma.c:		host->force_pio = true;
drivers/mmc/host/tmio_mmc_dma.c:		sg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);
drivers/mmc/host/tmio_mmc_dma.c:		memcpy(host->bounce_buf, sg_vaddr, host->bounce_sg.length);
drivers/mmc/host/tmio_mmc_dma.c:		host->sg_ptr = &host->bounce_sg;
drivers/mmc/host/tmio_mmc_dma.c:		sg = host->sg_ptr;
drivers/mmc/host/tmio_mmc_dma.c:	ret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_TO_DEVICE);
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc_dma.c:		__func__, host->sg_len, ret, cookie, host->mrq);
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:		chan = host->chan_rx;
drivers/mmc/host/tmio_mmc_dma.c:			host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:		if (host->chan_rx)
drivers/mmc/host/tmio_mmc_dma.c:		if (host->chan_tx)
drivers/mmc/host/tmio_mmc_dma.c:	spin_lock_irq(&host->lock);
drivers/mmc/host/tmio_mmc_dma.c:	if (host && host->data) {
drivers/mmc/host/tmio_mmc_dma.c:		if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/tmio_mmc_dma.c:			chan = host->chan_rx;
drivers/mmc/host/tmio_mmc_dma.c:			chan = host->chan_tx;
drivers/mmc/host/tmio_mmc_dma.c:	spin_unlock_irq(&host->lock);
drivers/mmc/host/tmio_mmc_dma.c:	spin_lock_irq(&host->lock);
drivers/mmc/host/tmio_mmc_dma.c:	if (!host->data)
drivers/mmc/host/tmio_mmc_dma.c:	if (host->data->flags & MMC_DATA_READ)
drivers/mmc/host/tmio_mmc_dma.c:		dma_unmap_sg(host->chan_rx->device->dev,
drivers/mmc/host/tmio_mmc_dma.c:			     host->sg_ptr, host->sg_len,
drivers/mmc/host/tmio_mmc_dma.c:		dma_unmap_sg(host->chan_tx->device->dev,
drivers/mmc/host/tmio_mmc_dma.c:			     host->sg_ptr, host->sg_len,
drivers/mmc/host/tmio_mmc_dma.c:	spin_unlock_irq(&host->lock);
drivers/mmc/host/tmio_mmc_dma.c:	if (!host->chan_tx && !host->chan_rx) {
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_tx = dma_request_channel(mask, tmio_mmc_filter,
drivers/mmc/host/tmio_mmc_dma.c:		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:			host->chan_tx);
drivers/mmc/host/tmio_mmc_dma.c:		if (!host->chan_tx)
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_rx = dma_request_channel(mask, tmio_mmc_filter,
drivers/mmc/host/tmio_mmc_dma.c:		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:			host->chan_rx);
drivers/mmc/host/tmio_mmc_dma.c:		if (!host->chan_rx)
drivers/mmc/host/tmio_mmc_dma.c:		host->bounce_buf = (u8 *)__get_free_page(GFP_KERNEL | GFP_DMA);
drivers/mmc/host/tmio_mmc_dma.c:		if (!host->bounce_buf)
drivers/mmc/host/tmio_mmc_dma.c:		tasklet_init(&host->dma_complete, tmio_mmc_tasklet_fn, (unsigned long)host);
drivers/mmc/host/tmio_mmc_dma.c:		tasklet_init(&host->dma_issue, tmio_mmc_issue_tasklet_fn, (unsigned long)host);
drivers/mmc/host/tmio_mmc_dma.c:	dma_release_channel(host->chan_rx);
drivers/mmc/host/tmio_mmc_dma.c:	host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:	dma_release_channel(host->chan_tx);
drivers/mmc/host/tmio_mmc_dma.c:	host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:	if (host->chan_tx) {
drivers/mmc/host/tmio_mmc_dma.c:		struct dma_chan *chan = host->chan_tx;
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_tx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:	if (host->chan_rx) {
drivers/mmc/host/tmio_mmc_dma.c:		struct dma_chan *chan = host->chan_rx;
drivers/mmc/host/tmio_mmc_dma.c:		host->chan_rx = NULL;
drivers/mmc/host/tmio_mmc_dma.c:	if (host->bounce_buf) {
drivers/mmc/host/tmio_mmc_dma.c:		free_pages((unsigned long)host->bounce_buf, 0);
drivers/mmc/host/tmio_mmc_dma.c:		host->bounce_buf = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	host->sdcard_irq_mask &= ~(i & TMIO_MASK_IRQ);
drivers/mmc/host/tmio_mmc_pio.c:	sd_ctrl_write32(host, CTL_IRQ_MASK, host->sdcard_irq_mask);
drivers/mmc/host/tmio_mmc_pio.c:	host->sdcard_irq_mask |= (i & TMIO_MASK_IRQ);
drivers/mmc/host/tmio_mmc_pio.c:	sd_ctrl_write32(host, CTL_IRQ_MASK, host->sdcard_irq_mask);
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_len = data->sg_len;
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_ptr = data->sg;
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_orig = data->sg;
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_off = 0;
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_ptr = sg_next(host->sg_ptr);
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_off = 0;
drivers/mmc/host/tmio_mmc_pio.c:	return --host->sg_len;
drivers/mmc/host/tmio_mmc_pio.c:		host->sdio_irq_mask = TMIO_SDIO_MASK_ALL &
drivers/mmc/host/tmio_mmc_pio.c:		sd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);
drivers/mmc/host/tmio_mmc_pio.c:		host->sdio_irq_mask = TMIO_SDIO_MASK_ALL;
drivers/mmc/host/tmio_mmc_pio.c:		sd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);
drivers/mmc/host/tmio_mmc_pio.c:		for (clock = host->mmc->f_min, clk = 0x80000080;
drivers/mmc/host/tmio_mmc_pio.c:	if (host->set_clk_div)
drivers/mmc/host/tmio_mmc_pio.c:		host->set_clk_div(host->pdev, (clk>>22) & 1);
drivers/mmc/host/tmio_mmc_pio.c:	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/tmio_mmc_pio.c:	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/tmio_mmc_pio.c:	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	mrq = host->mrq;
drivers/mmc/host/tmio_mmc_pio.c:	 * us, so, have to check for IS_ERR(host->mrq)
drivers/mmc/host/tmio_mmc_pio.c:	    || time_is_after_jiffies(host->last_req_ts +
drivers/mmc/host/tmio_mmc_pio.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_pio.c:	if (host->data)
drivers/mmc/host/tmio_mmc_pio.c:		host->data->error = -ETIMEDOUT;
drivers/mmc/host/tmio_mmc_pio.c:	else if (host->cmd)
drivers/mmc/host/tmio_mmc_pio.c:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/tmio_mmc_pio.c:	host->cmd = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	host->data = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	host->force_pio = false;
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/tmio_mmc_pio.c:/* called with host->lock held, interrupts disabled */
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	mrq = host->mrq;
drivers/mmc/host/tmio_mmc_pio.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	host->cmd = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	host->data = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	host->force_pio = false;
drivers/mmc/host/tmio_mmc_pio.c:	cancel_delayed_work(&host->delayed_reset_work);
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc_pio.c:	host->cmd = cmd;
drivers/mmc/host/tmio_mmc_pio.c:	if (!host->native_hotplug)
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc_pio.c:	if ((host->chan_tx || host->chan_rx) && !host->force_pio) {
drivers/mmc/host/tmio_mmc_pio.c:	sg_virt = tmio_mmc_kmap_atomic(host->sg_ptr, &flags);
drivers/mmc/host/tmio_mmc_pio.c:	buf = (unsigned short *)(sg_virt + host->sg_off);
drivers/mmc/host/tmio_mmc_pio.c:	count = host->sg_ptr->length - host->sg_off;
drivers/mmc/host/tmio_mmc_pio.c:		 count, host->sg_off, data->flags);
drivers/mmc/host/tmio_mmc_pio.c:	host->sg_off += count;
drivers/mmc/host/tmio_mmc_pio.c:	tmio_mmc_kunmap_atomic(host->sg_ptr, &flags, sg_virt);
drivers/mmc/host/tmio_mmc_pio.c:	if (host->sg_off == host->sg_ptr->length)
drivers/mmc/host/tmio_mmc_pio.c:	if (host->sg_ptr == &host->bounce_sg) {
drivers/mmc/host/tmio_mmc_pio.c:		void *sg_vaddr = tmio_mmc_kmap_atomic(host->sg_orig, &flags);
drivers/mmc/host/tmio_mmc_pio.c:		memcpy(sg_vaddr, host->bounce_buf, host->bounce_sg.length);
drivers/mmc/host/tmio_mmc_pio.c:		tmio_mmc_kunmap_atomic(host->sg_orig, &flags, sg_vaddr);
drivers/mmc/host/tmio_mmc_pio.c:/* needs to be called with host->lock held */
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_data *data = host->data;
drivers/mmc/host/tmio_mmc_pio.c:	host->data = NULL;
drivers/mmc/host/tmio_mmc_pio.c:		dev_warn(&host->pdev->dev, "Spurious data end IRQ\n");
drivers/mmc/host/tmio_mmc_pio.c:		if (host->chan_rx && !host->force_pio)
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev, "Complete Rx request %p\n",
drivers/mmc/host/tmio_mmc_pio.c:			host->mrq);
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev, "Complete Tx request %p\n",
drivers/mmc/host/tmio_mmc_pio.c:			host->mrq);
drivers/mmc/host/tmio_mmc_pio.c:	schedule_work(&host->done);
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock(&host->lock);
drivers/mmc/host/tmio_mmc_pio.c:	data = host->data;
drivers/mmc/host/tmio_mmc_pio.c:	if (host->chan_tx && (data->flags & MMC_DATA_WRITE) && !host->force_pio) {
drivers/mmc/host/tmio_mmc_pio.c:			tasklet_schedule(&host->dma_complete);
drivers/mmc/host/tmio_mmc_pio.c:	} else if (host->chan_rx && (data->flags & MMC_DATA_READ) && !host->force_pio) {
drivers/mmc/host/tmio_mmc_pio.c:		tasklet_schedule(&host->dma_complete);
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock(&host->lock);
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_command *cmd = host->cmd;
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock(&host->lock);
drivers/mmc/host/tmio_mmc_pio.c:	if (!host->cmd) {
drivers/mmc/host/tmio_mmc_pio.c:	host->cmd = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	if (host->data && !cmd->error) {
drivers/mmc/host/tmio_mmc_pio.c:		if (host->data->flags & MMC_DATA_READ) {
drivers/mmc/host/tmio_mmc_pio.c:			if (host->force_pio || !host->chan_rx)
drivers/mmc/host/tmio_mmc_pio.c:				tasklet_schedule(&host->dma_issue);
drivers/mmc/host/tmio_mmc_pio.c:			if (host->force_pio || !host->chan_tx)
drivers/mmc/host/tmio_mmc_pio.c:				tasklet_schedule(&host->dma_issue);
drivers/mmc/host/tmio_mmc_pio.c:		schedule_work(&host->done);
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock(&host->lock);
drivers/mmc/host/tmio_mmc_pio.c:	*ireg = *status & TMIO_MASK_IRQ & ~host->sdcard_irq_mask;
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/tmio_mmc_pio.c:			mmc_detect_change(host->mmc, msecs_to_jiffies(100));
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/tmio_mmc_pio.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_pio.c:	ireg = status & TMIO_SDIO_MASK_ALL & ~host->sdcard_irq_mask;
drivers/mmc/host/tmio_mmc_pio.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_pio.c:	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4) {
drivers/mmc/host/tmio_mmc_pio.c:			       mmc_hostname(host->mmc), data->blksz);
drivers/mmc/host/tmio_mmc_pio.c:	host->data = data;
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	if (host->mrq) {
drivers/mmc/host/tmio_mmc_pio.c:		if (IS_ERR(host->mrq)) {
drivers/mmc/host/tmio_mmc_pio.c:			spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	host->last_req_ts = jiffies;
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = mrq;
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:		schedule_delayed_work(&host->delayed_reset_work,
drivers/mmc/host/tmio_mmc_pio.c:	host->force_pio = false;
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	struct device *dev = &host->pdev->dev;
drivers/mmc/host/tmio_mmc_pio.c:	mutex_lock(&host->ios_lock);
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	if (host->mrq) {
drivers/mmc/host/tmio_mmc_pio.c:		if (IS_ERR(host->mrq)) {
drivers/mmc/host/tmio_mmc_pio.c:			host->mrq = ERR_PTR(-EINTR);
drivers/mmc/host/tmio_mmc_pio.c:				host->mrq->cmd->opcode, host->last_req_ts, jiffies);
drivers/mmc/host/tmio_mmc_pio.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:		mutex_unlock(&host->ios_lock);
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = ERR_PTR(-EBUSY);
drivers/mmc/host/tmio_mmc_pio.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/tmio_mmc_pio.c:	 * host->power toggles between false and true in both cases - either
drivers/mmc/host/tmio_mmc_pio.c:		if (!host->power) {
drivers/mmc/host/tmio_mmc_pio.c:			host->power = true;
drivers/mmc/host/tmio_mmc_pio.c:		if (host->set_pwr)
drivers/mmc/host/tmio_mmc_pio.c:			host->set_pwr(host->pdev, 1);
drivers/mmc/host/tmio_mmc_pio.c:		if (host->set_pwr && ios->power_mode == MMC_POWER_OFF)
drivers/mmc/host/tmio_mmc_pio.c:			host->set_pwr(host->pdev, 0);
drivers/mmc/host/tmio_mmc_pio.c:		if (host->power) {
drivers/mmc/host/tmio_mmc_pio.c:			host->power = false;
drivers/mmc/host/tmio_mmc_pio.c:	if (PTR_ERR(host->mrq) == -EINTR)
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_pio.c:	host->mrq = NULL;
drivers/mmc/host/tmio_mmc_pio.c:	mutex_unlock(&host->ios_lock);
drivers/mmc/host/tmio_mmc_pio.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_pio.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_pio.c:		return pdata->get_cd(host->pdev);
drivers/mmc/host/tmio_mmc_pio.c:	_host->pdata = pdata;
drivers/mmc/host/tmio_mmc_pio.c:	_host->mmc = mmc;
drivers/mmc/host/tmio_mmc_pio.c:	_host->pdev = pdev;
drivers/mmc/host/tmio_mmc_pio.c:	_host->set_pwr = pdata->set_pwr;
drivers/mmc/host/tmio_mmc_pio.c:	_host->set_clk_div = pdata->set_clk_div;
drivers/mmc/host/tmio_mmc_pio.c:	_host->bus_shift = resource_size(res_ctl) >> 10;
drivers/mmc/host/tmio_mmc_pio.c:	_host->ctl = ioremap(res_ctl->start, resource_size(res_ctl));
drivers/mmc/host/tmio_mmc_pio.c:	if (!_host->ctl) {
drivers/mmc/host/tmio_mmc_pio.c:	_host->native_hotplug = !(pdata->flags & TMIO_MMC_USE_GPIO_CD ||
drivers/mmc/host/tmio_mmc_pio.c:	_host->power = false;
drivers/mmc/host/tmio_mmc_pio.c:	if (_host->native_hotplug)
drivers/mmc/host/tmio_mmc_pio.c:	_host->sdcard_irq_mask = sd_ctrl_read32(_host, CTL_IRQ_MASK);
drivers/mmc/host/tmio_mmc_pio.c:	spin_lock_init(&_host->lock);
drivers/mmc/host/tmio_mmc_pio.c:	mutex_init(&_host->ios_lock);
drivers/mmc/host/tmio_mmc_pio.c:	INIT_DELAYED_WORK(&_host->delayed_reset_work, tmio_mmc_reset_work);
drivers/mmc/host/tmio_mmc_pio.c:	INIT_WORK(&_host->done, tmio_mmc_done_work);
drivers/mmc/host/tmio_mmc_pio.c:	if (!_host->chan_rx)
drivers/mmc/host/tmio_mmc_pio.c:	if (!_host->chan_tx)
drivers/mmc/host/tmio_mmc_pio.c:	if (!_host->native_hotplug)
drivers/mmc/host/tmio_mmc_pio.c:	iounmap(_host->ctl);
drivers/mmc/host/tmio_mmc_pio.c:	struct platform_device *pdev = host->pdev;
drivers/mmc/host/tmio_mmc_pio.c:	struct tmio_mmc_data *pdata = host->pdata;
drivers/mmc/host/tmio_mmc_pio.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/tmio_mmc_pio.c:	if (!host->native_hotplug)
drivers/mmc/host/tmio_mmc_pio.c:	cancel_work_sync(&host->done);
drivers/mmc/host/tmio_mmc_pio.c:	cancel_delayed_work_sync(&host->delayed_reset_work);
drivers/mmc/host/tmio_mmc_pio.c:	iounmap(host->ctl);
drivers/mmc/host/via-sdmmc.c:	void __iomem *addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	void __iomem *addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	pm_pcictrl_reg = &(host->pm_pcictrl_reg);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	pm_pcictrl_reg = &(host->pm_pcictrl_reg);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	pm_sdhc_reg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	pm_sdhc_reg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	if (sdhost->quirks & VIA_CRDR_QUIRK_300MS_PWRDELAY)
drivers/mmc/host/via-sdmmc.c:	addrbase = host->ddma_mmiobase;
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:		dev_info(host->mmc->parent, "forcing card speed to 8MHz\n");
drivers/mmc/host/via-sdmmc.c:	WARN_ON(host->data);
drivers/mmc/host/via-sdmmc.c:	BUG_ON(data->blksz > host->mmc->max_blk_size);
drivers/mmc/host/via-sdmmc.c:	BUG_ON(data->blocks > host->mmc->max_blk_count);
drivers/mmc/host/via-sdmmc.c:	host->data = data;
drivers/mmc/host/via-sdmmc.c:	count = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	void __iomem *addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	WARN_ON(host->cmd);
drivers/mmc/host/via-sdmmc.c:	mod_timer(&host->timer, jiffies + HZ);
drivers/mmc/host/via-sdmmc.c:	host->cmd = cmd;
drivers/mmc/host/via-sdmmc.c:		pr_err("%s: cmd->flag is not valid\n", mmc_hostname(host->mmc));
drivers/mmc/host/via-sdmmc.c:	if (cmd == host->mrq->stop)
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	BUG_ON(!host->data);
drivers/mmc/host/via-sdmmc.c:	data = host->data;
drivers/mmc/host/via-sdmmc.c:	host->data = NULL;
drivers/mmc/host/via-sdmmc.c:	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
drivers/mmc/host/via-sdmmc.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	via_sdc_get_response(host, host->cmd);
drivers/mmc/host/via-sdmmc.c:	host->cmd->error = 0;
drivers/mmc/host/via-sdmmc.c:	if (!host->cmd->data)
drivers/mmc/host/via-sdmmc.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	host->cmd = NULL;
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:	writew(status, host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:	WARN_ON(host->mrq != NULL);
drivers/mmc/host/via-sdmmc.c:	host->mrq = mrq;
drivers/mmc/host/via-sdmmc.c:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:	if (!(status & VIA_CRDR_SDSTS_SLOTG) || host->reject) {
drivers/mmc/host/via-sdmmc.c:		host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	host->power = (1 << power);
drivers/mmc/host/via-sdmmc.c:	gatt = readb(host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	if (host->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	status = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	if (host->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	if (!host->cmd) {
drivers/mmc/host/via-sdmmc.c:		       mmc_hostname(host->mmc), intmask);
drivers/mmc/host/via-sdmmc.c:		host->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:		host->cmd->error = -EILSEQ;
drivers/mmc/host/via-sdmmc.c:	if (host->cmd->error)
drivers/mmc/host/via-sdmmc.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:		host->data->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:		host->data->error = -EILSEQ;
drivers/mmc/host/via-sdmmc.c:	spin_lock(&sdhost->lock);
drivers/mmc/host/via-sdmmc.c:	addrbase = sdhost->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	addrbase = sdhost->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:		schedule_work(&sdhost->carddet_work);
drivers/mmc/host/via-sdmmc.c:		       mmc_hostname(sdhost->mmc), sd_status);
drivers/mmc/host/via-sdmmc.c:	spin_unlock(&sdhost->lock);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:	if (sdhost->mrq) {
drivers/mmc/host/via-sdmmc.c:		       "cmd:0x%x\n", mmc_hostname(sdhost->mmc),
drivers/mmc/host/via-sdmmc.c:		       sdhost->mrq->cmd->opcode);
drivers/mmc/host/via-sdmmc.c:		if (sdhost->data) {
drivers/mmc/host/via-sdmmc.c:				sdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);
drivers/mmc/host/via-sdmmc.c:			sdhost->data->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:			if (sdhost->cmd)
drivers/mmc/host/via-sdmmc.c:				sdhost->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:				sdhost->mrq->cmd->error = -ETIMEDOUT;
drivers/mmc/host/via-sdmmc.c:			tasklet_schedule(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	del_timer(&host->timer);
drivers/mmc/host/via-sdmmc.c:	mrq = host->mrq;
drivers/mmc/host/via-sdmmc.c:	host->mrq = NULL;
drivers/mmc/host/via-sdmmc.c:	host->cmd = NULL;
drivers/mmc/host/via-sdmmc.c:	host->data = NULL;
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->ddma_mmiobase;
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->pcictrl_mmiobase;
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:		if (host->mrq) {
drivers/mmc/host/via-sdmmc.c:			       mmc_hostname(host->mmc));
drivers/mmc/host/via-sdmmc.c:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:		spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:		spin_lock_irqsave(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&host->lock, flags);
drivers/mmc/host/via-sdmmc.c:	mmc_detect_change(host->mmc, msecs_to_jiffies(500));
drivers/mmc/host/via-sdmmc.c:	struct mmc_host *mmc = host->mmc;
drivers/mmc/host/via-sdmmc.c:	init_timer(&host->timer);
drivers/mmc/host/via-sdmmc.c:	host->timer.data = (unsigned long)host;
drivers/mmc/host/via-sdmmc.c:	host->timer.function = via_sdc_timeout;
drivers/mmc/host/via-sdmmc.c:	spin_lock_init(&host->lock);
drivers/mmc/host/via-sdmmc.c:	INIT_WORK(&host->carddet_work, via_sdc_card_detect);
drivers/mmc/host/via-sdmmc.c:	tasklet_init(&host->finish_tasklet, via_sdc_tasklet_finish,
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	sdhost->mmc = mmc;
drivers/mmc/host/via-sdmmc.c:	sdhost->mmiobase = ioremap_nocache(base, len);
drivers/mmc/host/via-sdmmc.c:	if (!sdhost->mmiobase) {
drivers/mmc/host/via-sdmmc.c:	sdhost->sdhc_mmiobase =
drivers/mmc/host/via-sdmmc.c:		sdhost->mmiobase + VIA_CRDR_SDC_OFF;
drivers/mmc/host/via-sdmmc.c:	sdhost->ddma_mmiobase =
drivers/mmc/host/via-sdmmc.c:		sdhost->mmiobase + VIA_CRDR_DDMA_OFF;
drivers/mmc/host/via-sdmmc.c:	sdhost->pcictrl_mmiobase =
drivers/mmc/host/via-sdmmc.c:		sdhost->mmiobase + VIA_CRDR_PCICTRL_OFF;
drivers/mmc/host/via-sdmmc.c:	sdhost->power = MMC_VDD_165_195;
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	       sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);
drivers/mmc/host/via-sdmmc.c:	       sdhost->pcictrl_mmiobase + VIA_CRDR_PCITMOCTRL);
drivers/mmc/host/via-sdmmc.c:		sdhost->quirks = VIA_CRDR_QUIRK_300MS_PWRDELAY;
drivers/mmc/host/via-sdmmc.c:	iounmap(sdhost->mmiobase);
drivers/mmc/host/via-sdmmc.c:	spin_lock_irqsave(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:	sdhost->reject = 1;
drivers/mmc/host/via-sdmmc.c:	writeb(0x0, sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);
drivers/mmc/host/via-sdmmc.c:	if (sdhost->mrq) {
drivers/mmc/host/via-sdmmc.c:			"transfer\n", mmc_hostname(sdhost->mmc));
drivers/mmc/host/via-sdmmc.c:			sdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);
drivers/mmc/host/via-sdmmc.c:		sdhost->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:		if (sdhost->mrq->stop)
drivers/mmc/host/via-sdmmc.c:			sdhost->mrq->stop->error = -ENOMEDIUM;
drivers/mmc/host/via-sdmmc.c:		tasklet_schedule(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	spin_unlock_irqrestore(&sdhost->lock, flags);
drivers/mmc/host/via-sdmmc.c:	mmc_remove_host(sdhost->mmc);
drivers/mmc/host/via-sdmmc.c:	del_timer_sync(&sdhost->timer);
drivers/mmc/host/via-sdmmc.c:	tasklet_kill(&sdhost->finish_tasklet);
drivers/mmc/host/via-sdmmc.c:	gatt = readb(sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	iounmap(sdhost->mmiobase);
drivers/mmc/host/via-sdmmc.c:	mmc_free_host(sdhost->mmc);
drivers/mmc/host/via-sdmmc.c:	pm_sdhcreg = &(host->pm_sdhc_reg);
drivers/mmc/host/via-sdmmc.c:	addrbase = host->sdhc_mmiobase;
drivers/mmc/host/via-sdmmc.c:	ret = mmc_suspend_host(host->mmc);
drivers/mmc/host/via-sdmmc.c:	if (sdhost->power == MMC_VDD_165_195)
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	writeb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);
drivers/mmc/host/via-sdmmc.c:	ret = mmc_resume_host(sdhost->mmc);
drivers/mmc/host/wbsd.c:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:	outb(host->unlock_code, host->config);
drivers/mmc/host/wbsd.c:	outb(host->unlock_code, host->config);
drivers/mmc/host/wbsd.c:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:	outb(LOCK_CODE, host->config);
drivers/mmc/host/wbsd.c:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:	outb(reg, host->config);
drivers/mmc/host/wbsd.c:	outb(value, host->config + 1);
drivers/mmc/host/wbsd.c:	BUG_ON(host->config == 0);
drivers/mmc/host/wbsd.c:	outb(reg, host->config);
drivers/mmc/host/wbsd.c:	return inb(host->config + 1);
drivers/mmc/host/wbsd.c:	outb(index, host->base + WBSD_IDXR);
drivers/mmc/host/wbsd.c:	outb(value, host->base + WBSD_DATAR);
drivers/mmc/host/wbsd.c:	outb(index, host->base + WBSD_IDXR);
drivers/mmc/host/wbsd.c:	return inb(host->base + WBSD_DATAR);
drivers/mmc/host/wbsd.c:	host->flags &= ~WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:	host->clk = wbsd_read_index(host, WBSD_IDX_CLK);
drivers/mmc/host/wbsd.c:	outb(WBSD_POWER_N, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:	if (inb(host->base + WBSD_CSR) & WBSD_CARDPRESENT)
drivers/mmc/host/wbsd.c:		host->flags |= WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:		host->flags &= ~WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:	outb(ier, host->base + WBSD_EIR);
drivers/mmc/host/wbsd.c:	inb(host->base + WBSD_ISR);
drivers/mmc/host/wbsd.c:	pr_err("%s: Resetting chip\n", mmc_hostname(host->mmc));
drivers/mmc/host/wbsd.c:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:	host->mrq = NULL;
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	mmc_request_done(host->mmc, mrq);
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	host->cur_sg = data->sg;
drivers/mmc/host/wbsd.c:	host->num_sg = data->sg_len;
drivers/mmc/host/wbsd.c:	host->offset = 0;
drivers/mmc/host/wbsd.c:	host->remain = host->cur_sg->length;
drivers/mmc/host/wbsd.c:	host->cur_sg++;
drivers/mmc/host/wbsd.c:	host->num_sg--;
drivers/mmc/host/wbsd.c:	if (host->num_sg > 0) {
drivers/mmc/host/wbsd.c:		host->offset = 0;
drivers/mmc/host/wbsd.c:		host->remain = host->cur_sg->length;
drivers/mmc/host/wbsd.c:	return host->num_sg;
drivers/mmc/host/wbsd.c:	return sg_virt(host->cur_sg);
drivers/mmc/host/wbsd.c:	char *dmabuf = host->dma_buffer;
drivers/mmc/host/wbsd.c:	char *dmabuf = host->dma_buffer;
drivers/mmc/host/wbsd.c:	host->isr = 0;
drivers/mmc/host/wbsd.c:	outb(cmd->opcode, host->base + WBSD_CMDR);
drivers/mmc/host/wbsd.c:		outb((cmd->arg >> (i * 8)) & 0xff, host->base + WBSD_CMDR);
drivers/mmc/host/wbsd.c:		isr = host->isr;
drivers/mmc/host/wbsd.c:	struct mmc_data *data = host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:	if (host->num_sg == 0)
drivers/mmc/host/wbsd.c:	buffer = wbsd_sg_to_buffer(host) + host->offset;
drivers/mmc/host/wbsd.c:	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {
drivers/mmc/host/wbsd.c:			*buffer = inb(host->base + WBSD_DFR);
drivers/mmc/host/wbsd.c:			host->offset++;
drivers/mmc/host/wbsd.c:			host->remain--;
drivers/mmc/host/wbsd.c:			if (host->remain == 0) {
drivers/mmc/host/wbsd.c:		tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:	struct mmc_data *data = host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:	if (host->num_sg == 0)
drivers/mmc/host/wbsd.c:	buffer = wbsd_sg_to_buffer(host) + host->offset;
drivers/mmc/host/wbsd.c:	while (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {
drivers/mmc/host/wbsd.c:			outb(*buffer, host->base + WBSD_DFR);
drivers/mmc/host/wbsd.c:			host->offset++;
drivers/mmc/host/wbsd.c:			host->remain--;
drivers/mmc/host/wbsd.c:			if (host->remain == 0) {
drivers/mmc/host/wbsd.c:	tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:	if (host->bus_width == MMC_BUS_WIDTH_1) {
drivers/mmc/host/wbsd.c:	} else if (host->bus_width == MMC_BUS_WIDTH_4) {
drivers/mmc/host/wbsd.c:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:			set_dma_mode(host->dma, DMA_MODE_READ & ~0x40);
drivers/mmc/host/wbsd.c:			set_dma_mode(host->dma, DMA_MODE_WRITE & ~0x40);
drivers/mmc/host/wbsd.c:		set_dma_addr(host->dma, host->dma_addr);
drivers/mmc/host/wbsd.c:		set_dma_count(host->dma, size);
drivers/mmc/host/wbsd.c:		enable_dma(host->dma);
drivers/mmc/host/wbsd.c:		host->firsterr = 1;
drivers/mmc/host/wbsd.c:	WARN_ON(host->mrq == NULL);
drivers/mmc/host/wbsd.c:	if (host->dma >= 0) {
drivers/mmc/host/wbsd.c:		disable_dma(host->dma);
drivers/mmc/host/wbsd.c:		clear_dma_ff(host->dma);
drivers/mmc/host/wbsd.c:		count = get_dma_residue(host->dma);
drivers/mmc/host/wbsd.c:		data->bytes_xfered = host->mrq->data->blocks *
drivers/mmc/host/wbsd.c:			host->mrq->data->blksz - count;
drivers/mmc/host/wbsd.c:				mmc_hostname(host->mmc), count);
drivers/mmc/host/wbsd.c:	wbsd_request_end(host, host->mrq);
drivers/mmc/host/wbsd.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	BUG_ON(host->mrq != NULL);
drivers/mmc/host/wbsd.c:	host->mrq = mrq;
drivers/mmc/host/wbsd.c:	if (!(host->flags & WBSD_FCARD_PRESENT)) {
drivers/mmc/host/wbsd.c:				mmc_hostname(host->mmc), cmd->opcode);
drivers/mmc/host/wbsd.c:		if (host->dma == -1)
drivers/mmc/host/wbsd.c:			tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:		spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	if (clk != host->clk) {
drivers/mmc/host/wbsd.c:		host->clk = clk;
drivers/mmc/host/wbsd.c:		pwr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:		outb(pwr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:		host->flags |= WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:			mod_timer(&host->ignore_timer, jiffies + HZ / 100);
drivers/mmc/host/wbsd.c:	host->bus_width = ios->bus_width;
drivers/mmc/host/wbsd.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:	outb(csr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:	outb(csr, host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	host->flags &= ~WBSD_FIGNORE_DETECT;
drivers/mmc/host/wbsd.c:	tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/wbsd.c:	spin_unlock_bh(&host->lock);
drivers/mmc/host/wbsd.c:	WARN_ON(!host->mrq);
drivers/mmc/host/wbsd.c:	if (!host->mrq)
drivers/mmc/host/wbsd.c:	WARN_ON(!host->mrq->cmd);
drivers/mmc/host/wbsd.c:	if (!host->mrq->cmd)
drivers/mmc/host/wbsd.c:	WARN_ON(!host->mrq->cmd->data);
drivers/mmc/host/wbsd.c:	if (!host->mrq->cmd->data)
drivers/mmc/host/wbsd.c:	return host->mrq->cmd->data;
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	if (host->flags & WBSD_FIGNORE_DETECT) {
drivers/mmc/host/wbsd.c:		spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	csr = inb(host->base + WBSD_CSR);
drivers/mmc/host/wbsd.c:		if (!(host->flags & WBSD_FCARD_PRESENT)) {
drivers/mmc/host/wbsd.c:			host->flags |= WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:	} else if (host->flags & WBSD_FCARD_PRESENT) {
drivers/mmc/host/wbsd.c:		host->flags &= ~WBSD_FCARD_PRESENT;
drivers/mmc/host/wbsd.c:		if (host->mrq) {
drivers/mmc/host/wbsd.c:				mmc_hostname(host->mmc));
drivers/mmc/host/wbsd.c:			host->mrq->cmd->error = -ENOMEDIUM;
drivers/mmc/host/wbsd.c:			tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:		mmc_detect_change(host->mmc, msecs_to_jiffies(delay));
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	if (!host->mrq)
drivers/mmc/host/wbsd.c:	if (host->num_sg == 0) {
drivers/mmc/host/wbsd.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	if (!host->mrq)
drivers/mmc/host/wbsd.c:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	if (!host->mrq)
drivers/mmc/host/wbsd.c:	tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	spin_lock(&host->lock);
drivers/mmc/host/wbsd.c:	WARN_ON(!host->mrq);
drivers/mmc/host/wbsd.c:	if (!host->mrq)
drivers/mmc/host/wbsd.c:	spin_unlock(&host->lock);
drivers/mmc/host/wbsd.c:	isr = inb(host->base + WBSD_ISR);
drivers/mmc/host/wbsd.c:	host->isr |= isr;
drivers/mmc/host/wbsd.c:		tasklet_schedule(&host->card_tasklet);
drivers/mmc/host/wbsd.c:		tasklet_schedule(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:		tasklet_hi_schedule(&host->crc_tasklet);
drivers/mmc/host/wbsd.c:		tasklet_hi_schedule(&host->timeout_tasklet);
drivers/mmc/host/wbsd.c:		tasklet_schedule(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	host->mmc = mmc;
drivers/mmc/host/wbsd.c:	host->dma = -1;
drivers/mmc/host/wbsd.c:	spin_lock_init(&host->lock);
drivers/mmc/host/wbsd.c:	init_timer(&host->ignore_timer);
drivers/mmc/host/wbsd.c:	host->ignore_timer.data = (unsigned long)host;
drivers/mmc/host/wbsd.c:	host->ignore_timer.function = wbsd_reset_ignore;
drivers/mmc/host/wbsd.c:	del_timer_sync(&host->ignore_timer);
drivers/mmc/host/wbsd.c:			host->config = config_ports[i];
drivers/mmc/host/wbsd.c:			host->unlock_code = unlock_codes[j];
drivers/mmc/host/wbsd.c:					host->chip_id = id;
drivers/mmc/host/wbsd.c:	host->config = 0;
drivers/mmc/host/wbsd.c:	host->unlock_code = 0;
drivers/mmc/host/wbsd.c:	host->base = base;
drivers/mmc/host/wbsd.c:	if (host->base)
drivers/mmc/host/wbsd.c:		release_region(host->base, 8);
drivers/mmc/host/wbsd.c:	host->base = 0;
drivers/mmc/host/wbsd.c:	if (host->config)
drivers/mmc/host/wbsd.c:		release_region(host->config, 2);
drivers/mmc/host/wbsd.c:	host->config = 0;
drivers/mmc/host/wbsd.c:	host->dma_buffer = kmalloc(WBSD_DMA_SIZE,
drivers/mmc/host/wbsd.c:	if (!host->dma_buffer)
drivers/mmc/host/wbsd.c:	host->dma_addr = dma_map_single(mmc_dev(host->mmc), host->dma_buffer,
drivers/mmc/host/wbsd.c:	if ((host->dma_addr & 0xffff) != 0)
drivers/mmc/host/wbsd.c:	else if (host->dma_addr >= 0x1000000)
drivers/mmc/host/wbsd.c:	host->dma = dma;
drivers/mmc/host/wbsd.c:	dma_unmap_single(mmc_dev(host->mmc), host->dma_addr,
drivers/mmc/host/wbsd.c:	host->dma_addr = 0;
drivers/mmc/host/wbsd.c:	kfree(host->dma_buffer);
drivers/mmc/host/wbsd.c:	host->dma_buffer = NULL;
drivers/mmc/host/wbsd.c:	if (host->dma_addr) {
drivers/mmc/host/wbsd.c:		dma_unmap_single(mmc_dev(host->mmc), host->dma_addr,
drivers/mmc/host/wbsd.c:	kfree(host->dma_buffer);
drivers/mmc/host/wbsd.c:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:		free_dma(host->dma);
drivers/mmc/host/wbsd.c:	host->dma = -1;
drivers/mmc/host/wbsd.c:	host->dma_buffer = NULL;
drivers/mmc/host/wbsd.c:	host->dma_addr = 0;
drivers/mmc/host/wbsd.c:	tasklet_init(&host->card_tasklet, wbsd_tasklet_card,
drivers/mmc/host/wbsd.c:	tasklet_init(&host->fifo_tasklet, wbsd_tasklet_fifo,
drivers/mmc/host/wbsd.c:	tasklet_init(&host->crc_tasklet, wbsd_tasklet_crc,
drivers/mmc/host/wbsd.c:	tasklet_init(&host->timeout_tasklet, wbsd_tasklet_timeout,
drivers/mmc/host/wbsd.c:	tasklet_init(&host->finish_tasklet, wbsd_tasklet_finish,
drivers/mmc/host/wbsd.c:	host->irq = irq;
drivers/mmc/host/wbsd.c:	if (!host->irq)
drivers/mmc/host/wbsd.c:	free_irq(host->irq, host);
drivers/mmc/host/wbsd.c:	host->irq = 0;
drivers/mmc/host/wbsd.c:	tasklet_kill(&host->card_tasklet);
drivers/mmc/host/wbsd.c:	tasklet_kill(&host->fifo_tasklet);
drivers/mmc/host/wbsd.c:	tasklet_kill(&host->crc_tasklet);
drivers/mmc/host/wbsd.c:	tasklet_kill(&host->timeout_tasklet);
drivers/mmc/host/wbsd.c:	tasklet_kill(&host->finish_tasklet);
drivers/mmc/host/wbsd.c:	wbsd_write_config(host, WBSD_CONF_PORT_HI, host->base >> 8);
drivers/mmc/host/wbsd.c:	wbsd_write_config(host, WBSD_CONF_PORT_LO, host->base & 0xff);
drivers/mmc/host/wbsd.c:	wbsd_write_config(host, WBSD_CONF_IRQ, host->irq);
drivers/mmc/host/wbsd.c:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:		wbsd_write_config(host, WBSD_CONF_DRQ, host->dma);
drivers/mmc/host/wbsd.c:	if (base != host->base)
drivers/mmc/host/wbsd.c:	if (irq != host->irq)
drivers/mmc/host/wbsd.c:	if ((dma != host->dma) && (host->dma != -1))
drivers/mmc/host/wbsd.c:		if ((host->config != 0) && !wbsd_chip_validate(host)) {
drivers/mmc/host/wbsd.c:	if (host->config) {
drivers/mmc/host/wbsd.c:	if (host->chip_id != 0)
drivers/mmc/host/wbsd.c:		printk(" id %x", (int)host->chip_id);
drivers/mmc/host/wbsd.c:	printk(" at 0x%x irq %d", (int)host->base, (int)host->irq);
drivers/mmc/host/wbsd.c:	if (host->dma >= 0)
drivers/mmc/host/wbsd.c:		printk(" dma %d", (int)host->dma);
drivers/mmc/host/wbsd.c:	return mmc_suspend_host(host->mmc);
drivers/mmc/host/wbsd.c:	return mmc_resume_host(host->mmc);
drivers/mmc/host/wbsd.c:	if (host->config != 0) {
drivers/mtd/chips/Kconfig:	  are expected to be wired to the CPU in 'host-endian' form.
drivers/mtd/nand/atmel_nand.c:	if (gpio_is_valid(host->board.enable_pin))
drivers/mtd/nand/atmel_nand.c:		gpio_set_value(host->board.enable_pin, 0);
drivers/mtd/nand/atmel_nand.c:	if (gpio_is_valid(host->board.enable_pin))
drivers/mtd/nand/atmel_nand.c:		gpio_set_value(host->board.enable_pin, 1);
drivers/mtd/nand/atmel_nand.c:		writeb(cmd, host->io_base + (1 << host->board.cle));
drivers/mtd/nand/atmel_nand.c:		writeb(cmd, host->io_base + (1 << host->board.ale));
drivers/mtd/nand/atmel_nand.c:	return gpio_get_value(host->board.rdy_pin) ^
drivers/mtd/nand/atmel_nand.c:                !!host->board.rdy_pin_active_low;
drivers/mtd/nand/atmel_nand.c:	dma_dev = host->dma_chan->device;
drivers/mtd/nand/atmel_nand.c:		dev_err(host->dev, "Failed to dma_map_single\n");
drivers/mtd/nand/atmel_nand.c:		dma_src_addr = host->io_phys;
drivers/mtd/nand/atmel_nand.c:		dma_dst_addr = host->io_phys;
drivers/mtd/nand/atmel_nand.c:	tx = dma_dev->device_prep_dma_memcpy(host->dma_chan, dma_dst_addr,
drivers/mtd/nand/atmel_nand.c:		dev_err(host->dev, "Failed to prepare DMA memcpy\n");
drivers/mtd/nand/atmel_nand.c:	init_completion(&host->comp);
drivers/mtd/nand/atmel_nand.c:	tx->callback_param = &host->comp;
drivers/mtd/nand/atmel_nand.c:		dev_err(host->dev, "Failed to do DMA tx_submit\n");
drivers/mtd/nand/atmel_nand.c:	dma_async_issue_pending(host->dma_chan);
drivers/mtd/nand/atmel_nand.c:	wait_for_completion(&host->comp);
drivers/mtd/nand/atmel_nand.c:		dev_warn(host->dev, "Fall back to CPU I/O\n");
drivers/mtd/nand/atmel_nand.c:	if (host->board.bus_width_16)
drivers/mtd/nand/atmel_nand.c:	if (host->board.bus_width_16)
drivers/mtd/nand/atmel_nand.c:	ecc_value = ecc_readl(host->ecc, PR);
drivers/mtd/nand/atmel_nand.c:	ecc_value = ecc_readl(host->ecc, NPR) & ATMEL_ECC_NPARITY;
drivers/mtd/nand/atmel_nand.c:		ecc_writel(host->ecc, CR, ATMEL_ECC_RST);
drivers/mtd/nand/atmel_nand.c:	ecc_status = ecc_readl(host->ecc, SR);
drivers/mtd/nand/atmel_nand.c:	ecc_bit = ecc_readl(host->ecc, PR) & ATMEL_ECC_BITADDR;
drivers/mtd/nand/atmel_nand.c:	ecc_word = ecc_readl(host->ecc, PR) & ATMEL_ECC_WORDADDR;
drivers/mtd/nand/atmel_nand.c:		dev_dbg(host->dev, "atmel_nand : multiple errors detected."
drivers/mtd/nand/atmel_nand.c:		dev_dbg(host->dev, "atmel_nand : one bit error on ECC code."
drivers/mtd/nand/atmel_nand.c:	dev_dbg(host->dev, "atmel_nand : one bit error on data."
drivers/mtd/nand/atmel_nand.c:	dev_dbg(host->dev, "atmel_nand : error corrected\n");
drivers/mtd/nand/atmel_nand.c:		ecc_writel(host->ecc, CR, ATMEL_ECC_RST);
drivers/mtd/nand/atmel_nand.c:	struct atmel_nand_data *board = &host->board;
drivers/mtd/nand/atmel_nand.c:			dev_err(host->dev, "invalid addr-offset %u\n", val);
drivers/mtd/nand/atmel_nand.c:			dev_err(host->dev, "invalid cmd-offset %u\n", val);
drivers/mtd/nand/atmel_nand.c:	host->io_phys = (dma_addr_t)mem->start;
drivers/mtd/nand/atmel_nand.c:	host->io_base = ioremap(mem->start, resource_size(mem));
drivers/mtd/nand/atmel_nand.c:	if (host->io_base == NULL) {
drivers/mtd/nand/atmel_nand.c:	mtd = &host->mtd;
drivers/mtd/nand/atmel_nand.c:	nand_chip = &host->nand_chip;
drivers/mtd/nand/atmel_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/atmel_nand.c:		memcpy(&host->board, pdev->dev.platform_data,
drivers/mtd/nand/atmel_nand.c:	nand_chip->IO_ADDR_R = host->io_base;
drivers/mtd/nand/atmel_nand.c:	nand_chip->IO_ADDR_W = host->io_base;
drivers/mtd/nand/atmel_nand.c:	if (gpio_is_valid(host->board.rdy_pin))
drivers/mtd/nand/atmel_nand.c:	nand_chip->ecc.mode = host->board.ecc_mode;
drivers/mtd/nand/atmel_nand.c:		host->ecc = ioremap(regs->start, resource_size(regs));
drivers/mtd/nand/atmel_nand.c:		if (host->ecc == NULL) {
drivers/mtd/nand/atmel_nand.c:	if (host->board.bus_width_16)	/* 16-bit bus width */
drivers/mtd/nand/atmel_nand.c:	if (gpio_is_valid(host->board.det_pin)) {
drivers/mtd/nand/atmel_nand.c:		if (gpio_get_value(host->board.det_pin)) {
drivers/mtd/nand/atmel_nand.c:	if (host->board.on_flash_bbt || on_flash_bbt) {
drivers/mtd/nand/atmel_nand.c:		host->dma_chan = dma_request_channel(mask, NULL, NULL);
drivers/mtd/nand/atmel_nand.c:		if (!host->dma_chan) {
drivers/mtd/nand/atmel_nand.c:			dev_err(host->dev, "Failed to request DMA channel\n");
drivers/mtd/nand/atmel_nand.c:		dev_info(host->dev, "Using %s for DMA transfers.\n",
drivers/mtd/nand/atmel_nand.c:					dma_chan_name(host->dma_chan));
drivers/mtd/nand/atmel_nand.c:		dev_info(host->dev, "No DMA support for NAND access.\n");
drivers/mtd/nand/atmel_nand.c:			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);
drivers/mtd/nand/atmel_nand.c:			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);
drivers/mtd/nand/atmel_nand.c:			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);
drivers/mtd/nand/atmel_nand.c:			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);
drivers/mtd/nand/atmel_nand.c:			host->board.parts, host->board.num_parts);
drivers/mtd/nand/atmel_nand.c:	if (host->dma_chan)
drivers/mtd/nand/atmel_nand.c:		dma_release_channel(host->dma_chan);
drivers/mtd/nand/atmel_nand.c:	if (host->ecc)
drivers/mtd/nand/atmel_nand.c:		iounmap(host->ecc);
drivers/mtd/nand/atmel_nand.c:	iounmap(host->io_base);
drivers/mtd/nand/atmel_nand.c:	struct mtd_info *mtd = &host->mtd;
drivers/mtd/nand/atmel_nand.c:	if (host->ecc)
drivers/mtd/nand/atmel_nand.c:		iounmap(host->ecc);
drivers/mtd/nand/atmel_nand.c:	if (host->dma_chan)
drivers/mtd/nand/atmel_nand.c:		dma_release_channel(host->dma_chan);
drivers/mtd/nand/atmel_nand.c:	iounmap(host->io_base);
drivers/mtd/nand/fsmc_nand.c:		if (host->select_chip)
drivers/mtd/nand/fsmc_nand.c:			host->select_chip(chipnr,
drivers/mtd/nand/fsmc_nand.c:	void *__iomem *regs = host->regs_va;
drivers/mtd/nand/fsmc_nand.c:	unsigned int bank = host->bank;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_R = host->cmd_va;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_W = host->cmd_va;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_R = host->addr_va;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_W = host->addr_va;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_R = host->data_va;
drivers/mtd/nand/fsmc_nand.c:			this->IO_ADDR_W = host->data_va;
drivers/mtd/nand/fsmc_nand.c:	void __iomem *regs = host->regs_va;
drivers/mtd/nand/fsmc_nand.c:	uint32_t bank = host->bank;
drivers/mtd/nand/fsmc_nand.c:	void __iomem *regs = host->regs_va;
drivers/mtd/nand/fsmc_nand.c:	uint32_t bank = host->bank;
drivers/mtd/nand/fsmc_nand.c:		dev_err(host->dev, "calculate ecc timed out\n");
drivers/mtd/nand/fsmc_nand.c:	void __iomem *regs = host->regs_va;
drivers/mtd/nand/fsmc_nand.c:	uint32_t bank = host->bank;
drivers/mtd/nand/fsmc_nand.c:	complete(&host->dma_access_complete);
drivers/mtd/nand/fsmc_nand.c:		chan = host->write_dma_chan;
drivers/mtd/nand/fsmc_nand.c:		chan = host->read_dma_chan;
drivers/mtd/nand/fsmc_nand.c:		dma_dst = host->data_pa;
drivers/mtd/nand/fsmc_nand.c:		dma_src = host->data_pa;
drivers/mtd/nand/fsmc_nand.c:		dev_err(host->dev, "device_prep_dma_memcpy error\n");
drivers/mtd/nand/fsmc_nand.c:		dev_err(host->dev, "dma_submit_error %d\n", cookie);
drivers/mtd/nand/fsmc_nand.c:	wait_for_completion_interruptible_timeout(&host->dma_access_complete,
drivers/mtd/nand/fsmc_nand.c:		dev_err(host->dev, "wait_for_completion_timeout\n");
drivers/mtd/nand/fsmc_nand.c:	struct fsmc_eccplace *ecc_place = host->ecc_place;
drivers/mtd/nand/fsmc_nand.c:	void __iomem *regs = host->regs_va;
drivers/mtd/nand/fsmc_nand.c:	unsigned int bank = host->bank;
drivers/mtd/nand/fsmc_nand.c:	host->data_pa = (dma_addr_t)res->start;
drivers/mtd/nand/fsmc_nand.c:	host->data_va = devm_ioremap(&pdev->dev, res->start,
drivers/mtd/nand/fsmc_nand.c:	if (!host->data_va) {
drivers/mtd/nand/fsmc_nand.c:	host->addr_va = devm_ioremap(&pdev->dev, res->start + pdata->ale_off,
drivers/mtd/nand/fsmc_nand.c:	if (!host->addr_va) {
drivers/mtd/nand/fsmc_nand.c:	host->cmd_va = devm_ioremap(&pdev->dev, res->start + pdata->cle_off,
drivers/mtd/nand/fsmc_nand.c:	if (!host->cmd_va) {
drivers/mtd/nand/fsmc_nand.c:	host->regs_va = devm_ioremap(&pdev->dev, res->start,
drivers/mtd/nand/fsmc_nand.c:	if (!host->regs_va) {
drivers/mtd/nand/fsmc_nand.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/fsmc_nand.c:	if (IS_ERR(host->clk)) {
drivers/mtd/nand/fsmc_nand.c:		return PTR_ERR(host->clk);
drivers/mtd/nand/fsmc_nand.c:	ret = clk_enable(host->clk);
drivers/mtd/nand/fsmc_nand.c:		pid |= (readl(host->regs_va + resource_size(res) - 0x20 + 4 * i) & 255) << (i * 8);
drivers/mtd/nand/fsmc_nand.c:	host->pid = pid;
drivers/mtd/nand/fsmc_nand.c:	host->bank = pdata->bank;
drivers/mtd/nand/fsmc_nand.c:	host->select_chip = pdata->select_bank;
drivers/mtd/nand/fsmc_nand.c:	host->partitions = pdata->partitions;
drivers/mtd/nand/fsmc_nand.c:	host->nr_partitions = pdata->nr_partitions;
drivers/mtd/nand/fsmc_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/fsmc_nand.c:	host->dev_timings = pdata->nand_timings;
drivers/mtd/nand/fsmc_nand.c:	host->mode = pdata->mode;
drivers/mtd/nand/fsmc_nand.c:	if (host->mode == USE_DMA_ACCESS)
drivers/mtd/nand/fsmc_nand.c:		init_completion(&host->dma_access_complete);
drivers/mtd/nand/fsmc_nand.c:	mtd = &host->mtd;
drivers/mtd/nand/fsmc_nand.c:	nand = &host->nand;
drivers/mtd/nand/fsmc_nand.c:	host->mtd.owner = THIS_MODULE;
drivers/mtd/nand/fsmc_nand.c:	nand->IO_ADDR_R = host->data_va;
drivers/mtd/nand/fsmc_nand.c:	nand->IO_ADDR_W = host->data_va;
drivers/mtd/nand/fsmc_nand.c:	switch (host->mode) {
drivers/mtd/nand/fsmc_nand.c:		host->read_dma_chan = dma_request_channel(mask, filter,
drivers/mtd/nand/fsmc_nand.c:		if (!host->read_dma_chan) {
drivers/mtd/nand/fsmc_nand.c:		host->write_dma_chan = dma_request_channel(mask, filter,
drivers/mtd/nand/fsmc_nand.c:		if (!host->write_dma_chan) {
drivers/mtd/nand/fsmc_nand.c:	fsmc_nand_setup(host->regs_va, host->bank,
drivers/mtd/nand/fsmc_nand.c:			host->dev_timings);
drivers/mtd/nand/fsmc_nand.c:	if (AMBA_REV_BITS(host->pid) >= 8) {
drivers/mtd/nand/fsmc_nand.c:	if (nand_scan_ident(&host->mtd, 1, NULL)) {
drivers/mtd/nand/fsmc_nand.c:	if (AMBA_REV_BITS(host->pid) >= 8) {
drivers/mtd/nand/fsmc_nand.c:		switch (host->mtd.oobsize) {
drivers/mtd/nand/fsmc_nand.c:			host->ecc_place = &fsmc_ecc4_sp_place;
drivers/mtd/nand/fsmc_nand.c:			host->ecc_place = &fsmc_ecc4_lp_place;
drivers/mtd/nand/fsmc_nand.c:			host->ecc_place = &fsmc_ecc4_lp_place;
drivers/mtd/nand/fsmc_nand.c:			host->ecc_place = &fsmc_ecc4_lp_place;
drivers/mtd/nand/fsmc_nand.c:			host->ecc_place = &fsmc_ecc4_lp_place;
drivers/mtd/nand/fsmc_nand.c:		switch (host->mtd.oobsize) {
drivers/mtd/nand/fsmc_nand.c:	if (nand_scan_tail(&host->mtd)) {
drivers/mtd/nand/fsmc_nand.c:	host->mtd.name = "nand";
drivers/mtd/nand/fsmc_nand.c:	ret = mtd_device_parse_register(&host->mtd, NULL, &ppdata,
drivers/mtd/nand/fsmc_nand.c:					host->partitions, host->nr_partitions);
drivers/mtd/nand/fsmc_nand.c:	if (host->mode == USE_DMA_ACCESS)
drivers/mtd/nand/fsmc_nand.c:		dma_release_channel(host->write_dma_chan);
drivers/mtd/nand/fsmc_nand.c:	if (host->mode == USE_DMA_ACCESS)
drivers/mtd/nand/fsmc_nand.c:		dma_release_channel(host->read_dma_chan);
drivers/mtd/nand/fsmc_nand.c:	clk_disable(host->clk);
drivers/mtd/nand/fsmc_nand.c:	clk_put(host->clk);
drivers/mtd/nand/fsmc_nand.c:		nand_release(&host->mtd);
drivers/mtd/nand/fsmc_nand.c:		if (host->mode == USE_DMA_ACCESS) {
drivers/mtd/nand/fsmc_nand.c:			dma_release_channel(host->write_dma_chan);
drivers/mtd/nand/fsmc_nand.c:			dma_release_channel(host->read_dma_chan);
drivers/mtd/nand/fsmc_nand.c:		clk_disable(host->clk);
drivers/mtd/nand/fsmc_nand.c:		clk_put(host->clk);
drivers/mtd/nand/fsmc_nand.c:		clk_disable(host->clk);
drivers/mtd/nand/fsmc_nand.c:		clk_enable(host->clk);
drivers/mtd/nand/fsmc_nand.c:		fsmc_nand_setup(host->regs_va, host->bank,
drivers/mtd/nand/fsmc_nand.c:				host->nand.options & NAND_BUSWIDTH_16,
drivers/mtd/nand/fsmc_nand.c:				host->dev_timings);
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_BUF_SIZE		(host->regs + 0x00)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_BUF_ADDR		(host->regs + 0x04)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_FLASH_ADDR		(host->regs + 0x06)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_FLASH_CMD		(host->regs + 0x08)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_CONFIG		(host->regs + 0x0a)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_ECC_STATUS_RESULT	(host->regs + 0x0c)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_RSLTMAIN_AREA		(host->regs + 0x0e)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_RSLTSPARE_AREA	(host->regs + 0x10)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_WRPROT		(host->regs + 0x12)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_UNLOCKSTART_BLKADDR	(host->regs + 0x14)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_UNLOCKEND_BLKADDR	(host->regs + 0x16)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKSTART_BLKADDR0	(host->regs + 0x20)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKSTART_BLKADDR1	(host->regs + 0x24)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKSTART_BLKADDR2	(host->regs + 0x28)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKSTART_BLKADDR3	(host->regs + 0x2c)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKEND_BLKADDR0	(host->regs + 0x22)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKEND_BLKADDR1	(host->regs + 0x26)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKEND_BLKADDR2	(host->regs + 0x2a)
drivers/mtd/nand/mxc_nand.c:#define NFC_V21_UNLOCKEND_BLKADDR3	(host->regs + 0x2e)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_NF_WRPRST		(host->regs + 0x18)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_CONFIG1		(host->regs + 0x1a)
drivers/mtd/nand/mxc_nand.c:#define NFC_V1_V2_CONFIG2		(host->regs + 0x1c)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_FLASH_CMD		(host->regs_axi + 0x00)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_FLASH_ADDR0		(host->regs_axi + 0x04)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_CONFIG1			(host->regs_axi + 0x34)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_ECC_STATUS_RESULT	(host->regs_axi + 0x38)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_LAUNCH			(host->regs_axi + 0x40)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_WRPROT			(host->regs_ip + 0x0)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_WRPROT_UNLOCK_BLK_ADD0   (host->regs_ip + 0x04)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_CONFIG2			(host->regs_ip + 0x24)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_CONFIG3				(host->regs_ip + 0x28)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_IPC			(host->regs_ip + 0x2C)
drivers/mtd/nand/mxc_nand.c:#define NFC_V3_DELAY_LINE		(host->regs_ip + 0x34)
drivers/mtd/nand/mxc_nand.c:	if (!host->check_int(host))
drivers/mtd/nand/mxc_nand.c:	host->irq_control(host, 0);
drivers/mtd/nand/mxc_nand.c:	complete(&host->op_completion);
drivers/mtd/nand/mxc_nand.c:		enable_irq(host->irq);
drivers/mtd/nand/mxc_nand.c:		disable_irq_nosync(host->irq);
drivers/mtd/nand/mxc_nand.c:		if (!host->check_int(host)) {
drivers/mtd/nand/mxc_nand.c:			INIT_COMPLETION(host->op_completion);
drivers/mtd/nand/mxc_nand.c:			host->irq_control(host, 1);
drivers/mtd/nand/mxc_nand.c:			wait_for_completion(&host->op_completion);
drivers/mtd/nand/mxc_nand.c:			if (host->check_int(host))
drivers/mtd/nand/mxc_nand.c:		writew((host->active_cs << 4) | i, NFC_V1_V2_BUF_ADDR);
drivers/mtd/nand/mxc_nand.c:	memcpy(host->data_buf, host->main_area0, 16);
drivers/mtd/nand/mxc_nand.c:	struct nand_chip *this = &host->nand;
drivers/mtd/nand/mxc_nand.c:	writew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);
drivers/mtd/nand/mxc_nand.c:	memcpy(host->data_buf, host->main_area0, 16);
drivers/mtd/nand/mxc_nand.c:		host->data_buf[1] = host->data_buf[2];
drivers/mtd/nand/mxc_nand.c:		host->data_buf[2] = host->data_buf[4];
drivers/mtd/nand/mxc_nand.c:		host->data_buf[3] = host->data_buf[6];
drivers/mtd/nand/mxc_nand.c:		host->data_buf[4] = host->data_buf[8];
drivers/mtd/nand/mxc_nand.c:		host->data_buf[5] = host->data_buf[10];
drivers/mtd/nand/mxc_nand.c:	void __iomem *main_buf = host->main_area0;
drivers/mtd/nand/mxc_nand.c:	writew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);
drivers/mtd/nand/mxc_nand.c:	ecc_bit_mask = (host->eccsize == 4) ? 0x7 : 0xf;
drivers/mtd/nand/mxc_nand.c:	err_limit = (host->eccsize == 4) ? 0x4 : 0x8;
drivers/mtd/nand/mxc_nand.c:	if (host->status_request)
drivers/mtd/nand/mxc_nand.c:		return host->get_dev_status(host) & 0xFF;
drivers/mtd/nand/mxc_nand.c:	ret = *(uint8_t *)(host->data_buf + host->buf_start);
drivers/mtd/nand/mxc_nand.c:	host->buf_start++;
drivers/mtd/nand/mxc_nand.c:	ret = *(uint16_t *)(host->data_buf + host->buf_start);
drivers/mtd/nand/mxc_nand.c:	host->buf_start += 2;
drivers/mtd/nand/mxc_nand.c:	u16 col = host->buf_start;
drivers/mtd/nand/mxc_nand.c:	memcpy(host->data_buf + col, buf, n);
drivers/mtd/nand/mxc_nand.c:	host->buf_start += n;
drivers/mtd/nand/mxc_nand.c:	u16 col = host->buf_start;
drivers/mtd/nand/mxc_nand.c:	memcpy(buf, host->data_buf + col, n);
drivers/mtd/nand/mxc_nand.c:	host->buf_start += n;
drivers/mtd/nand/mxc_nand.c:		if (host->clk_act) {
drivers/mtd/nand/mxc_nand.c:			clk_disable(host->clk);
drivers/mtd/nand/mxc_nand.c:			host->clk_act = 0;
drivers/mtd/nand/mxc_nand.c:	if (!host->clk_act) {
drivers/mtd/nand/mxc_nand.c:		clk_enable(host->clk);
drivers/mtd/nand/mxc_nand.c:		host->clk_act = 1;
drivers/mtd/nand/mxc_nand.c:		host->active_cs = chip;
drivers/mtd/nand/mxc_nand.c:		writew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);
drivers/mtd/nand/mxc_nand.c:	u8 *d = host->data_buf + mtd->writesize;
drivers/mtd/nand/mxc_nand.c:	u8 *s = host->spare0;
drivers/mtd/nand/mxc_nand.c:	u16 t = host->spare_len;
drivers/mtd/nand/mxc_nand.c:		host->send_addr(host, 0, page_addr == -1);
drivers/mtd/nand/mxc_nand.c:			host->send_addr(host, 0, false);
drivers/mtd/nand/mxc_nand.c:		host->send_addr(host, (page_addr & 0xff), false);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 8) & 0xff, false);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 16) & 0xff, true);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 8) & 0xff, true);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 8) & 0xff, false);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 16) & 0xff, true);
drivers/mtd/nand/mxc_nand.c:				host->send_addr(host, (page_addr >> 8) & 0xff, true);
drivers/mtd/nand/mxc_nand.c:		host->eccsize = get_eccsize(mtd);
drivers/mtd/nand/mxc_nand.c:		if (host->eccsize == 4)
drivers/mtd/nand/mxc_nand.c:		host->eccsize = 1;
drivers/mtd/nand/mxc_nand.c:		host->eccsize = get_eccsize(mtd);
drivers/mtd/nand/mxc_nand.c:		if (host->eccsize == 8)
drivers/mtd/nand/mxc_nand.c:	host->status_request = false;
drivers/mtd/nand/mxc_nand.c:		host->preset(mtd);
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, false);
drivers/mtd/nand/mxc_nand.c:		host->buf_start = 0;
drivers/mtd/nand/mxc_nand.c:		host->status_request = true;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, true);
drivers/mtd/nand/mxc_nand.c:			host->buf_start = column;
drivers/mtd/nand/mxc_nand.c:			host->buf_start = column + mtd->writesize;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, false);
drivers/mtd/nand/mxc_nand.c:			host->send_cmd(host, NAND_CMD_READSTART, true);
drivers/mtd/nand/mxc_nand.c:		host->send_page(mtd, NFC_OUTPUT);
drivers/mtd/nand/mxc_nand.c:		memcpy(host->data_buf, host->main_area0, mtd->writesize);
drivers/mtd/nand/mxc_nand.c:		host->buf_start = column;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, false);
drivers/mtd/nand/mxc_nand.c:		memcpy(host->main_area0, host->data_buf, mtd->writesize);
drivers/mtd/nand/mxc_nand.c:		host->send_page(mtd, NFC_INPUT);
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, true);
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, true);
drivers/mtd/nand/mxc_nand.c:		host->send_read_id(host);
drivers/mtd/nand/mxc_nand.c:		host->buf_start = column;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd(host, command, false);
drivers/mtd/nand/mxc_nand.c:	host->data_buf = (uint8_t *)(host + 1);
drivers/mtd/nand/mxc_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/mxc_nand.c:	this = &host->nand;
drivers/mtd/nand/mxc_nand.c:	mtd = &host->mtd;
drivers/mtd/nand/mxc_nand.c:	host->clk = clk_get(&pdev->dev, "nfc");
drivers/mtd/nand/mxc_nand.c:	if (IS_ERR(host->clk)) {
drivers/mtd/nand/mxc_nand.c:		err = PTR_ERR(host->clk);
drivers/mtd/nand/mxc_nand.c:	clk_enable(host->clk);
drivers/mtd/nand/mxc_nand.c:	host->clk_act = 1;
drivers/mtd/nand/mxc_nand.c:	host->base = ioremap(res->start, resource_size(res));
drivers/mtd/nand/mxc_nand.c:	if (!host->base) {
drivers/mtd/nand/mxc_nand.c:	host->main_area0 = host->base;
drivers/mtd/nand/mxc_nand.c:		host->preset = preset_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd = send_cmd_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->send_addr = send_addr_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->send_page = send_page_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->send_read_id = send_read_id_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->get_dev_status = get_dev_status_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->check_int = check_int_v1_v2;
drivers/mtd/nand/mxc_nand.c:			host->irq_control = irq_control_mx21;
drivers/mtd/nand/mxc_nand.c:			host->irq_control = irq_control_v1_v2;
drivers/mtd/nand/mxc_nand.c:		host->regs = host->base + 0x1e00;
drivers/mtd/nand/mxc_nand.c:		host->spare0 = host->base + 0x1000;
drivers/mtd/nand/mxc_nand.c:		host->spare_len = 64;
drivers/mtd/nand/mxc_nand.c:		host->regs = host->base + 0xe00;
drivers/mtd/nand/mxc_nand.c:		host->spare0 = host->base + 0x800;
drivers/mtd/nand/mxc_nand.c:		host->spare_len = 16;
drivers/mtd/nand/mxc_nand.c:		host->eccsize = 1;
drivers/mtd/nand/mxc_nand.c:		host->regs_ip = ioremap(res->start, resource_size(res));
drivers/mtd/nand/mxc_nand.c:		if (!host->regs_ip) {
drivers/mtd/nand/mxc_nand.c:		host->regs_axi = host->base + 0x1e00;
drivers/mtd/nand/mxc_nand.c:		host->spare0 = host->base + 0x1000;
drivers/mtd/nand/mxc_nand.c:		host->spare_len = 64;
drivers/mtd/nand/mxc_nand.c:		host->preset = preset_v3;
drivers/mtd/nand/mxc_nand.c:		host->send_cmd = send_cmd_v3;
drivers/mtd/nand/mxc_nand.c:		host->send_addr = send_addr_v3;
drivers/mtd/nand/mxc_nand.c:		host->send_page = send_page_v3;
drivers/mtd/nand/mxc_nand.c:		host->send_read_id = send_read_id_v3;
drivers/mtd/nand/mxc_nand.c:		host->check_int = check_int_v3;
drivers/mtd/nand/mxc_nand.c:		host->get_dev_status = get_dev_status_v3;
drivers/mtd/nand/mxc_nand.c:		host->irq_control = irq_control_v3;
drivers/mtd/nand/mxc_nand.c:	init_completion(&host->op_completion);
drivers/mtd/nand/mxc_nand.c:	host->irq = platform_get_irq(pdev, 0);
drivers/mtd/nand/mxc_nand.c:		host->irq_control(host, 0);
drivers/mtd/nand/mxc_nand.c:	err = request_irq(host->irq, mxc_nfc_irq, IRQF_DISABLED, DRIVER_NAME, host);
drivers/mtd/nand/mxc_nand.c:	host->irq_control(host, 0);
drivers/mtd/nand/mxc_nand.c:	host->preset(mtd);
drivers/mtd/nand/mxc_nand.c:			this->ecc.strength = (host->eccsize == 4) ? 4 : 8;
drivers/mtd/nand/mxc_nand.c:	free_irq(host->irq, host);
drivers/mtd/nand/mxc_nand.c:	if (host->regs_ip)
drivers/mtd/nand/mxc_nand.c:		iounmap(host->regs_ip);
drivers/mtd/nand/mxc_nand.c:	iounmap(host->base);
drivers/mtd/nand/mxc_nand.c:	clk_put(host->clk);
drivers/mtd/nand/mxc_nand.c:	clk_put(host->clk);
drivers/mtd/nand/mxc_nand.c:	nand_release(&host->mtd);
drivers/mtd/nand/mxc_nand.c:	free_irq(host->irq, host);
drivers/mtd/nand/mxc_nand.c:	if (host->regs_ip)
drivers/mtd/nand/mxc_nand.c:		iounmap(host->regs_ip);
drivers/mtd/nand/mxc_nand.c:	iounmap(host->base);
drivers/mtd/nand/nomadik_nand.c:		writeb(cmd, host->cmd_va);
drivers/mtd/nand/nomadik_nand.c:		writeb(cmd, host->addr_va);
drivers/mtd/nand/nomadik_nand.c:	host->addr_va = ioremap(res->start, resource_size(res));
drivers/mtd/nand/nomadik_nand.c:	host->data_va = ioremap(res->start, resource_size(res));
drivers/mtd/nand/nomadik_nand.c:	host->cmd_va = ioremap(res->start, resource_size(res));
drivers/mtd/nand/nomadik_nand.c:	if (!host->addr_va || !host->data_va || !host->cmd_va) {
drivers/mtd/nand/nomadik_nand.c:	mtd = &host->mtd;
drivers/mtd/nand/nomadik_nand.c:	nand = &host->nand;
drivers/mtd/nand/nomadik_nand.c:	host->mtd.owner = THIS_MODULE;
drivers/mtd/nand/nomadik_nand.c:	nand->IO_ADDR_R = host->data_va;
drivers/mtd/nand/nomadik_nand.c:	nand->IO_ADDR_W = host->data_va;
drivers/mtd/nand/nomadik_nand.c:	if (nand_scan(&host->mtd, 1)) {
drivers/mtd/nand/nomadik_nand.c:	mtd_device_register(&host->mtd, pdata->parts, pdata->nparts);
drivers/mtd/nand/nomadik_nand.c:	if (host->cmd_va)
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->cmd_va);
drivers/mtd/nand/nomadik_nand.c:	if (host->data_va)
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->data_va);
drivers/mtd/nand/nomadik_nand.c:	if (host->addr_va)
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->addr_va);
drivers/mtd/nand/nomadik_nand.c:		nand_release(&host->mtd);
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->cmd_va);
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->data_va);
drivers/mtd/nand/nomadik_nand.c:		iounmap(host->addr_va);
drivers/mtd/nand/nomadik_nand.c:		ret = mtd_suspend(&host->mtd);
drivers/mtd/nand/nomadik_nand.c:		mtd_resume(&host->mtd);
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	host->ndtr0cs0 = ndtr0;
drivers/mtd/nand/pxa3xx_nand.c:	host->ndtr1cs0 = ndtr1;
drivers/mtd/nand/pxa3xx_nand.c:	int oob_enable = host->reg_ndcr & NDCR_SPARE_EN;
drivers/mtd/nand/pxa3xx_nand.c:	info->data_size = host->page_size;
drivers/mtd/nand/pxa3xx_nand.c:	switch (host->page_size) {
drivers/mtd/nand/pxa3xx_nand.c:	ndcr = host->reg_ndcr;
drivers/mtd/nand/pxa3xx_nand.c:	mtd = host->mtd;
drivers/mtd/nand/pxa3xx_nand.c:	addr_cycle = NDCB0_ADDR_CYC(host->row_addr_cycles
drivers/mtd/nand/pxa3xx_nand.c:				    + host->col_addr_cycles);
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->read1;
drivers/mtd/nand/pxa3xx_nand.c:		if (unlikely(host->page_size < PAGE_CHUNK_SIZE))
drivers/mtd/nand/pxa3xx_nand.c:		if (unlikely(host->page_size < PAGE_CHUNK_SIZE)) {
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->program;
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->read_id;
drivers/mtd/nand/pxa3xx_nand.c:		info->buf_count = host->read_id_bytes;
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->read_status;
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->erase;
drivers/mtd/nand/pxa3xx_nand.c:		cmd = host->cmdset->reset;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	if (host->reg_ndcr & NDCR_DWIDTH_M)
drivers/mtd/nand/pxa3xx_nand.c:	if (info->cs != host->cs) {
drivers/mtd/nand/pxa3xx_nand.c:		info->cs = host->cs;
drivers/mtd/nand/pxa3xx_nand.c:		nand_writel(info, NDTR0CS0, host->ndtr0cs0);
drivers/mtd/nand/pxa3xx_nand.c:		nand_writel(info, NDTR1CS0, host->ndtr1cs0);
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	host->cmdset = &default_cmdset;
drivers/mtd/nand/pxa3xx_nand.c:	host->page_size = f->page_size;
drivers/mtd/nand/pxa3xx_nand.c:	host->read_id_bytes = (f->page_size == 2048) ? 4 : 2;
drivers/mtd/nand/pxa3xx_nand.c:	host->col_addr_cycles = (f->page_size == 2048) ? 2 : 1;
drivers/mtd/nand/pxa3xx_nand.c:		host->row_addr_cycles = 3;
drivers/mtd/nand/pxa3xx_nand.c:		host->row_addr_cycles = 2;
drivers/mtd/nand/pxa3xx_nand.c:	ndcr |= (host->col_addr_cycles == 2) ? NDCR_RA_START : 0;
drivers/mtd/nand/pxa3xx_nand.c:	ndcr |= NDCR_RD_ID_CNT(host->read_id_bytes);
drivers/mtd/nand/pxa3xx_nand.c:	host->reg_ndcr = ndcr;
drivers/mtd/nand/pxa3xx_nand.c:		host->page_size = 2048;
drivers/mtd/nand/pxa3xx_nand.c:		host->read_id_bytes = 4;
drivers/mtd/nand/pxa3xx_nand.c:		host->page_size = 512;
drivers/mtd/nand/pxa3xx_nand.c:		host->read_id_bytes = 2;
drivers/mtd/nand/pxa3xx_nand.c:	host->reg_ndcr = ndcr & ~NDCR_INT_MASK;
drivers/mtd/nand/pxa3xx_nand.c:	host->cmdset = &default_cmdset;
drivers/mtd/nand/pxa3xx_nand.c:	host->ndtr0cs0 = nand_readl(info, NDTR0CS0);
drivers/mtd/nand/pxa3xx_nand.c:	host->ndtr1cs0 = nand_readl(info, NDTR1CS0);
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_info *info = host->info_data;
drivers/mtd/nand/pxa3xx_nand.c:	chip->ecc.size = host->page_size;
drivers/mtd/nand/pxa3xx_nand.c:	if (host->reg_ndcr & NDCR_DWIDTH_M)
drivers/mtd/nand/pxa3xx_nand.c:		host->col_addr_cycles = 2;
drivers/mtd/nand/pxa3xx_nand.c:		host->col_addr_cycles = 1;
drivers/mtd/nand/pxa3xx_nand.c:		host->row_addr_cycles = 3;
drivers/mtd/nand/pxa3xx_nand.c:		host->row_addr_cycles = 2;
drivers/mtd/nand/pxa3xx_nand.c:		host->mtd = mtd;
drivers/mtd/nand/pxa3xx_nand.c:		host->cs = cs;
drivers/mtd/nand/pxa3xx_nand.c:		host->info_data = info;
drivers/mtd/nand/socrates_nand.c:		out_be32(host->io_base, FPGA_NAND_ENABLE |
drivers/mtd/nand/socrates_nand.c:	out_be32(host->io_base, val);
drivers/mtd/nand/socrates_nand.c:		buf[i] = (in_be32(host->io_base) >>
drivers/mtd/nand/socrates_nand.c:	out_be32(host->io_base, val);
drivers/mtd/nand/socrates_nand.c:	if (in_be32(host->io_base) & FPGA_NAND_BUSY)
drivers/mtd/nand/socrates_nand.c:	host->io_base = of_iomap(ofdev->dev.of_node, 0);
drivers/mtd/nand/socrates_nand.c:	if (host->io_base == NULL) {
drivers/mtd/nand/socrates_nand.c:	mtd = &host->mtd;
drivers/mtd/nand/socrates_nand.c:	nand_chip = &host->nand_chip;
drivers/mtd/nand/socrates_nand.c:	host->dev = &ofdev->dev;
drivers/mtd/nand/socrates_nand.c:	iounmap(host->io_base);
drivers/mtd/nand/socrates_nand.c:	struct mtd_info *mtd = &host->mtd;
drivers/mtd/nand/socrates_nand.c:	iounmap(host->io_base);
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h: * Global Receive Side Scaling (RSS) parameters in host-native format.
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h: * Virtual Interface RSS Configuration in host-native format.
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c: *	@config: pointer to host-native VI RSS Configuration buffer
drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c: *	@config: pointer to host-native VI RSS Configuration buffer
drivers/net/ethernet/qlogic/netxen/netxen_nic.h: * NetXen host-peg signal message structure
drivers/net/ethernet/sfc/txc43128_phy.c:	 * PCS or the PHYXS and the result is a reset of both host- and
drivers/net/ethernet/smsc/epic100.c: * really ARE host-endian; it's not a misannotation.  We tell
drivers/net/ethernet/tehuti/tehuti.c: * create TX/RX descriptor fifo for host-NIC communication.
drivers/net/fddi/defxx.c: *		acknowledging any host-based interrupt chips.
drivers/net/fddi/defxx.h: *  certain host-sent SMT frames such as PMF Get and Set requests.  The
drivers/net/fddi/skfp/h/supern_2.h:#define	FM_ENHSRQ	0x0100		/* enable-host-request bit */
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable,
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable based
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable
drivers/net/usb/Kconfig:	  Note that while many USB host-to-host cables can work in this mode,
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable
drivers/net/usb/Kconfig:	boolean "eTEK based host-to-host cables (Advance, Belkin, ...)"
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable
drivers/net/usb/Kconfig:	  Choose this option if you're using a host-to-host cable
drivers/net/usb/cdc_eem.c:			 * Hosts should never receive host-to-peripheral
drivers/net/usb/cdc_subset.c: * of "host-to-host" USB cables (which embed two devices back-to-back).
drivers/net/usb/cdc_subset.c: * Note that although Linux may use many of those host-to-host links
drivers/net/usb/cdc_subset.c: * peers at the other end of host-to-host cables may expect their own
drivers/net/usb/net1080.c: * Net1080 based USB host-to-host cables
drivers/net/usb/plusb.c: * PL-2301/2302 USB host-to-host link cables
drivers/net/usb/usbnet.c: * kinds of full and high speed networking devices:  host-to-host cables,
drivers/net/wimax/i2400m/i2400m.h: *  - HDI (host-device interface) definitions common to all busses
drivers/net/wimax/i2400m/i2400m.h: *     only allow one at a time, per host-device interface design).
drivers/net/wimax/i2400m/sdio.c: * really provide and certain arches/host-controller combinations
drivers/net/wireless/ath/ath6kl/sdio.c:	if (ar_sdio->func->card->host->max_segs < MAX_SCATTER_ENTRIES_PER_REQ) {
drivers/net/wireless/ath/ath6kl/sdio.c:			   ar_sdio->func->card->host->max_segs,
drivers/net/wireless/bcmdhd/bcmsdh_linux.c:/* Module parameters specific to each host-controller driver */
drivers/net/wireless/bcmdhd/dhd.h:	b[9  ] - 1 = packet is host->firmware (transmit direction)
drivers/net/wireless/bcmdhd/dhd_common.c:	 * byte order. Convert all members to host-order.
drivers/net/wireless/bcmdhd/include/bcmcdc.h:#define BDC_FLAG_SUM_NEEDED	0x08	/* Dongle needs to do TX checksums: host->device */
drivers/net/wireless/bcmdhd/include/wlfc_proto.h:	|  5   |   4  | see pkttag comments      | PKKTTAG [host->firmware]
drivers/net/wireless/bcmdhd/include/wlfc_proto.h:	|      |      |                          | [host->firmware]
drivers/net/wireless/bcmdhd_4335/wl_android.c:			clk_disable(host->clk);
drivers/net/wireless/bcmdhd_4335/wl_android.c:			if (host->pclk)
drivers/net/wireless/bcmdhd_4335/wl_android.c:				clk_disable(host->pclk);
drivers/net/wireless/bcmdhd_4335/wl_android.c:			if (host->bus_clk)
drivers/net/wireless/bcmdhd_4335/wl_android.c:				clk_disable(host->bus_clk);
drivers/net/wireless/bcmdhd_4335/wl_android.c:			atomic_set(&host->clks_on, 0);
drivers/net/wireless/hostap/hostap_ap.c:/* Update station info for host-based TX rate control and return current
drivers/net/wireless/hostap/hostap_ap.c:	/* Set tx_rate if using host-based TX rate control */
drivers/net/wireless/hostap/hostap_hw.c:		printk(KERN_DEBUG "%s: defaulting to host-based encryption as "
drivers/net/wireless/hostap/hostap_hw.c:		 * passive scanning when a host-generated frame is being
drivers/net/wireless/hostap/hostap_ioctl.c:		printk(KERN_DEBUG "%s: defaulting to host-based encryption as "
drivers/net/wireless/hostap/hostap_ioctl.c:	 * host-based and then setup scanrequest data and return the mode to
drivers/net/wireless/hostap/hostap_ioctl.c:		 * require host-based encryption, so force them on
drivers/net/wireless/hostap/hostap_ioctl.c:	 * host-based encryption, so force them on automatically */
drivers/net/wireless/iwlegacy/4965.h: * 4965 has 16 base pointer registers, one for each of 16 host-DRAM-resident
drivers/net/wireless/iwlwifi/iwl-fh.h: * Device has 16 base pointer registers, one for each of 16 host-DRAM-resident
drivers/net/wireless/libertas/if_sdio.c:	    (host->caps & MMC_CAP_SDIO_IRQ) &&
drivers/net/wireless/libertas/if_sdio.c:	    (host->ios.bus_width == MMC_BUS_WIDTH_1)) {
drivers/net/wireless/wl1251/acx.h:	/* the amount of wake on host-access times */
drivers/net/wireless/wl12xx/acx.h:	/* the amount of wake on host-access times */
drivers/net/wireless/wl12xx/main.c:	/* update the host-chipset time offset */
drivers/net/wireless/zd1211rw/zd_chip.h:/*             bit 7: host-controlled RF register writes
drivers/parport/parport_ip32.c: * parport_ip32_data_forward - enable host-to-peripheral communications
drivers/parport/parport_ip32.c: * Enable the data line drivers, for 8-bit host-to-peripheral communications.
drivers/pci/hotplug/acpiphp_glue.c:		dbg("found PCI host-bus bridge with hot-pluggable slots\n");
drivers/rapidio/rio-scan.c: * rio_enum_host- Set host lock and initialize host destination ID
drivers/s390/scsi/zfcp_dbf.c:		(struct zfcp_adapter *) sc->device->host->hostdata[0];
drivers/s390/scsi/zfcp_dbf.h:					scmd->device->host->hostdata[0];
drivers/s390/scsi/zfcp_fc.c:	adapter = (struct zfcp_adapter *) job->shost->hostdata[0];
drivers/s390/scsi/zfcp_fc.c:	adapter = (struct zfcp_adapter *)shost->hostdata[0];
drivers/s390/scsi/zfcp_qdio.c:		adapter->scsi_host->sg_tablesize = qdio->max_sbale_per_req;
drivers/s390/scsi/zfcp_qdio.c:		adapter->scsi_host->max_sectors = qdio->max_sbale_per_req * 8;
drivers/s390/scsi/zfcp_scsi.c:		(struct zfcp_adapter *) sdev->host->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:		(struct zfcp_adapter *) scsi_host->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->max_id = 511;
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->max_lun = 0xFFFFFFFF;
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->max_channel = 0;
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->unique_id = dev_id.devno;
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->max_cmd_len = 16; /* in struct fcp_cmnd */
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->transportt = zfcp_scsi_transport_template;
drivers/s390/scsi/zfcp_scsi.c:	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
drivers/s390/scsi/zfcp_scsi.c:	adapter = (struct zfcp_adapter *)host->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:	adapter = (struct zfcp_adapter *)shost->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:		(struct zfcp_adapter *)shost->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:		(struct zfcp_adapter *)shost->hostdata[0];
drivers/s390/scsi/zfcp_scsi.c:		shost->sg_prot_tablesize = adapter->qdio->max_sbale_per_req / 2;
drivers/s390/scsi/zfcp_scsi.c:		shost->sg_tablesize = adapter->qdio->max_sbale_per_req / 2;
drivers/s390/scsi/zfcp_scsi.c:		shost->max_sectors = shost->sg_tablesize * 8;
drivers/s390/scsi/zfcp_sysfs.c:	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
drivers/s390/scsi/zfcp_sysfs.c:	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
drivers/s390/scsi/zfcp_sysfs.c:		((struct zfcp_adapter *) scsi_host->hostdata[0])->qdio;
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:		sprintf(host, " scsi%d:", tw_dev->host->host_no);
drivers/scsi/3w-9xxx.c:		spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:		spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:			       tw_dev->host->host_no, TW_DRIVER, 0x37,
drivers/scsi/3w-9xxx.c:		spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:		spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:			       tw_dev->host->host_no,
drivers/scsi/3w-9xxx.c:	spin_lock(tw_dev->host->host_lock);
drivers/scsi/3w-9xxx.c:	spin_unlock(tw_dev->host->host_lock);
drivers/scsi/3w-9xxx.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-9xxx.c:	tw_dev = (TW_Device_Extension *)sdev->host->hostdata;
drivers/scsi/3w-9xxx.c:	tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-9xxx.c:	printk(KERN_WARNING "3w-9xxx: Shutting down host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:	tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:		host->max_id = TW_MAX_UNITS_9650SE;
drivers/scsi/3w-9xxx.c:		host->max_id = TW_MAX_UNITS;
drivers/scsi/3w-9xxx.c:	host->max_cmd_len = TW_MAX_CDB_LEN;
drivers/scsi/3w-9xxx.c:	host->max_lun = TW_MAX_LUNS(tw_dev->tw_compat_info.working_srl);
drivers/scsi/3w-9xxx.c:	host->max_channel = 0;
drivers/scsi/3w-9xxx.c:	       host->host_no, mem_addr, pdev->irq);
drivers/scsi/3w-9xxx.c:	       host->host_no,
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:	printk(KERN_WARNING "3w-9xxx: Suspending host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-9xxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-9xxx.c:	printk(KERN_WARNING "3w-9xxx: Resuming host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;
drivers/scsi/3w-sas.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;
drivers/scsi/3w-sas.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-sas.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:		sprintf(host, " scsi%d:", tw_dev->host->host_no);
drivers/scsi/3w-sas.c:		spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:		spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:			       tw_dev->host->host_no, TW_DRIVER, 0x6,
drivers/scsi/3w-sas.c:		spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:		spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:			       tw_dev->host->host_no,
drivers/scsi/3w-sas.c:	spin_lock(tw_dev->host->host_lock);
drivers/scsi/3w-sas.c:	spin_unlock(tw_dev->host->host_lock);
drivers/scsi/3w-sas.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-sas.c:	tw_dev = (TW_Device_Extension *)sdev->host->hostdata;
drivers/scsi/3w-sas.c:	tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-sas.c:	printk(KERN_WARNING "3w-sas: Shutting down host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-sas.c:	tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-sas.c:	host->max_id = TW_MAX_UNITS;
drivers/scsi/3w-sas.c:	host->max_cmd_len = TW_MAX_CDB_LEN;
drivers/scsi/3w-sas.c:	host->max_lun = TW_MAX_LUNS;
drivers/scsi/3w-sas.c:	host->max_channel = 0;
drivers/scsi/3w-sas.c:	       host->host_no,
drivers/scsi/3w-sas.c:	       host->host_no,
drivers/scsi/3w-sas.c:	if (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr))
drivers/scsi/3w-sas.c:	if (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr))
drivers/scsi/3w-sas.c:	tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-sas.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr);
drivers/scsi/3w-sas.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr);
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-sas.c:	printk(KERN_WARNING "3w-sas: Suspending host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-sas.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-sas.c:	printk(KERN_WARNING "3w-sas: Resuming host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:                 Set tw_host->max_id for 12 port cards.
drivers/scsi/3w-xxxx.c:   1.02.00.016 - Set host->max_sectors back up to 256.
drivers/scsi/3w-xxxx.c:		sprintf(host, " scsi%d:", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	printk(KERN_WARNING "3w-xxxx: scsi%d: Command failed: status = 0x%x, flags = 0x%x, unit #%d.\n", tw_dev->host->host_no, command->status, command->flags, TW_UNIT_OUT(command->unit__hostid));
drivers/scsi/3w-xxxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-xxxx.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:		printk(KERN_WARNING "3w-xxxx: scsi%d: AEN: INFO: AEN queue overflow.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:				printk(KERN_WARNING "3w-xxxx: scsi%d: AEN: %s%d.\n", tw_dev->host->host_no, tw_aen_string[aen & 0xff], aen >> 8);
drivers/scsi/3w-xxxx.c:					printk(KERN_WARNING "3w-xxxx: scsi%d: AEN: %s.\n", tw_dev->host->host_no, tw_aen_string[aen & 0xff]);
drivers/scsi/3w-xxxx.c:			printk(KERN_WARNING "3w-xxxx: scsi%d: Received AEN %d.\n", tw_dev->host->host_no, aen);
drivers/scsi/3w-xxxx.c:			printk(KERN_WARNING "3w-xxxx: scsi%d: Error completing AEN.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:			spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:			spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:			spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:			spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:				printk(KERN_WARNING "3w-xxxx: scsi%d: Character ioctl (0x%x) timed out, resetting card.\n", tw_dev->host->host_no, cmd);
drivers/scsi/3w-xxxx.c:					printk(KERN_WARNING "3w-xxxx: tw_chrdev_ioctl(): Reset failed for card %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:			spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:			spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:			printk(KERN_WARNING "3w-xxxx: scsi%d: AEN drain failed, retrying.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:			printk(KERN_WARNING "3w-xxxx: scsi%d: Controller errors found, retrying.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:		printk(KERN_WARNING "3w-xxxx: scsi%d: Controller errors, card not responding, check all cabling.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:		printk(KERN_WARNING "3w-xxxx: scsi%d: Connection initialization failed.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	spin_lock_irqsave(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:	spin_unlock_irqrestore(tw_dev->host->host_lock, flags);
drivers/scsi/3w-xxxx.c:		printk(KERN_WARNING "3w-xxxx: scsi%d: Reset sequence failed.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	tw_dev = (TW_Device_Extension *)sdev->host->hostdata;
drivers/scsi/3w-xxxx.c:	tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-xxxx.c:		printk(KERN_WARNING "3w-xxxx: scsi%d: Reset failed.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;
drivers/scsi/3w-xxxx.c:			printk(KERN_NOTICE "3w-xxxx: scsi%d: Unknown scsi opcode: 0x%x\n", tw_dev->host->host_no, *command);
drivers/scsi/3w-xxxx.c:	spin_lock(tw_dev->host->host_lock);
drivers/scsi/3w-xxxx.c:			printk(KERN_WARNING "3w-xxxx: scsi%d: Error reading aen queue.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:				printk(KERN_WARNING "3w-xxxx: scsi%d: Found request id that wasn't pending.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:					printk(KERN_WARNING "3w-xxxx: scsi%d: Received a request id that wasn't posted.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:						printk(KERN_WARNING "3w-xxxx: scsi%d: Error completing aen.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	spin_unlock(tw_dev->host->host_lock);
drivers/scsi/3w-xxxx.c:	printk(KERN_WARNING "3w-xxxx: Shutting down host %d.\n", tw_dev->host->host_no);
drivers/scsi/3w-xxxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-xxxx.c:	tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/3w-xxxx.c:	host->max_id = TW_MAX_UNITS;
drivers/scsi/3w-xxxx.c:	host->max_cmd_len = TW_MAX_CDB_LEN;
drivers/scsi/3w-xxxx.c:	host->max_lun = 0;
drivers/scsi/3w-xxxx.c:	host->max_channel = 0;
drivers/scsi/3w-xxxx.c:	printk(KERN_WARNING "3w-xxxx: scsi%d: Found a 3ware Storage Controller at 0x%x, IRQ: %d.\n", host->host_no, tw_dev->base_addr, pdev->irq);
drivers/scsi/3w-xxxx.c:	TW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];
drivers/scsi/53c700.c:	host->max_id = 8;
drivers/scsi/53c700.c:	host->max_lun = NCR_700_MAX_LUNS;
drivers/scsi/53c700.c:	host->transportt = NCR_700_transport_template;
drivers/scsi/53c700.c:	host->unique_id = (unsigned long)hostdata->base;
drivers/scsi/53c700.c:	host->hostdata[0] = (unsigned long)hostdata;
drivers/scsi/53c700.c:	printk(KERN_NOTICE "scsi%d: %s rev %d %s\n", host->host_no,
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:	NCR_700_writeb(1 << host->this_id, host, SCID_REG);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		       host->host_no, pun, lun);
drivers/scsi/53c700.c:		       host->host_no, pun, lun,
drivers/scsi/53c700.c:	printk("scsi%d (%d:%d): message %s: ", host->host_no, pun, lun,
drivers/scsi/53c700.c:			scsi_deactivate_tcq(SCp->device, host->cmd_per_lun);
drivers/scsi/53c700.c:		printk(KERN_ERR "scsi%d (%d:%d) Parity Error!\n", host->host_no,
drivers/scsi/53c700.c:		printk(KERN_INFO "scsi%d (%d:%d) SIMPLE TAG %d %s\n", host->host_no,
drivers/scsi/53c700.c:		       host->host_no, pun, lun,
drivers/scsi/53c700.c:		       host->host_no, pun, lun, NCR_700_fatal_messages[i]);
drivers/scsi/53c700.c:		       host->host_no, pun, lun,
drivers/scsi/53c700.c:		       host->host_no, reselection_id, lun));
drivers/scsi/53c700.c:			       host->host_no, reselection_id, lun);
drivers/scsi/53c700.c:				       host->host_no, reselection_id, lun, hostdata->msgin[2]);
drivers/scsi/53c700.c:			       host->host_no, reselection_id, lun,
drivers/scsi/53c700.c:				       host->host_no);
drivers/scsi/53c700.c:		reselection_id &= ~(1<<host->this_id);
drivers/scsi/53c700.c:		       host->host_no, reselection_id, lun, dsp, dsp - hostdata->pScript, hostdata->state, hostdata->command_slot_count);
drivers/scsi/53c700.c:				printk(KERN_ERR "scsi%d: Invalid reselection during selection!!\n", host->host_no);
drivers/scsi/53c700.c:				       host->host_no);
drivers/scsi/53c700.c:		       host->host_no, pun, lun, NCR_700_condition[i],
drivers/scsi/53c700.c:		       host->host_no, pun, lun, dsps & 0xfff, dsp, dsp - hostdata->pScript);
drivers/scsi/53c700.c:		       host->host_no, pun, lun, dsps, dsp - hostdata->pScript);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		id &= ~(1<<host->this_id);
drivers/scsi/53c700.c:		       host->host_no, id));
drivers/scsi/53c700.c:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];
drivers/scsi/53c700.c:		       SCp->device->host->host_no, slot->cmnd, slot));
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/53c700.c:		       host->host_no, istat, sstat0, dstat,
drivers/scsi/53c700.c:			       host->host_no, SCp, SCp == NULL ? NULL : SCp->host_scribble, dsp, dsp - hostdata->pScript);
drivers/scsi/53c700.c:			       host->host_no, pun, lun));
drivers/scsi/53c700.c:				printk("scsi%d (%d:%d) PHASE MISMATCH IN SEND MESSAGE %d remain, return %p[%04x], phase %s\n", host->host_no, pun, lun, count, (void *)temp, temp - hostdata->pScript, sbcl_to_string(NCR_700_readb(host, SBCL_REG)));
drivers/scsi/53c700.c:				       host->host_no, pun, lun,
drivers/scsi/53c700.c:				       host->host_no, pun, lun,
drivers/scsi/53c700.c:						printk("scsi%d (%d:%d) transfer mismatch pAddr=%lx, naddr=%lx, data_transfer=%d, residual=%d\n", host->host_no, pun, lun, (unsigned long)pAddr, (unsigned long)naddr, data_transfer, residual);
drivers/scsi/53c700.c:				       host->host_no, pun, lun, dsp - hostdata->pScript, sbcl_to_string(sbcl));
drivers/scsi/53c700.c:			       host->host_no, pun, lun);
drivers/scsi/53c700.c:			       host->host_no, pun, lun);
drivers/scsi/53c700.c:			       host->host_no, pun, lun));
drivers/scsi/53c700.c:			       host->host_no, pun, lun,
drivers/scsi/53c700.c:			       host->host_no, pun, lun, dstat);
drivers/scsi/53c700.c:			       host->host_no, resume_offset, resume_offset - hostdata->pScript);
drivers/scsi/53c700.c:				       host->host_no, &hostdata->slots[j],
drivers/scsi/53c700.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];
drivers/scsi/53c700.c:		printk(KERN_WARNING "scsi%d: Command depth has gone over queue depth\n", SCp->device->host->host_no);
drivers/scsi/53c700.c:	printk("53c700: scsi%d, command ", SCp->device->host->host_no);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];
drivers/scsi/53c700.c:	spin_lock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:		spin_unlock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:		spin_lock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:	spin_unlock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:	spin_lock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:	spin_unlock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:	spin_lock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:	spin_unlock_irq(SCp->device->host->host_lock);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];
drivers/scsi/53c700.c:		scsi_adjust_queue_depth(SDp, 0, SDp->host->cmd_per_lun);
drivers/scsi/53c700.c:		(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];
drivers/scsi/53c700.c:		scsi_deactivate_tcq(SDp, SDp->host->cmd_per_lun);
drivers/scsi/53c700.h:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.h:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.h:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/53c700.h:		= (struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Device->host->hostdata;
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) SCpnt->device->host->hostdata;
drivers/scsi/BusLogic.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/BusLogic.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Command->device->host->hostdata;
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Command->device->host->hostdata;
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) sdev->host->hostdata;
drivers/scsi/BusLogic.c:	struct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) shost->hostdata;
drivers/scsi/NCR5380.c:	SPRINTF("scsi%d : destination target %d, lun %d\n", cmd->device->host->host_no, cmd->device->id, cmd->device->lun);
drivers/scsi/NCR53c406a.c:	if (shost->irq)
drivers/scsi/NCR53c406a.c:		free_irq(shost->irq, NULL);
drivers/scsi/NCR53c406a.c:	if (shost->dma_channel != 0xff)
drivers/scsi/NCR53c406a.c:		free_dma(shost->dma_channel);
drivers/scsi/NCR53c406a.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/NCR53c406a.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/NCR53c406a.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/NCR53c406a.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/NCR_D700.c:	host->this_id = id_array[slot * 2 + siop];
drivers/scsi/NCR_D700.c:	host->irq = irq;
drivers/scsi/NCR_D700.c:	host->base = region;
drivers/scsi/NCR_D700.c:	kfree((struct NCR_700_Host_Parameters *)host->hostdata[0]);
drivers/scsi/NCR_D700.c:	free_irq(host->irq, host);
drivers/scsi/NCR_D700.c:	release_region(host->base, 64);
drivers/scsi/a100u2w.c:		if (inb(host->base + ORC_HCTRL) & HOSTSTOP)	/* Wait HOSTSTOP set */
drivers/scsi/a100u2w.c:		if (inb(host->base + ORC_HSTUS) & RREADY)		/* Wait READY set */
drivers/scsi/a100u2w.c:		if (!(inb(host->base + ORC_HCTRL) & SCSIRST))	/* Wait SCSIRST done */
drivers/scsi/a100u2w.c:		if (!(inb(host->base + ORC_HCTRL) & HDO))		/* Wait HDO off */
drivers/scsi/a100u2w.c:		if ((*data = inb(host->base + ORC_HSTUS)) & HDI)
drivers/scsi/a100u2w.c:	outb(ORC_CMD_VERSION, host->base + ORC_HDATA);
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	version = inb(host->base + ORC_HDATA);
drivers/scsi/a100u2w.c:	outb(data, host->base + ORC_HSTUS);	/* Clear HDI            */
drivers/scsi/a100u2w.c:	version |= inb(host->base + ORC_HDATA) << 8;
drivers/scsi/a100u2w.c:	outb(data, host->base + ORC_HSTUS);	/* Clear HDI            */
drivers/scsi/a100u2w.c:	outb(ORC_CMD_SET_NVM, host->base + ORC_HDATA);	/* Write command */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	outb(address, host->base + ORC_HDATA);	/* Write address */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	outb(value, host->base + ORC_HDATA);	/* Write value  */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	outb(ORC_CMD_GET_NVM, host->base + ORC_HDATA);	/* Write command */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	outb(address, host->base + ORC_HDATA);	/* Write address */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	*ptr = inb(host->base + ORC_HDATA);
drivers/scsi/a100u2w.c:	outb(data, host->base + ORC_HSTUS);	/* Clear HDI    */
drivers/scsi/a100u2w.c:	outb(scb->scbidx, host->base + ORC_PQUEUE);
drivers/scsi/a100u2w.c:	data = inb(host->base + ORC_GCFG);
drivers/scsi/a100u2w.c:	outb(data | EEPRG, host->base + ORC_GCFG);	/* Enable EEPROM programming */
drivers/scsi/a100u2w.c:	outb(0x00, host->base + ORC_EBIOSADR2);
drivers/scsi/a100u2w.c:	outw(0x0000, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:	if (inb(host->base + ORC_EBIOSDATA) != 0x55) {
drivers/scsi/a100u2w.c:		outb(data, host->base + ORC_GCFG);	/* Disable EEPROM programming */
drivers/scsi/a100u2w.c:	outw(0x0001, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:	if (inb(host->base + ORC_EBIOSDATA) != 0xAA) {
drivers/scsi/a100u2w.c:		outb(data, host->base + ORC_GCFG);	/* Disable EEPROM programming */
drivers/scsi/a100u2w.c:	outb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);	/* Enable SRAM programming */
drivers/scsi/a100u2w.c:	outw(0x0010, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:	*data32_ptr = inb(host->base + ORC_EBIOSDATA);		/* Read from BIOS */
drivers/scsi/a100u2w.c:	outw(0x0011, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:	*(data32_ptr + 1) = inb(host->base + ORC_EBIOSDATA);	/* Read from BIOS */
drivers/scsi/a100u2w.c:	outw(0x0012, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:	*(data32_ptr + 2) = inb(host->base + ORC_EBIOSDATA);	/* Read from BIOS */
drivers/scsi/a100u2w.c:	outw(*(data32_ptr + 2), host->base + ORC_EBIOSADR2);
drivers/scsi/a100u2w.c:	outl(le32_to_cpu(data32), host->base + ORC_FWBASEADR);		/* Write FW address */
drivers/scsi/a100u2w.c:		outw(bios_addr, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:		*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);	/* Read from BIOS */
drivers/scsi/a100u2w.c:			outl(le32_to_cpu(data32), host->base + ORC_RISCRAM);	/* Write every 4 bytes */
drivers/scsi/a100u2w.c:	outb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);	/* Reset program count 0 */
drivers/scsi/a100u2w.c:		outw(bios_addr, host->base + ORC_EBIOSADR0);
drivers/scsi/a100u2w.c:		*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);	/* Read from BIOS */
drivers/scsi/a100u2w.c:			if (inl(host->base + ORC_RISCRAM) != le32_to_cpu(data32)) {
drivers/scsi/a100u2w.c:				outb(PRGMRST, host->base + ORC_RISCCTL);	/* Reset program to 0 */
drivers/scsi/a100u2w.c:				outb(data, host->base + ORC_GCFG);	/*Disable EEPROM programming */
drivers/scsi/a100u2w.c:	outb(PRGMRST, host->base + ORC_RISCCTL);	/* Reset program to 0   */
drivers/scsi/a100u2w.c:	outb(data, host->base + ORC_GCFG);	/* Disable EEPROM programming */
drivers/scsi/a100u2w.c:	outb(ORC_MAXQUEUE, host->base + ORC_SCBSIZE);	/* Total number of SCBs */
drivers/scsi/a100u2w.c:	outl(host->scb_phys, host->base + ORC_SCBBASE0);
drivers/scsi/a100u2w.c:	outl(host->scb_phys, host->base + ORC_SCBBASE1);
drivers/scsi/a100u2w.c:	scb = host->scb_virt;
drivers/scsi/a100u2w.c:	escb = host->escb_virt;
drivers/scsi/a100u2w.c:		escb_phys = (host->escb_phys + (sizeof(struct orc_extended_scb) * i));
drivers/scsi/a100u2w.c:			host->allocation_map[i][j] = 0xffffffff;
drivers/scsi/a100u2w.c:	outb(0xFF, host->base + ORC_GIMSK);	/* Disable all interrupts */
drivers/scsi/a100u2w.c:	if (inb(host->base + ORC_HSTUS) & RREADY) {	/* Orchid is ready */
drivers/scsi/a100u2w.c:			outb(DEVRST, host->base + ORC_HCTRL);	/* Reset Host Adapter   */
drivers/scsi/a100u2w.c:			outb(0x00, host->base + ORC_HCTRL);	/* clear HOSTSTOP       */
drivers/scsi/a100u2w.c:		outb(DEVRST, host->base + ORC_HCTRL);	/* Reset Host Adapter   */
drivers/scsi/a100u2w.c:		outb(HDO, host->base + ORC_HCTRL);	/* Do Hardware Reset &  */
drivers/scsi/a100u2w.c:	host->scsi_id = nvramp->scsi_id;
drivers/scsi/a100u2w.c:	host->BIOScfg = nvramp->BIOSConfig1;
drivers/scsi/a100u2w.c:	host->max_targets = MAX_TARGETS;
drivers/scsi/a100u2w.c:		host->target_flag[i] = *ptr;
drivers/scsi/a100u2w.c:		host->max_tags[i] = ORC_MAXTAGS;
drivers/scsi/a100u2w.c:		host->flags |= HCF_SCSI_RESET;
drivers/scsi/a100u2w.c:	outb(0xFB, host->base + ORC_GIMSK);	/* enable RP FIFO interrupt     */
drivers/scsi/a100u2w.c:	spin_lock_irqsave(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	outb(SCSIRST, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:		spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:		spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	spin_lock_irqsave(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:	host_scb = host->scb_virt;
drivers/scsi/a100u2w.c:		spin_unlock_irqrestore(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:		spin_unlock_irqrestore(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:	spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	channel = host->index;
drivers/scsi/a100u2w.c:			if ((host->allocation_map[channel][i] >> index) & 0x01) {
drivers/scsi/a100u2w.c:				host->allocation_map[channel][i] &= ~(1 << index);
drivers/scsi/a100u2w.c:				return host->scb_virt + idx;
drivers/scsi/a100u2w.c:	spin_lock_irqsave(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	spin_lock_irqsave(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:	channel = host->index;	/* Channel */
drivers/scsi/a100u2w.c:	host->allocation_map[channel][i] |= (1 << index);
drivers/scsi/a100u2w.c:	spin_unlock_irqrestore(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:	outb(ORC_CMD_ABORT_SCB, host->base + ORC_HDATA);	/* Write command */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	outb(scb->scbidx, host->base + ORC_HDATA);	/* Write address */
drivers/scsi/a100u2w.c:	outb(HDO, host->base + ORC_HCTRL);
drivers/scsi/a100u2w.c:	status = inb(host->base + ORC_HDATA);
drivers/scsi/a100u2w.c:	outb(data, host->base + ORC_HSTUS);	/* Clear HDI    */
drivers/scsi/a100u2w.c:	spin_lock_irqsave(&(host->allocation_lock), flags);
drivers/scsi/a100u2w.c:	scb = host->scb_virt;
drivers/scsi/a100u2w.c:					spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	spin_unlock_irqrestore(&host->allocation_lock, flags);
drivers/scsi/a100u2w.c:	if (inb(host->base + ORC_RQUEUECNT) == 0)
drivers/scsi/a100u2w.c:		scb_index = inb(host->base + ORC_RQUEUE);
drivers/scsi/a100u2w.c:		scb = (struct orc_scb *) ((unsigned long) host->scb_virt + (unsigned long) (sizeof(struct orc_scb) * scb_index));
drivers/scsi/a100u2w.c:	} while (inb(host->base + ORC_RQUEUECNT));
drivers/scsi/a100u2w.c:	host = (struct orc_host *) cmd->device->host->hostdata;
drivers/scsi/a100u2w.c:	host = (struct orc_host *) cmd->device->host->hostdata;
drivers/scsi/a100u2w.c:	host = (struct orc_host *) cmd->device->host->hostdata;
drivers/scsi/a100u2w.c:	host = (struct orc_host *) cmd->device->host->hostdata;
drivers/scsi/a100u2w.c:	struct orc_host *host = (struct orc_host *)shost->hostdata;
drivers/scsi/a100u2w.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/a100u2w.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/a100u2w.c:	host = (struct orc_host *)shost->hostdata;
drivers/scsi/a100u2w.c:	host->pdev = pdev;
drivers/scsi/a100u2w.c:	host->base = port;
drivers/scsi/a100u2w.c:	host->BIOScfg = bios;
drivers/scsi/a100u2w.c:	spin_lock_init(&host->allocation_lock);
drivers/scsi/a100u2w.c:	host->scb_virt = pci_alloc_consistent(pdev, sz,
drivers/scsi/a100u2w.c:			&host->scb_phys);
drivers/scsi/a100u2w.c:	if (!host->scb_virt) {
drivers/scsi/a100u2w.c:	memset(host->scb_virt, 0, sz);
drivers/scsi/a100u2w.c:	host->escb_virt = pci_alloc_consistent(pdev, sz,
drivers/scsi/a100u2w.c:			&host->escb_phys);
drivers/scsi/a100u2w.c:	if (!host->escb_virt) {
drivers/scsi/a100u2w.c:	memset(host->escb_virt, 0, sz);
drivers/scsi/a100u2w.c:	biosaddr = host->BIOScfg;
drivers/scsi/a100u2w.c:	shost->io_port = host->base;
drivers/scsi/a100u2w.c:	shost->n_io_port = 0xff;
drivers/scsi/a100u2w.c:	shost->can_queue = ORC_MAXQUEUE;
drivers/scsi/a100u2w.c:	shost->unique_id = shost->io_port;
drivers/scsi/a100u2w.c:	shost->max_id = host->max_targets;
drivers/scsi/a100u2w.c:	shost->max_lun = 16;
drivers/scsi/a100u2w.c:	shost->irq = pdev->irq;
drivers/scsi/a100u2w.c:	shost->this_id = host->scsi_id;	/* Assign HCS index */
drivers/scsi/a100u2w.c:	shost->sg_tablesize = TOTAL_SG_ENTRY;
drivers/scsi/a100u2w.c:        free_irq(shost->irq, shost);
drivers/scsi/a100u2w.c:			host->escb_virt, host->escb_phys);
drivers/scsi/a100u2w.c:			host->scb_virt, host->scb_phys);
drivers/scsi/a100u2w.c:	struct orc_host *host = (struct orc_host *)shost->hostdata;
drivers/scsi/a100u2w.c:        free_irq(shost->irq, shost);
drivers/scsi/a100u2w.c:			host->escb_virt, host->escb_phys);
drivers/scsi/a100u2w.c:			host->scb_virt, host->scb_phys);
drivers/scsi/a100u2w.c:        release_region(shost->io_port, 256);
drivers/scsi/a4000t.c:	host->this_id = 7;
drivers/scsi/a4000t.c:	host->base = scsi_addr;
drivers/scsi/a4000t.c:	host->irq = IRQ_AMIGA_PORTS;
drivers/scsi/a4000t.c:	if (request_irq(host->irq, NCR_700_intr, IRQF_SHARED, "a4000t-scsi",
drivers/scsi/a4000t.c:	free_irq(host->irq, host);
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	struct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;
drivers/scsi/aacraid/aachba.c:	if ((fibptr = aac_fib_alloc((struct aac_dev *)scsicmd->device->host->hostdata))) {
drivers/scsi/aacraid/aachba.c:		struct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	aac = (struct aac_dev *)sdev->host->hostdata;
drivers/scsi/aacraid/aachba.c:	struct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;
drivers/scsi/aacraid/aachba.c:	struct aac_dev *dev = (struct aac_dev *)host->hostdata;
drivers/scsi/aacraid/aachba.c:	if (cid != host->this_id) {
drivers/scsi/aacraid/aachba.c:			arr[0] = (scmd_id(scsicmd) == host->this_id) ?
drivers/scsi/aacraid/aachba.c:		if (cid == host->this_id) {
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aachba.c:	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
drivers/scsi/aacraid/aacraid.h:#define shost_to_class(shost) &shost->shost_dev
drivers/scsi/aacraid/comminit.c:	dev->sg_tablesize = host->sg_tablesize = (dev->max_fib_size
drivers/scsi/aacraid/comminit.c:		host->max_sectors = (status[1] >> 16) << 1;
drivers/scsi/aacraid/comminit.c:		host->sg_tablesize = status[2] >> 16;
drivers/scsi/aacraid/comminit.c:		host->can_queue = (status[3] & 0xFFFF) - AAC_NUM_MGT_FIB;
drivers/scsi/aacraid/comminit.c:			host->max_sectors = AAC_MAX_32BIT_SGBCOUNT;
drivers/scsi/aacraid/comminit.c:			dev->sg_tablesize = host->sg_tablesize
drivers/scsi/aacraid/comminit.c:			host->can_queue = AAC_NUM_IO_FIB;
drivers/scsi/aacraid/comminit.c:			host->max_sectors = 512;
drivers/scsi/aacraid/comminit.c:			host->sg_tablesize = 65;
drivers/scsi/aacraid/comminit.c:			host->can_queue = 512 - AAC_NUM_MGT_FIB;
drivers/scsi/aacraid/comminit.c:			host->max_sectors = 1024;
drivers/scsi/aacraid/comminit.c:			host->sg_tablesize = 129;
drivers/scsi/aacraid/comminit.c:			host->can_queue = 256 - AAC_NUM_MGT_FIB;
drivers/scsi/aacraid/comminit.c:			host->max_sectors = 2048;
drivers/scsi/aacraid/comminit.c:			host->sg_tablesize = 257;
drivers/scsi/aacraid/comminit.c:			host->can_queue = 128 - AAC_NUM_MGT_FIB;
drivers/scsi/aacraid/comminit.c:			if (numacb < host->can_queue)
drivers/scsi/aacraid/comminit.c:				host->can_queue = numacb;
drivers/scsi/aacraid/commsup.c:		spin_unlock_irq(host->host_lock);
drivers/scsi/aacraid/commsup.c:	if ((quirks & AAC_QUIRK_34SG) && (host->sg_tablesize > 34)) {
drivers/scsi/aacraid/commsup.c:		host->sg_tablesize = 34;
drivers/scsi/aacraid/commsup.c:		host->max_sectors = (host->sg_tablesize * 8) + 112;
drivers/scsi/aacraid/commsup.c:	if ((quirks & AAC_QUIRK_17SG) && (host->sg_tablesize > 17)) {
drivers/scsi/aacraid/commsup.c:		host->sg_tablesize = 17;
drivers/scsi/aacraid/commsup.c:		host->max_sectors = (host->sg_tablesize * 8) + 112;
drivers/scsi/aacraid/commsup.c:		spin_lock_irq(host->host_lock);
drivers/scsi/aacraid/commsup.c:	spin_lock_irqsave(host->host_lock, flagv);
drivers/scsi/aacraid/commsup.c:	spin_unlock_irqrestore(host->host_lock, flagv);
drivers/scsi/aacraid/commsup.c:		spin_lock_irqsave(host->host_lock, flagv);
drivers/scsi/aacraid/commsup.c:		spin_unlock_irqrestore(host->host_lock, flagv);
drivers/scsi/aacraid/linit.c:	struct aac_dev *dev = (struct aac_dev *)host->hostdata;
drivers/scsi/aacraid/linit.c:	for (; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
drivers/scsi/aacraid/linit.c:	struct aac_dev *dev = (struct aac_dev *)shost->hostdata;
drivers/scsi/aacraid/linit.c:	struct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;
drivers/scsi/aacraid/linit.c:		depth = (host->can_queue - num_one) / num_lsu;
drivers/scsi/aacraid/linit.c:		if (num >= host->can_queue)
drivers/scsi/aacraid/linit.c:			num = host->can_queue - 1;
drivers/scsi/aacraid/linit.c:		if (depth > (host->can_queue - num))
drivers/scsi/aacraid/linit.c:			depth = host->can_queue - num;
drivers/scsi/aacraid/linit.c:	struct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);
drivers/scsi/aacraid/linit.c:	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
drivers/scsi/aacraid/linit.c:	struct aac_dev * aac = (struct aac_dev *)host->hostdata;
drivers/scsi/aacraid/linit.c:		host->host_no, sdev_channel(dev), sdev_id(dev), dev->lun);
drivers/scsi/aacraid/linit.c:		for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
drivers/scsi/aacraid/linit.c:		for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
drivers/scsi/aacraid/linit.c:	struct aac_dev * aac = (struct aac_dev *)host->hostdata;
drivers/scsi/aacraid/linit.c:	for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
drivers/scsi/aacraid/linit.c:	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
drivers/scsi/aacraid/linit.c:	shost->irq = pdev->irq;
drivers/scsi/aacraid/linit.c:	shost->base = pci_resource_start(pdev, 0);
drivers/scsi/aacraid/linit.c:	shost->unique_id = unique_id;
drivers/scsi/aacraid/linit.c:	shost->max_cmd_len = 16;
drivers/scsi/aacraid/linit.c:	aac = (struct aac_dev *)shost->hostdata;
drivers/scsi/aacraid/linit.c:	aac->id = shost->unique_id;
drivers/scsi/aacraid/linit.c:	aac->fibs = kmalloc(sizeof(struct fib) * (shost->can_queue + AAC_NUM_MGT_FIB), GFP_KERNEL);
drivers/scsi/aacraid/linit.c:			(shost->sg_tablesize > 34)) {
drivers/scsi/aacraid/linit.c:		shost->sg_tablesize = 34;
drivers/scsi/aacraid/linit.c:		shost->max_sectors = (shost->sg_tablesize * 8) + 112;
drivers/scsi/aacraid/linit.c:			(shost->sg_tablesize > 17)) {
drivers/scsi/aacraid/linit.c:		shost->sg_tablesize = 17;
drivers/scsi/aacraid/linit.c:		shost->max_sectors = (shost->sg_tablesize * 8) + 112;
drivers/scsi/aacraid/linit.c:			(shost->max_sectors << 9) : 65536);
drivers/scsi/aacraid/linit.c:		shost->max_channel = aac->maximum_num_channels;
drivers/scsi/aacraid/linit.c:		shost->max_channel = 0;
drivers/scsi/aacraid/linit.c:	shost->max_id = aac->maximum_num_containers;
drivers/scsi/aacraid/linit.c:	if (shost->max_id < aac->maximum_num_physicals)
drivers/scsi/aacraid/linit.c:		shost->max_id = aac->maximum_num_physicals;
drivers/scsi/aacraid/linit.c:	if (shost->max_id < MAXIMUM_NUM_CONTAINERS)
drivers/scsi/aacraid/linit.c:		shost->max_id = MAXIMUM_NUM_CONTAINERS;
drivers/scsi/aacraid/linit.c:		shost->this_id = shost->max_id;
drivers/scsi/aacraid/linit.c:	shost->max_lun = AAC_MAX_LUN;
drivers/scsi/aacraid/linit.c:	__aac_shutdown((struct aac_dev *)shost->hostdata);
drivers/scsi/aacraid/linit.c:	struct aac_dev *aac = (struct aac_dev *)shost->hostdata;
drivers/scsi/advansys.c:				(ulong)shost->io_port,
drivers/scsi/advansys.c:				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
drivers/scsi/advansys.c:				boardp->irq, shost->dma_channel);
drivers/scsi/advansys.c:				ASC_VERSION, busname, (ulong)shost->io_port,
drivers/scsi/advansys.c:				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_busy, shost->last_reset, shost->max_id,
drivers/scsi/advansys.c:			   shost->max_lun, shost->max_channel);
drivers/scsi/advansys.c:			   shost->unique_id, shost->can_queue, shost->this_id,
drivers/scsi/advansys.c:			   shost->sg_tablesize, shost->cmd_per_lun);
drivers/scsi/advansys.c:			   shost->unchecked_isa_dma, shost->use_clustering);
drivers/scsi/advansys.c:	len = asc_prt_line(cp, leftlen, " io_port 0x%x\n", shost->io_port);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:			   shost->host_no);
drivers/scsi/advansys.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/advansys.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/advansys.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/advansys.c:	spin_lock(shost->host_lock);
drivers/scsi/advansys.c:		if (AscIsIntPending(shost->io_port)) {
drivers/scsi/advansys.c:	spin_unlock(shost->host_lock);
drivers/scsi/advansys.c:		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/advansys.c:		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/advansys.c:		if (use_sg > scp->device->host->sg_tablesize) {
drivers/scsi/advansys.c:				scp->device->host->sg_tablesize);
drivers/scsi/advansys.c:				   scp->device->host->sg_tablesize);
drivers/scsi/advansys.c:			shost->unchecked_isa_dma = TRUE;
drivers/scsi/advansys.c:			shost->unchecked_isa_dma = FALSE;
drivers/scsi/advansys.c:			shost->unchecked_isa_dma = FALSE;
drivers/scsi/advansys.c:			shost->unchecked_isa_dma = FALSE;
drivers/scsi/advansys.c:			shost->unchecked_isa_dma = TRUE;
drivers/scsi/advansys.c:		shost->unchecked_isa_dma = FALSE;
drivers/scsi/advansys.c:	shost->max_channel = 0;
drivers/scsi/advansys.c:		shost->max_id = ASC_MAX_TID + 1;
drivers/scsi/advansys.c:		shost->max_lun = ASC_MAX_LUN + 1;
drivers/scsi/advansys.c:		shost->max_cmd_len = ASC_MAX_CDB_LEN;
drivers/scsi/advansys.c:		shost->io_port = asc_dvc_varp->iop_base;
drivers/scsi/advansys.c:		shost->this_id = asc_dvc_varp->cfg->chip_scsi_id;
drivers/scsi/advansys.c:		shost->can_queue = asc_dvc_varp->max_total_qng;
drivers/scsi/advansys.c:		shost->max_id = ADV_MAX_TID + 1;
drivers/scsi/advansys.c:		shost->max_lun = ADV_MAX_LUN + 1;
drivers/scsi/advansys.c:		shost->max_cmd_len = ADV_MAX_CDB_LEN;
drivers/scsi/advansys.c:		shost->io_port = iop;
drivers/scsi/advansys.c:		shost->this_id = adv_dvc_varp->chip_scsi_id;
drivers/scsi/advansys.c:		shost->can_queue = adv_dvc_varp->max_host_qng;
drivers/scsi/advansys.c:	shost->cmd_per_lun = 1;
drivers/scsi/advansys.c:            shost->cmd_per_lun = 0;
drivers/scsi/advansys.c:		shost->sg_tablesize =
drivers/scsi/advansys.c:		shost->sg_tablesize = ADV_MAX_SG_LIST;
drivers/scsi/advansys.c:	if (shost->sg_tablesize > SG_ALL) {
drivers/scsi/advansys.c:		shost->sg_tablesize = SG_ALL;
drivers/scsi/advansys.c:	ASC_DBG(1, "sg_tablesize: %d\n", shost->sg_tablesize);
drivers/scsi/advansys.c:		shost->base = AscGetChipBiosAddress(asc_dvc_varp->iop_base,
drivers/scsi/advansys.c:			shost->base = ((ulong)boardp->bios_codeseg << 4);
drivers/scsi/advansys.c:			shost->base = 0;
drivers/scsi/advansys.c:	shost->dma_channel = NO_ISA_DMA;	/* Default to no ISA DMA. */
drivers/scsi/advansys.c:			shost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
drivers/scsi/advansys.c:			ret = request_dma(shost->dma_channel, DRV_NAME);
drivers/scsi/advansys.c:						shost->dma_channel, ret);
drivers/scsi/advansys.c:			AscEnableIsaDma(shost->dma_channel);
drivers/scsi/advansys.c:	if (shost->dma_channel != NO_ISA_DMA)
drivers/scsi/advansys.c:		free_dma(shost->dma_channel);
drivers/scsi/advansys.c:	if (shost->dma_channel != NO_ISA_DMA) {
drivers/scsi/advansys.c:		free_dma(shost->dma_channel);
drivers/scsi/advansys.c:		ioport = shost->io_port;
drivers/scsi/aha152x.c:			(cmd) ? ((cmd)->device->host->host_no) : -1, \
drivers/scsi/aha152x.c:			int hostno=DONE_SC->device->host->host_no;
drivers/scsi/aha1542.c:#define HOSTDATA(host) ((struct aha1542_hostdata *) &host->hostdata)
drivers/scsi/aha1542.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/aha1542.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/aha1542.c:		flag = inb(INTRFLAGS(shost->io_port));
drivers/scsi/aha1542.c:		printk("status %02x\n", inb(STATUS(shost->io_port)));
drivers/scsi/aha1542.c:		flag = inb(INTRFLAGS(shost->io_port));
drivers/scsi/aha1542.c:		aha1542_intr_reset(shost->io_port);
drivers/scsi/aha1542.c:		aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);	/* start scsi command */
drivers/scsi/aha1542.c:	if (shost->irq)
drivers/scsi/aha1542.c:		free_irq(shost->irq, shost);
drivers/scsi/aha1542.c:	if (shost->dma_channel != 0xff)
drivers/scsi/aha1542.c:		free_dma(shost->dma_channel);
drivers/scsi/aha1542.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/aha1542.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/aha1542.c:		aha1542_out(shost->io_port, &ahacmd, 1);
drivers/scsi/aha1542.c:	aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);
drivers/scsi/aha1542.c:	outb(SCRST, CONTROL(SCpnt->device->host->io_port));
drivers/scsi/aha1542.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	WAIT(STATUS(SCpnt->device->host->io_port),
drivers/scsi/aha1542.c:	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
drivers/scsi/aha1542.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	outb(HRST | SCRST, CONTROL(SCpnt->device->host->io_port));
drivers/scsi/aha1542.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	WAIT(STATUS(SCpnt->device->host->io_port),
drivers/scsi/aha1542.c:	setup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);
drivers/scsi/aha1542.c:	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
drivers/scsi/aha1542.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/aha1542.c:	       inb(STATUS(SCpnt->host->io_port)),
drivers/scsi/aha1542.c:	       inb(INTRFLAGS(SCpnt->host->io_port)));
drivers/scsi/aha1542.c:		       SCpnt->host->irq);
drivers/scsi/aha1542.c:					aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
drivers/scsi/aha1542.c:			aha1542_out(SCpnt->host->io_port, &ahacmd, 1);	/* start scsi command */
drivers/scsi/aha1542.c:		outb(HRST | SCRST, CONTROL(SCpnt->host->io_port));
drivers/scsi/aha1542.c:		WAIT(STATUS(SCpnt->host->io_port),
drivers/scsi/aha1542.c:		setup_mailboxes(SCpnt->host->io_port, SCpnt->host);
drivers/scsi/aha1542.c:		printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->host->host_no);
drivers/scsi/aha1542.c:				aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
drivers/scsi/aha1740.c:#define HOSTDATA(host) ((struct aha1740_hostdata *) &host->hostdata)
drivers/scsi/aha1740.c:		      shpnt->io_port, shpnt->irq, host->edev->slot,
drivers/scsi/aha1740.c:		      host->translation ? "en" : "dis");
drivers/scsi/aha1740.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/aha1740.c:	base = host->io_port;
drivers/scsi/aha1740.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/aha1740.c:	spin_lock_irqsave(SCpnt->device->host->host_lock, flags);
drivers/scsi/aha1740.c:	ecbno = host->last_ecb_used + 1; /* An optimization */
drivers/scsi/aha1740.c:		if (!host->ecb[ecbno].cmdw)
drivers/scsi/aha1740.c:	} while (ecbno != host->last_ecb_used);
drivers/scsi/aha1740.c:	if (host->ecb[ecbno].cmdw)
drivers/scsi/aha1740.c:	host->ecb[ecbno].cmdw = AHA1740CMD_INIT; /* SCSI Initiator Command
drivers/scsi/aha1740.c:	host->last_ecb_used = ecbno;    
drivers/scsi/aha1740.c:	spin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);
drivers/scsi/aha1740.c:	host->ecb[ecbno].cdblen = SCpnt->cmd_len; /* SCSI Command
drivers/scsi/aha1740.c:	memcpy(host->ecb[ecbno].cdb, cmd, SCpnt->cmd_len);
drivers/scsi/aha1740.c:	SCpnt->host_scribble = dma_alloc_coherent (&host->edev->dev,
drivers/scsi/aha1740.c:		host->ecb[ecbno].sg = 1;  /* SCSI Initiator Command
drivers/scsi/aha1740.c:		host->ecb[ecbno].datalen = nseg * sizeof(struct aha1740_chain);
drivers/scsi/aha1740.c:		host->ecb[ecbno].dataptr = sg_dma;
drivers/scsi/aha1740.c:		host->ecb[ecbno].datalen = 0;
drivers/scsi/aha1740.c:		host->ecb[ecbno].dataptr = 0;
drivers/scsi/aha1740.c:	host->ecb[ecbno].lun = SCpnt->device->lun;
drivers/scsi/aha1740.c:	host->ecb[ecbno].ses = 1; /* Suppress underrun errors */
drivers/scsi/aha1740.c:	host->ecb[ecbno].dir = direction;
drivers/scsi/aha1740.c:	host->ecb[ecbno].ars = 1; /* Yes, get the sense on an error */
drivers/scsi/aha1740.c:	host->ecb[ecbno].senselen = 12;
drivers/scsi/aha1740.c:	host->ecb[ecbno].senseptr = ecb_cpu_to_dma (SCpnt->device->host,
drivers/scsi/aha1740.c:						    host->ecb[ecbno].sense);
drivers/scsi/aha1740.c:	host->ecb[ecbno].statusptr = ecb_cpu_to_dma (SCpnt->device->host,
drivers/scsi/aha1740.c:						     host->ecb[ecbno].status);
drivers/scsi/aha1740.c:	host->ecb[ecbno].done = done;
drivers/scsi/aha1740.c:	host->ecb[ecbno].SCpnt = SCpnt;
drivers/scsi/aha1740.c:		for (i = 0; i < sizeof(host->ecb[ecbno]) - 10; i++)
drivers/scsi/aha1740.c:			printk("%02x ", ((unchar *)&host->ecb[ecbno])[i]);
drivers/scsi/aha1740.c:		unsigned int base = SCpnt->device->host->io_port;
drivers/scsi/aha1740.c:		spin_lock_irqsave(SCpnt->device->host->host_lock, flags);
drivers/scsi/aha1740.c:		outl (ecb_cpu_to_dma (SCpnt->device->host, host->ecb + ecbno),
drivers/scsi/aha1740.c:		spin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);
drivers/scsi/aha1740.c:	host->edev = edev;
drivers/scsi/aha1740.c:	host->translation = translation;
drivers/scsi/aha1740.c:	host->ecb_dma_addr = dma_map_single (&edev->dev, host->ecb,
drivers/scsi/aha1740.c:					     sizeof (host->ecb),
drivers/scsi/aha1740.c:	if (!host->ecb_dma_addr) {
drivers/scsi/aha1740.c:	dma_unmap_single (&edev->dev, host->ecb_dma_addr,
drivers/scsi/aha1740.c:			  sizeof (host->ecb), DMA_BIDIRECTIONAL);
drivers/scsi/aha1740.c:	dma_unmap_single (dev, host->ecb_dma_addr,
drivers/scsi/aha1740.c:			  sizeof (host->ecb), DMA_BIDIRECTIONAL);
drivers/scsi/aic7xxx/aic79xx_osm.c:	       ahd->platform_data->host->host_no,
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *(struct ahd_softc **)host->hostdata;
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic79xx_osm.c:		*((struct ahd_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *((struct ahd_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *((struct ahd_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic79xx_osm.c:	*((struct ahd_softc **)host->hostdata) = ahd;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->can_queue = AHD_MAX_QUEUE;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->cmd_per_lun = 2;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->sg_tablesize = AHD_NSEG;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->this_id = ahd->our_id;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->irq = ahd->platform_data->irq;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->max_lun = AHD_NUM_LUNS;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->max_channel = 0;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->sg_tablesize = AHD_NSEG;
drivers/scsi/aic7xxx/aic79xx_osm.c:	sprintf(buf, "scsi%d", host->host_no);
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->unique_id = ahd->unit;
drivers/scsi/aic7xxx/aic79xx_osm.c:	host->transportt = ahd_linux_transport_template;
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic79xx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic79xx_osm.c:	ahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic79xx_osm.c:	struct ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;
drivers/scsi/aic7xxx/aic79xx_proc.c:	struct	ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	       ahc->platform_data->host->host_no,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *(struct ahc_softc **)host->hostdata;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic7xxx_osm.c:		*((struct ahc_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *((struct ahc_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *((struct ahc_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	*((struct ahc_softc **)host->hostdata) = ahc;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->can_queue = AHC_MAX_QUEUE;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->cmd_per_lun = 2;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->this_id = ahc->our_id;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->irq = ahc->platform_data->irq;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->max_id = (ahc->features & AHC_WIDE) ? 16 : 8;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->max_lun = AHC_NUM_LUNS;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->max_channel = (ahc->features & AHC_TWIN) ? 1 : 0;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->sg_tablesize = AHC_NSEG;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	sprintf(buf, "scsi%d", host->host_no);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->unique_id = ahc->unit;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	host->transportt = ahc_linux_transport_template;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)sdev->host->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *((struct ahc_softc **)shost->hostdata);
drivers/scsi/aic7xxx/aic7xxx_osm.c:				      shost->this_id, starget->id, &tstate);
drivers/scsi/aic7xxx/aic7xxx_osm.c:	ahc_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,
drivers/scsi/aic7xxx/aic7xxx_osm.c:	struct ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;
drivers/scsi/aic7xxx/aic7xxx_proc.c:	struct	ahc_softc *ahc = *(struct ahc_softc **)shost->hostdata;
drivers/scsi/aic7xxx_old.c:			    p->host->cmd_per_lun);
drivers/scsi/aic7xxx_old.c:		  diff = aic_dev->max_q_depth - p->host->cmd_per_lun;
drivers/scsi/aic7xxx_old.c:  spin_lock_irqsave(p->host->host_lock, cpu_flags);
drivers/scsi/aic7xxx_old.c:  spin_unlock_irqrestore(p->host->host_lock, cpu_flags);
drivers/scsi/aic7xxx_old.c:  struct aic7xxx_host *p = (struct aic7xxx_host *)SDptr->host->hostdata;
drivers/scsi/aic7xxx_old.c: *   depth to p->host->hostt->cmd_per_lun for internal driver queueing.
drivers/scsi/aic7xxx_old.c:            device->lun, device->host->cmd_per_lun);
drivers/scsi/aic7xxx_old.c:    scsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);
drivers/scsi/aic7xxx_old.c:  struct aic7xxx_host *p = (struct aic7xxx_host *) SDptr->host->hostdata;
drivers/scsi/aic7xxx_old.c:  host->can_queue = AIC7XXX_MAXSCB;
drivers/scsi/aic7xxx_old.c:  host->cmd_per_lun = 3;
drivers/scsi/aic7xxx_old.c:  host->sg_tablesize = AIC7XXX_MAX_SG;
drivers/scsi/aic7xxx_old.c:  host->this_id = p->scsi_id;
drivers/scsi/aic7xxx_old.c:  host->io_port = p->base;
drivers/scsi/aic7xxx_old.c:  host->n_io_port = 0xFF;
drivers/scsi/aic7xxx_old.c:  host->base = p->mbase;
drivers/scsi/aic7xxx_old.c:  host->irq = p->irq;
drivers/scsi/aic7xxx_old.c:    host->max_id = 16;
drivers/scsi/aic7xxx_old.c:    host->max_channel = 1;
drivers/scsi/aic7xxx_old.c:  p->host_no = host->host_no;
drivers/scsi/aic7xxx_old.c:  host->unique_id = p->instance;
drivers/scsi/aic7xxx_old.c:    p = (struct aic7xxx_host *) host->hostdata;
drivers/scsi/aic7xxx_old.c:    p->host_no = host->host_no;
drivers/scsi/aic7xxx_old.c:  p = (struct aic7xxx_host *) cmd->device->host->hostdata;
drivers/scsi/aic7xxx_old.c:  p = (struct aic7xxx_host *)cmd->device->host->hostdata;
drivers/scsi/aic7xxx_old.c:      spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:      spin_lock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  spin_lock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:      spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/aic7xxx_old.c:      spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/aic7xxx_old.c:  spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  p = (struct aic7xxx_host *)cmd->device->host->hostdata;
drivers/scsi/aic7xxx_old.c:  spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  spin_lock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/aic7xxx_old.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/aic7xxx_old.c:  p = (struct aic7xxx_host *) cmd->device->host->hostdata;
drivers/scsi/aic7xxx_old.c:  spin_lock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:    spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  spin_unlock_irq(p->host->host_lock);
drivers/scsi/aic7xxx_old.c:  p = (struct aic7xxx_host *) sdev->host->hostdata;
drivers/scsi/aic7xxx_old.c:  struct aic7xxx_host *p = (struct aic7xxx_host *) host->hostdata;
drivers/scsi/aic7xxx_old/aic7xxx.seq: * host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
drivers/scsi/aic94xx/aic94xx_init.c:	shost->transportt = aic94xx_transport_template;
drivers/scsi/aic94xx/aic94xx_init.c:	shost->max_id = ~0;
drivers/scsi/aic94xx/aic94xx_init.c:	shost->max_lun = ~0;
drivers/scsi/aic94xx/aic94xx_init.c:	shost->max_cmd_len = 16;
drivers/scsi/aic94xx/aic94xx_init.c:	shost->can_queue = asd_ha->seq.can_queue;
drivers/scsi/arcmsr/arcmsr_attr.c:	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:	error = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	error = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	error = sysfs_create_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_clear_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_clear_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_write_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:	sysfs_remove_bin_file(&host->shost_dev.kobj, &arcmsr_sysfs_message_read_attr);
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:			(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_attr.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:			printk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			printk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			printk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			printk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			timeout, retry count down = %d \n", acb->host->host_no, retry_count);
drivers/scsi/arcmsr/arcmsr_hba.c:			timeout,retry count down = %d \n", acb->host->host_no, retry_count);
drivers/scsi/arcmsr/arcmsr_hba.c:			timeout,retry count down = %d \n", pACB->host->host_no, retry_count);
drivers/scsi/arcmsr/arcmsr_hba.c:	acb->host->max_sectors = max_xfer_len/512;
drivers/scsi/arcmsr/arcmsr_hba.c:	acb->host->sg_tablesize = max_sg_entrys;
drivers/scsi/arcmsr/arcmsr_hba.c:		printk(KERN_NOTICE "arcmsr%d: dma_alloc_coherent got error\n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			       host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:	acb = (struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:	host->max_lun = ARCMSR_MAX_TARGETLUN;
drivers/scsi/arcmsr/arcmsr_hba.c:	host->max_id = ARCMSR_MAX_TARGETID;		/*16:8*/
drivers/scsi/arcmsr/arcmsr_hba.c:	host->max_cmd_len = 16;	 			/*this is issue of 64bit LBA ,over 2T byte*/
drivers/scsi/arcmsr/arcmsr_hba.c:	host->can_queue = ARCMSR_MAX_FREECCB_NUM;	/* max simultaneous cmds */		
drivers/scsi/arcmsr/arcmsr_hba.c:	host->cmd_per_lun = ARCMSR_MAX_CMD_PERLUN;	    
drivers/scsi/arcmsr/arcmsr_hba.c:	host->this_id = ARCMSR_SCSI_INITIATOR_ID;
drivers/scsi/arcmsr/arcmsr_hba.c:	host->unique_id = (bus << 8) | dev_fun;
drivers/scsi/arcmsr/arcmsr_hba.c:	host->irq = pdev->irq;
drivers/scsi/arcmsr/arcmsr_hba.c:			, acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			, acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			, pACB->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:		printk(KERN_ERR "arcmsr%d: can't set driver mode. \n", pacb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:				acb->host->host_no, pCCB);
drivers/scsi/arcmsr/arcmsr_hba.c:				, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:		(struct AdapterControlBlock *)host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:	if (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))
drivers/scsi/arcmsr/arcmsr_hba.c:			, acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			, acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			, pACB->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:			miscellaneous data' timeout \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:		acb->host->host_no,
drivers/scsi/arcmsr/arcmsr_hba.c:		printk(KERN_NOTICE "arcmsr%d: dma_alloc_coherent got error for hbb mu\n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			miscellaneous data' timeout \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:		acb->host->host_no,
drivers/scsi/arcmsr/arcmsr_hba.c:			miscellaneous data' timeout \n", pACB->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:		pACB->host->host_no,
drivers/scsi/arcmsr/arcmsr_hba.c:					, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:				, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:					,acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:				, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:					, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:				, acb->host->host_no
drivers/scsi/arcmsr/arcmsr_hba.c:				acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:			timeout \n",acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				timeout \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				rebulid' timeout \n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				rebulid' timeout \n",acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:				rebulid' timeout \n", pACB->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:	printk(KERN_NOTICE "arcmsr%d: executing hw bus reset .....\n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:	acb = (struct AdapterControlBlock *) cmd->device->host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:					printk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, retry=%d\n", acb->host->host_no, retry_count);
drivers/scsi/arcmsr/arcmsr_hba.c:						printk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:					printk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, retry=%d\n", acb->host->host_no, retry_count);
drivers/scsi/arcmsr/arcmsr_hba.c:						printk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\n", acb->host->host_no);
drivers/scsi/arcmsr/arcmsr_hba.c:		(struct AdapterControlBlock *)cmd->device->host->hostdata;
drivers/scsi/arcmsr/arcmsr_hba.c:		acb->host->host_no, cmd->device->id, cmd->device->lun);
drivers/scsi/arcmsr/arcmsr_hba.c:		(struct AdapterControlBlock *) host->hostdata;
drivers/scsi/arm/acornscsi.c:    writeb(reg, host->base + SBIC_REGIDX);
drivers/scsi/arm/acornscsi.c:    writeb(value, host->base + SBIC_REGVAL);
drivers/scsi/arm/acornscsi.c:	   return readl(host->base + SBIC_REGIDX) & 255;
drivers/scsi/arm/acornscsi.c:    writeb(reg, host->base + SBIC_REGIDX);
drivers/scsi/arm/acornscsi.c:    return readl(host->base + SBIC_REGVAL) & 255;
drivers/scsi/arm/acornscsi.c:		host->host->host_no, where,
drivers/scsi/arm/acornscsi.c:	printk("DMA @%06x, ", host->dma.start_addr);
drivers/scsi/arm/acornscsi.c:	printk("BH @%p +%04x, ", host->scsi.SCp.ptr,
drivers/scsi/arm/acornscsi.c:		host->scsi.SCp.this_residual);
drivers/scsi/arm/acornscsi.c:	printk("DT @+%04x ST @+%04x", host->dma.transferred,
drivers/scsi/arm/acornscsi.c:		host->scsi.SCp.scsi_xferred);
drivers/scsi/arm/acornscsi.c:	printk("scsi%d: timeout while %s\n", host->host->host_no, msg);
drivers/scsi/arm/acornscsi.c:    host->card.page_reg = 0x80;
drivers/scsi/arm/acornscsi.c:    writeb(host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    host->card.page_reg = 0;
drivers/scsi/arm/acornscsi.c:    writeb(host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:	if (readb(host->fast + INT_REG) & 8)
drivers/scsi/arm/acornscsi.c:		host->host->host_no);
drivers/scsi/arm/acornscsi.c:    sbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);
drivers/scsi/arm/acornscsi.c:	if (readb(host->fast + INT_REG) & 8)
drivers/scsi/arm/acornscsi.c:		host->host->host_no);
drivers/scsi/arm/acornscsi.c:		host->host->host_no);
drivers/scsi/arm/acornscsi.c:    host->card.page_reg = 0x40;
drivers/scsi/arm/acornscsi.c:    writeb(host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:    host->scsi.phase = PHASE_IDLE;
drivers/scsi/arm/acornscsi.c:    host->scsi.disconnectable = 0;
drivers/scsi/arm/acornscsi.c:    memset(host->busyluns, 0, sizeof(host->busyluns));
drivers/scsi/arm/acornscsi.c:	host->device[i].sync_state = SYNC_NEGOCIATE;
drivers/scsi/arm/acornscsi.c:	host->device[i].disconnect_ok = 1;
drivers/scsi/arm/acornscsi.c:	ptr = host->status_ptr[target] - STATUS_BUFFER_TO_PRINT;
drivers/scsi/arm/acornscsi.c:	prev = host->status[target][ptr].when;
drivers/scsi/arm/acornscsi.c:	for (; ptr != host->status_ptr[target]; ptr = (ptr + 1) & (STATUS_BUFFER_SIZE - 1)) {
drivers/scsi/arm/acornscsi.c:		if (!host->status[target][ptr].when)
drivers/scsi/arm/acornscsi.c:			printk("%c%02X", host->status[target][ptr].irq ? '-' : ' ',
drivers/scsi/arm/acornscsi.c:					 host->status[target][ptr].ph);
drivers/scsi/arm/acornscsi.c:			printk(" %02X", host->status[target][ptr].ssr);
drivers/scsi/arm/acornscsi.c:			time_diff = host->status[target][ptr].when - prev;
drivers/scsi/arm/acornscsi.c:			prev = host->status[target][ptr].when;
drivers/scsi/arm/acornscsi.c:	if (host->SCpnt)
drivers/scsi/arm/acornscsi.c:		return '0' + host->SCpnt->device->id;
drivers/scsi/arm/acornscsi.c:    SCpnt = host->origSCpnt;
drivers/scsi/arm/acornscsi.c:    host->origSCpnt = NULL;
drivers/scsi/arm/acornscsi.c:	SCpnt = queue_remove_exclude(&host->queues.issue, host->busyluns);
drivers/scsi/arm/acornscsi.c:    if (host->scsi.disconnectable && host->SCpnt) {
drivers/scsi/arm/acornscsi.c:	queue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);
drivers/scsi/arm/acornscsi.c:	host->scsi.disconnectable = 0;
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, printk("scsi%d.%c: moved command to disconnected queue\n",
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host)));
drivers/scsi/arm/acornscsi.c:	host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:    host->scsi.phase = PHASE_CONNECTING;
drivers/scsi/arm/acornscsi.c:    host->SCpnt = SCpnt;
drivers/scsi/arm/acornscsi.c:    host->scsi.SCp = SCpnt->SCp;
drivers/scsi/arm/acornscsi.c:    host->dma.xfer_setup = 0;
drivers/scsi/arm/acornscsi.c:    host->dma.xfer_required = 0;
drivers/scsi/arm/acornscsi.c:    host->dma.xfer_done = 0;
drivers/scsi/arm/acornscsi.c:	    host->host->host_no, '0' + SCpnt->device->id,
drivers/scsi/arm/acornscsi.c:	    set_bit(SCpnt->device->id * 8 + SCpnt->device->lun, host->busyluns);
drivers/scsi/arm/acornscsi.c:	host->stats.removes += 1;
drivers/scsi/arm/acornscsi.c:	    host->stats.writes += 1;
drivers/scsi/arm/acornscsi.c:	    host->stats.reads += 1;
drivers/scsi/arm/acornscsi.c:	    host->stats.miscs += 1;
drivers/scsi/arm/acornscsi.c:    host->stats.fins += 1;
drivers/scsi/arm/acornscsi.c:	SCpnt->result = result << 16 | host->scsi.SCp.Message << 8 | host->scsi.SCp.Status;
drivers/scsi/arm/acornscsi.c:			if (host->scsi.SCp.ptr &&
drivers/scsi/arm/acornscsi.c:			if (host->scsi.SCp.scsi_xferred < SCpnt->underflow ||
drivers/scsi/arm/acornscsi.c:			    host->scsi.SCp.scsi_xferred != host->dma.transferred)
drivers/scsi/arm/acornscsi.c:		if (host->dma.xfer_done)
drivers/scsi/arm/acornscsi.c:				host->host->host_no, SCpnt->result);
drivers/scsi/arm/acornscsi.c:	    panic("scsi%d.H: null scsi_done function in acornscsi_done", host->host->host_no);
drivers/scsi/arm/acornscsi.c:	clear_bit(SCpnt->device->id * 8 + SCpnt->device->lun, host->busyluns);
drivers/scsi/arm/acornscsi.c:	printk("scsi%d: null command in acornscsi_done", host->host->host_no);
drivers/scsi/arm/acornscsi.c:    host->scsi.phase = PHASE_IDLE;
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_done = 1;
drivers/scsi/arm/acornscsi.c:    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:	__acornscsi_in(host->base + (offset << 1), ptr, this_len);
drivers/scsi/arm/acornscsi.c:	    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    writeb(host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:	__acornscsi_out(host->base + (offset << 1), ptr, this_len);
drivers/scsi/arm/acornscsi.c:	    writeb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    writeb(host->card.page_reg, host->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:    DBG(host->SCpnt, acornscsi_dumpdma(host, "stop"));
drivers/scsi/arm/acornscsi.c:    host->dma.direction = direction;
drivers/scsi/arm/acornscsi.c:	if (NO_WRITE & (1 << host->SCpnt->device->id)) {
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:    length = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);
drivers/scsi/arm/acornscsi.c:	host->dma.start_addr = address = host->dma.free_addr;
drivers/scsi/arm/acornscsi.c:	host->dma.free_addr = (host->dma.free_addr + length) &
drivers/scsi/arm/acornscsi.c:	    acornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, acornscsi_dumpdma(host, "strt"));
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_setup = 1;
drivers/scsi/arm/acornscsi.c: * Purpose : ensure that all DMA transfers are up-to-date & host->scsi.SCp is correct
drivers/scsi/arm/acornscsi.c:    if (host->dma.xfer_required) {
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_required = 0;
drivers/scsi/arm/acornscsi.c:	if (host->dma.direction == DMA_IN)
drivers/scsi/arm/acornscsi.c:	    acornscsi_data_read(host, host->dma.xfer_ptr,
drivers/scsi/arm/acornscsi.c:				 host->dma.xfer_start, host->dma.xfer_length);
drivers/scsi/arm/acornscsi.c:    if (host->dma.xfer_setup) {
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_setup = 0;
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, acornscsi_dumpdma(host, "cupi"));
drivers/scsi/arm/acornscsi.c:	transferred = dmac_address(host) - host->dma.start_addr;
drivers/scsi/arm/acornscsi.c:	host->dma.transferred += transferred;
drivers/scsi/arm/acornscsi.c:	if (host->dma.direction == DMA_IN)
drivers/scsi/arm/acornscsi.c:	    acornscsi_data_read(host, host->scsi.SCp.ptr,
drivers/scsi/arm/acornscsi.c:				 host->dma.start_addr, transferred);
drivers/scsi/arm/acornscsi.c:	acornscsi_data_updateptr(host, &host->scsi.SCp, transferred);
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, acornscsi_dumpdma(host, "cupo"));
drivers/scsi/arm/acornscsi.c:    DBG(host->SCpnt, acornscsi_dumpdma(host, "inti"));
drivers/scsi/arm/acornscsi.c:    transferred = dmac_address(host) - host->dma.start_addr;
drivers/scsi/arm/acornscsi.c:    host->dma.transferred += transferred;
drivers/scsi/arm/acornscsi.c:    if (host->dma.direction == DMA_IN) {
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_start = host->dma.start_addr;
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_length = transferred;
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_ptr = host->scsi.SCp.ptr;
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_required = 1;
drivers/scsi/arm/acornscsi.c:    acornscsi_data_updateptr(host, &host->scsi.SCp, transferred);
drivers/scsi/arm/acornscsi.c:    length = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);
drivers/scsi/arm/acornscsi.c:	host->dma.start_addr = address = host->dma.free_addr;
drivers/scsi/arm/acornscsi.c:	host->dma.free_addr = (host->dma.free_addr + length) &
drivers/scsi/arm/acornscsi.c:	if (host->dma.direction == DMA_OUT)
drivers/scsi/arm/acornscsi.c:	    acornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, acornscsi_dumpdma(host, "into"));
drivers/scsi/arm/acornscsi.c:	host->dma.xfer_setup = 0;
drivers/scsi/arm/acornscsi.c:	    acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:    host->dma.xfer_required = 0;
drivers/scsi/arm/acornscsi.c:    if (host->dma.direction == DMA_IN)
drivers/scsi/arm/acornscsi.c:	acornscsi_data_read(host, host->dma.xfer_ptr,
drivers/scsi/arm/acornscsi.c:				host->dma.xfer_start, host->dma.xfer_length);
drivers/scsi/arm/acornscsi.c:    if (host->dma.xfer_setup) {
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, acornscsi_dumpdma(host, "adji"));
drivers/scsi/arm/acornscsi.c:	 *  host->scsi.SCp.scsi_xferred is the number of bytes
drivers/scsi/arm/acornscsi.c:	 *  host->dma.transferred is the number of bytes transferred
drivers/scsi/arm/acornscsi.c:	 *  over DMA since host->dma.start_addr was last set.
drivers/scsi/arm/acornscsi.c:	 * real_dma_addr = host->dma.start_addr + host->scsi.SCp.scsi_xferred
drivers/scsi/arm/acornscsi.c:	 *		   - host->dma.transferred
drivers/scsi/arm/acornscsi.c:	transferred = host->scsi.SCp.scsi_xferred - host->dma.transferred;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), transferred);
drivers/scsi/arm/acornscsi.c:	    host->dma.xfer_setup = 0;
drivers/scsi/arm/acornscsi.c:	    transferred += host->dma.start_addr;
drivers/scsi/arm/acornscsi.c:	    DBG(host->SCpnt, acornscsi_dumpdma(host, "adjo"));
drivers/scsi/arm/acornscsi.c:	struct scsi_cmnd *SCpnt = host->SCpnt;
drivers/scsi/arm/acornscsi.c:    sbic_arm_writenext(host, SCpnt->cmd_len - host->scsi.SCp.sent_command);
drivers/scsi/arm/acornscsi.c:	(int *)&host->scsi.SCp.sent_command, SCpnt->cmd_len, 1000000))
drivers/scsi/arm/acornscsi.c:	printk("scsi%d: timeout while sending command\n", host->host->host_no);
drivers/scsi/arm/acornscsi.c:    host->scsi.phase = PHASE_COMMAND;
drivers/scsi/arm/acornscsi.c:    unsigned int message_length = msgqueue_msglength(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:	host->scsi.last_message = NOP;
drivers/scsi/arm/acornscsi.c:	msg = msgqueue_getmsg(&host->scsi.msgs, 0);
drivers/scsi/arm/acornscsi.c:	host->scsi.last_message = msg->msg[0];
drivers/scsi/arm/acornscsi.c:	while ((msg = msgqueue_getmsg(&host->scsi.msgs, msgnr++)) != NULL) {
drivers/scsi/arm/acornscsi.c:		printk("scsi%d: timeout while sending message\n", host->host->host_no);
drivers/scsi/arm/acornscsi.c:	    host->scsi.last_message = msg->msg[0];
drivers/scsi/arm/acornscsi.c:		host->scsi.last_message |= msg->msg[2] << 8;
drivers/scsi/arm/acornscsi.c:    host->scsi.SCp.Status = sbic_arm_read(host, SBIC_DATA);
drivers/scsi/arm/acornscsi.c:	    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:    if (host->scsi.phase == PHASE_RECONNECTED) {
drivers/scsi/arm/acornscsi.c:	    host->scsi.reconnected.tag = message[1];
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_MSGIN;
drivers/scsi/arm/acornscsi.c:	if (host->scsi.phase != PHASE_STATUSIN) {
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt->device->id);
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_DONE;
drivers/scsi/arm/acornscsi.c:	host->scsi.SCp.Message = message[0];
drivers/scsi/arm/acornscsi.c:	host->SCpnt->SCp = host->scsi.SCp;
drivers/scsi/arm/acornscsi.c:	host->SCpnt->SCp.sent_command = 0;
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_MSGIN;
drivers/scsi/arm/acornscsi.c:	host->scsi.SCp = host->SCpnt->SCp;
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_MSGIN;
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_DISCONNECT;
drivers/scsi/arm/acornscsi.c:	if (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST)
drivers/scsi/arm/acornscsi.c:	    host->device[host->SCpnt->device->id].sync_state = SYNC_NEGOCIATE;
drivers/scsi/arm/acornscsi.c:	if (msgqueue_msglength(&host->scsi.msgs))
drivers/scsi/arm/acornscsi.c:	switch (host->scsi.last_message) {
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:	    host->SCpnt->device->simple_tags = 0;
drivers/scsi/arm/acornscsi.c:	    set_bit(host->SCpnt->device->id * 8 + host->SCpnt->device->lun, host->busyluns);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:	    host->device[host->SCpnt->device->id].sync_xfer = SYNCHTRANSFER_2DBA;
drivers/scsi/arm/acornscsi.c:	    host->device[host->SCpnt->device->id].sync_state = SYNC_ASYNCHRONOUS;
drivers/scsi/arm/acornscsi.c:	    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host),
drivers/scsi/arm/acornscsi.c:	    if (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST) {
drivers/scsi/arm/acornscsi.c:		host->device[host->SCpnt->device->id].sync_state = SYNC_COMPLETED;
drivers/scsi/arm/acornscsi.c:			host->host->host_no, acornscsi_target(host),
drivers/scsi/arm/acornscsi.c:		host->device[host->SCpnt->device->id].sync_xfer =
drivers/scsi/arm/acornscsi.c:		msgqueue_addmsg(&host->scsi.msgs, 5, EXTENDED_MESSAGE, 3,
drivers/scsi/arm/acornscsi.c:		host->device[host->SCpnt->device->id].sync_xfer =
drivers/scsi/arm/acornscsi.c:	    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);
drivers/scsi/arm/acornscsi.c:	    msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	    msgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    if (!host->SCpnt->next_link) {
drivers/scsi/arm/acornscsi.c:			instance->host_no, acornscsi_target(host), host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:		msgqueue_addmsg(&host->scsi.msgs, 1, ABORT);
drivers/scsi/arm/acornscsi.c:		struct scsi_cmnd *SCpnt = host->SCpnt;
drivers/scsi/arm/acornscsi.c:		host->SCpnt = host->SCpnt->next_link;
drivers/scsi/arm/acornscsi.c:		host->SCpnt->tag = SCpnt->tag;
drivers/scsi/arm/acornscsi.c:		SCpnt->result = DID_OK | host->scsi.SCp.Message << 8 | host->Scsi.SCp.Status;
drivers/scsi/arm/acornscsi.c:		/* initialise host->SCpnt->SCp */
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host),
drivers/scsi/arm/acornscsi.c:	msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_MSGIN;
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 1, BUS_DEVICE_RESET);
drivers/scsi/arm/acornscsi.c:    msgqueue_addmsg(&host->scsi.msgs, 1,
drivers/scsi/arm/acornscsi.c:		     IDENTIFY(host->device[host->SCpnt->device->id].disconnect_ok,
drivers/scsi/arm/acornscsi.c:			     host->SCpnt->device->lun));
drivers/scsi/arm/acornscsi.c:	acornscsi_abortcmd(host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:    if (host->SCpnt->tag) {
drivers/scsi/arm/acornscsi.c:	if (host->SCpnt->cmnd[0] == REQUEST_SENSE ||
drivers/scsi/arm/acornscsi.c:	    host->SCpnt->cmnd[0] == TEST_UNIT_READY ||
drivers/scsi/arm/acornscsi.c:	    host->SCpnt->cmnd[0] == INQUIRY)
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 2, tag_type, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:    if (host->device[host->SCpnt->device->id].sync_state == SYNC_NEGOCIATE) {
drivers/scsi/arm/acornscsi.c:	host->device[host->SCpnt->device->id].sync_state = SYNC_SENT_REQUEST;
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 5,
drivers/scsi/arm/acornscsi.c:    if (!host->scsi.SCp.ptr /*&& host->scsi.SCp.this_residual*/) {
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:    residual = scsi_bufflen(host->SCpnt) - host->scsi.SCp.scsi_xferred;
drivers/scsi/arm/acornscsi.c:    sbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);
drivers/scsi/arm/acornscsi.c:		host->host->host_no);
drivers/scsi/arm/acornscsi.c:    if (host->SCpnt && !host->scsi.disconnectable) {
drivers/scsi/arm/acornscsi.c:		host->host->host_no, target, host->SCpnt->device->id);
drivers/scsi/arm/acornscsi.c:	host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:    host->scsi.reconnected.target = target;
drivers/scsi/arm/acornscsi.c:    host->scsi.reconnected.lun = lun;
drivers/scsi/arm/acornscsi.c:    host->scsi.reconnected.tag = 0;
drivers/scsi/arm/acornscsi.c:    if (host->scsi.disconnectable && host->SCpnt &&
drivers/scsi/arm/acornscsi.c:	host->SCpnt->device->id == target && host->SCpnt->device->lun == lun)
drivers/scsi/arm/acornscsi.c:    if (!ok && queue_probetgtlun(&host->queues.disconnected, target, lun))
drivers/scsi/arm/acornscsi.c:    ADD_STATUS(target, 0x81, host->scsi.phase, 0);
drivers/scsi/arm/acornscsi.c:	host->scsi.phase = PHASE_RECONNECTED;
drivers/scsi/arm/acornscsi.c:		host->host->host_no, '0' + target);
drivers/scsi/arm/acornscsi.c:	if (host->SCpnt) {
drivers/scsi/arm/acornscsi.c:	    queue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);
drivers/scsi/arm/acornscsi.c:	    host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:    if (host->scsi.disconnectable && host->SCpnt) {
drivers/scsi/arm/acornscsi.c:	host->scsi.disconnectable = 0;
drivers/scsi/arm/acornscsi.c:	if (host->SCpnt->device->id  == host->scsi.reconnected.target &&
drivers/scsi/arm/acornscsi.c:	    host->SCpnt->device->lun == host->scsi.reconnected.lun &&
drivers/scsi/arm/acornscsi.c:	    host->SCpnt->tag         == host->scsi.reconnected.tag) {
drivers/scsi/arm/acornscsi.c:	    DBG(host->SCpnt, printk("scsi%d.%c: reconnected",
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host)));
drivers/scsi/arm/acornscsi.c:	    queue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);
drivers/scsi/arm/acornscsi.c:	    DBG(host->SCpnt, printk("scsi%d.%c: had to move command "
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host)));
drivers/scsi/arm/acornscsi.c:	    host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:    if (!host->SCpnt) {
drivers/scsi/arm/acornscsi.c:	host->SCpnt = queue_remove_tgtluntag(&host->queues.disconnected,
drivers/scsi/arm/acornscsi.c:				host->scsi.reconnected.target,
drivers/scsi/arm/acornscsi.c:				host->scsi.reconnected.lun,
drivers/scsi/arm/acornscsi.c:				host->scsi.reconnected.tag);
drivers/scsi/arm/acornscsi.c:	DBG(host->SCpnt, printk("scsi%d.%c: had to get command",
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host)));
drivers/scsi/arm/acornscsi.c:    if (!host->SCpnt)
drivers/scsi/arm/acornscsi.c:	acornscsi_abortcmd(host, host->scsi.reconnected.tag);
drivers/scsi/arm/acornscsi.c:	host->scsi.SCp = host->SCpnt->SCp;
drivers/scsi/arm/acornscsi.c:		host->scsi.SCp.ptr, host->scsi.SCp.this_residual);
drivers/scsi/arm/acornscsi.c:    host->dma.transferred = host->scsi.SCp.scsi_xferred;
drivers/scsi/arm/acornscsi.c:    return host->SCpnt != NULL;
drivers/scsi/arm/acornscsi.c:	    host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:    acornscsi_done(host, &host->SCpnt, DID_ERROR);
drivers/scsi/arm/acornscsi.c:    host->scsi.phase = PHASE_ABORTED;
drivers/scsi/arm/acornscsi.c:    msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 2, ABORT_TAG, tag);
drivers/scsi/arm/acornscsi.c:	msgqueue_addmsg(&host->scsi.msgs, 1, ABORT);
drivers/scsi/arm/acornscsi.c:    print_sbic_status(asr, ssr, host->scsi.phase);
drivers/scsi/arm/acornscsi.c:    ADD_STATUS(8, ssr, host->scsi.phase, in_irq);
drivers/scsi/arm/acornscsi.c:    if (host->SCpnt && !host->scsi.disconnectable)
drivers/scsi/arm/acornscsi.c:	ADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);
drivers/scsi/arm/acornscsi.c:		host->host->host_no);
drivers/scsi/arm/acornscsi.c:	sbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);
drivers/scsi/arm/acornscsi.c:	msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:    switch (host->scsi.phase) {
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_CONNECTED;
drivers/scsi/arm/acornscsi.c:	    msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	    host->dma.transferred = host->scsi.SCp.scsi_xferred;
drivers/scsi/arm/acornscsi.c:	    ADD_STATUS(8, ssr, host->scsi.phase, 1);
drivers/scsi/arm/acornscsi.c:	    ADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, 1);
drivers/scsi/arm/acornscsi.c:	    acornscsi_done(host, &host->SCpnt, DID_NO_CONNECT);
drivers/scsi/arm/acornscsi.c:	    host->origSCpnt = host->SCpnt;
drivers/scsi/arm/acornscsi.c:	    host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:	    msgqueue_flush(&host->scsi.msgs);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_MSGOUT;
drivers/scsi/arm/acornscsi.c:	    acornscsi_done(host, &host->SCpnt, DID_ERROR);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    if (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_DATAOUT;
drivers/scsi/arm/acornscsi.c:	    if (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_DATAIN;
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    host->scsi.disconnectable = 1;
drivers/scsi/arm/acornscsi.c:	    host->scsi.reconnected.tag = 0;
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_IDLE;
drivers/scsi/arm/acornscsi.c:	    host->stats.disconnects += 1;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	ADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_DATAOUT;
drivers/scsi/arm/acornscsi.c:		acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_DATAIN;
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:	    host->scsi.phase = PHASE_STATUSIN;
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:	    host->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host));
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_done(host, &host->SCpnt, DID_ERROR);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    acornscsi_done(host, &host->SCpnt, DID_OK);
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	    if (host->SCpnt)
drivers/scsi/arm/acornscsi.c:		acornscsi_done(host, &host->SCpnt, DID_ABORT);
drivers/scsi/arm/acornscsi.c:		clear_bit(host->scsi.reconnected.target * 8 + host->scsi.reconnected.lun,
drivers/scsi/arm/acornscsi.c:			  host->busyluns);
drivers/scsi/arm/acornscsi.c:		host->scsi.phase = PHASE_IDLE;
drivers/scsi/arm/acornscsi.c:		    host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	    acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:		host->host->host_no, acornscsi_target(host), ssr);
drivers/scsi/arm/acornscsi.c:	acornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);
drivers/scsi/arm/acornscsi.c:	iostatus = readb(host->fast + INT_REG);
drivers/scsi/arm/acornscsi.c:	    iostatus = readb(host->fast + INT_REG);
drivers/scsi/arm/acornscsi.c:	if (host->dma.xfer_required)
drivers/scsi/arm/acornscsi.c:    AS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;
drivers/scsi/arm/acornscsi.c:		host->host->host_no, SCpnt);
drivers/scsi/arm/acornscsi.c:	    host->host->host_no, '0' + SCpnt->device->id);
drivers/scsi/arm/acornscsi.c:    host->stats.queues += 1;
drivers/scsi/arm/acornscsi.c:	if (!queue_add_cmd_ordered(&host->queues.issue, SCpnt)) {
drivers/scsi/arm/acornscsi.c:	if (host->scsi.phase == PHASE_IDLE)
drivers/scsi/arm/acornscsi.c:	if (queue_remove_cmd(&host->queues.issue, SCpnt)) {
drivers/scsi/arm/acornscsi.c:	} else if (queue_remove_cmd(&host->queues.disconnected, SCpnt)) {
drivers/scsi/arm/acornscsi.c:	} else if (host->SCpnt == SCpnt) {
drivers/scsi/arm/acornscsi.c:		switch (host->scsi.phase) {
drivers/scsi/arm/acornscsi.c:			if (host->scsi.disconnectable) {
drivers/scsi/arm/acornscsi.c:				host->scsi.disconnectable = 0;
drivers/scsi/arm/acornscsi.c:				host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:			host->SCpnt = NULL;
drivers/scsi/arm/acornscsi.c:			acornscsi_abortcmd(host, host->SCpnt->tag);
drivers/scsi/arm/acornscsi.c:	} else if (host->origSCpnt == SCpnt) {
drivers/scsi/arm/acornscsi.c:		host->origSCpnt = NULL;
drivers/scsi/arm/acornscsi.c:	AS_Host *host = (AS_Host *) SCpnt->device->host->hostdata;
drivers/scsi/arm/acornscsi.c:	host->stats.aborts += 1;
drivers/scsi/arm/acornscsi.c:		print_sbic_status(asr, ssr, host->scsi.phase);
drivers/scsi/arm/acornscsi.c:	printk("scsi%d: ", host->host->host_no);
drivers/scsi/arm/acornscsi.c:		clear_bit(SCpnt->device->id * 8 + SCpnt->device->lun, host->busyluns);
drivers/scsi/arm/acornscsi.c:	AS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;
drivers/scsi/arm/acornscsi.c:    host->stats.resets += 1;
drivers/scsi/arm/acornscsi.c:	print_sbic_status(asr, ssr, host->scsi.phase);
drivers/scsi/arm/acornscsi.c:    while ((SCptr = queue_remove(&host->queues.disconnected)) != NULL)
drivers/scsi/arm/acornscsi.c:		, host->hostt->name, host->io_port, host->irq,
drivers/scsi/arm/acornscsi.c:			host->base + SBIC_REGIDX, host->scsi.irq);
drivers/scsi/arm/acornscsi.c:			host->base + DMAC_OFFSET, host->scsi.irq);
drivers/scsi/arm/acornscsi.c:			host->stats.queues,		host->stats.removes,
drivers/scsi/arm/acornscsi.c:			host->stats.fins,		host->stats.reads,
drivers/scsi/arm/acornscsi.c:			host->stats.writes,		host->stats.miscs,
drivers/scsi/arm/acornscsi.c:			host->stats.disconnects,	host->stats.aborts,
drivers/scsi/arm/acornscsi.c:			host->stats.resets);
drivers/scsi/arm/acornscsi.c:	statptr = host->status_ptr[devidx] - 10;
drivers/scsi/arm/acornscsi.c:	prev = host->status[devidx][statptr].when;
drivers/scsi/arm/acornscsi.c:	for (; statptr != host->status_ptr[devidx]; statptr = (statptr + 1) & (STATUS_BUFFER_SIZE - 1)) {
drivers/scsi/arm/acornscsi.c:	    if (host->status[devidx][statptr].when) {
drivers/scsi/arm/acornscsi.c:			host->status[devidx][statptr].irq ? '-' : ' ',
drivers/scsi/arm/acornscsi.c:			host->status[devidx][statptr].ph,
drivers/scsi/arm/acornscsi.c:			host->status[devidx][statptr].ssr,
drivers/scsi/arm/acornscsi.c:			(host->status[devidx][statptr].when - prev) < 100 ?
drivers/scsi/arm/acornscsi.c:				(host->status[devidx][statptr].when - prev) : 99);
drivers/scsi/arm/acornscsi.c:		prev = host->status[devidx][statptr].when;
drivers/scsi/arm/acornscsi.c:	if (host->device[scd->id].sync_xfer & 15)
drivers/scsi/arm/acornscsi.c:			     host->device[scd->id].sync_xfer & 15,
drivers/scsi/arm/acornscsi.c:			     acornscsi_getperiod(host->device[scd->id].sync_xfer));
drivers/scsi/arm/acornscsi.c:	ashost = (AS_Host *)host->hostdata;
drivers/scsi/arm/acornscsi.c:	ashost->base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);
drivers/scsi/arm/acornscsi.c:	ashost->fast = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);
drivers/scsi/arm/acornscsi.c:	if (!ashost->base || !ashost->fast)
drivers/scsi/arm/acornscsi.c:	host->irq = ec->irq;
drivers/scsi/arm/acornscsi.c:	ashost->host = host;
drivers/scsi/arm/acornscsi.c:	ashost->scsi.irq = host->irq;
drivers/scsi/arm/acornscsi.c:	ec->irqaddr	= ashost->fast + INT_REG;
drivers/scsi/arm/acornscsi.c:	ret = request_irq(host->irq, acornscsi_intr, IRQF_DISABLED, "acornscsi", ashost);
drivers/scsi/arm/acornscsi.c:			host->host_no, ashost->scsi.irq, ret);
drivers/scsi/arm/acornscsi.c:	memset(&ashost->stats, 0, sizeof (ashost->stats));
drivers/scsi/arm/acornscsi.c:	queue_initialise(&ashost->queues.issue);
drivers/scsi/arm/acornscsi.c:	queue_initialise(&ashost->queues.disconnected);
drivers/scsi/arm/acornscsi.c:	msgqueue_initialise(&ashost->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	free_irq(host->irq, ashost);
drivers/scsi/arm/acornscsi.c:	msgqueue_free(&ashost->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	queue_free(&ashost->queues.disconnected);
drivers/scsi/arm/acornscsi.c:	queue_free(&ashost->queues.issue);
drivers/scsi/arm/acornscsi.c:	ecardm_iounmap(ec, ashost->fast);
drivers/scsi/arm/acornscsi.c:	ecardm_iounmap(ec, ashost->base);
drivers/scsi/arm/acornscsi.c:	AS_Host *ashost = (AS_Host *)host->hostdata;
drivers/scsi/arm/acornscsi.c:	writeb(0x80, ashost->fast + PAGE_REG);
drivers/scsi/arm/acornscsi.c:	free_irq(host->irq, ashost);
drivers/scsi/arm/acornscsi.c:	msgqueue_free(&ashost->scsi.msgs);
drivers/scsi/arm/acornscsi.c:	queue_free(&ashost->queues.disconnected);
drivers/scsi/arm/acornscsi.c:	queue_free(&ashost->queues.issue);
drivers/scsi/arm/acornscsi.c:	ecardm_iounmap(ec, ashost->fast);
drivers/scsi/arm/acornscsi.c:	ecardm_iounmap(ec, ashost->base);
drivers/scsi/arm/acornscsi.h:	host->status[(_q)][host->status_ptr[(_q)]].when = jiffies;	\
drivers/scsi/arm/acornscsi.h:	host->status[(_q)][host->status_ptr[(_q)]].ssr  = (_ssr);	\
drivers/scsi/arm/acornscsi.h:	host->status[(_q)][host->status_ptr[(_q)]].ph   = (_ph);	\
drivers/scsi/arm/acornscsi.h:	host->status[(_q)][host->status_ptr[(_q)]].irq  = (_irq);	\
drivers/scsi/arm/acornscsi.h:	host->status_ptr[(_q)] = (host->status_ptr[(_q)] + 1) & (STATUS_BUFFER_SIZE - 1); \
drivers/scsi/arm/arxescsi.c:	struct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;
drivers/scsi/arm/arxescsi.c:	struct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;
drivers/scsi/arm/arxescsi.c:		host->hostt->name, info->info.scsi.type, info->ec->slot_no,
drivers/scsi/arm/arxescsi.c:	info = (struct arxescsi_info *)host->hostdata;
drivers/scsi/arm/arxescsi.c:	info = (struct arxescsi_info *)host->hostdata;
drivers/scsi/arm/cumana_1.c:	host->irq = ec->irq;
drivers/scsi/arm/cumana_1.c:	host->n_io_port = 255;
drivers/scsi/arm/cumana_1.c:	if (!(request_region(host->io_port, host->n_io_port, "CumanaSCSI-1"))) {
drivers/scsi/arm/cumana_1.c:	ret = request_irq(host->irq, cumanascsi_intr, IRQF_DISABLED,
drivers/scsi/arm/cumana_1.c:		    host->host_no, host->irq, ret);
drivers/scsi/arm/cumana_1.c:		host->host_no, host->io_port, host->irq);
drivers/scsi/arm/cumana_1.c:		host->can_queue, host->cmd_per_lun, CUMANASCSI_PUBLIC_RELEASE);
drivers/scsi/arm/cumana_1.c:	printk("\nscsi%d:", host->host_no);
drivers/scsi/arm/cumana_1.c:	free_irq(host->irq, host);
drivers/scsi/arm/cumana_1.c:	free_irq(host->irq, host);
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:		host->hostt->name, info->info.scsi.type, info->ec->slot_no,
drivers/scsi/arm/cumana_2.c:	info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:	info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/cumana_2.c:		       host->host_no, ec->irq, ret);
drivers/scsi/arm/cumana_2.c:			       host->host_no, info->info.scsi.dma);
drivers/scsi/arm/cumana_2.c:	struct cumanascsi2_info *info = (struct cumanascsi2_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/arm/eesox.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:		host->hostt->name, info->info.scsi.type, info->ec->slot_no,
drivers/scsi/arm/eesox.c:	info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:		spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/arm/eesox.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/arm/eesox.c:	info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/eesox.c:		       host->host_no, ec->irq, ret);
drivers/scsi/arm/eesox.c:			       host->host_no, info->info.scsi.dma);
drivers/scsi/arm/eesox.c:	struct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;
drivers/scsi/arm/fas216.c:	printk("scsi%d.%c: %s", info->host->host_no, target, buf);
drivers/scsi/arm/fas216.c:				info->host->host_no, '0' + info->SCpnt->device->id);
drivers/scsi/arm/fas216.c:			info->host->host_no, fas216_target(info), fas216_drv_phase(info));
drivers/scsi/arm/fas216.c:			info->host->host_no);
drivers/scsi/arm/fas216.c:	if (!(msg[0] & (1 << info->host->this_id)) ||
drivers/scsi/arm/fas216.c:	target = msg[0] & ~(1 << info->host->this_id);
drivers/scsi/arm/fas216.c:		info->host->host_no);
drivers/scsi/arm/fas216.c:			info->host->host_no, fas216_target(info));
drivers/scsi/arm/fas216.c:	printk("scsi%d.%c: message was", info->host->host_no, fas216_target(info));
drivers/scsi/arm/fas216.c:			info->host->host_no, fas216_target(info));
drivers/scsi/arm/fas216.c:			info->host->host_no, fas216_target(info));
drivers/scsi/arm/fas216.c:			info->host->host_no, fas216_target(info),
drivers/scsi/arm/fas216.c:		info->host->host_no, fas216_target(info),
drivers/scsi/arm/fas216.c:			info->host->host_no, '0' + SCpnt->device->id);
drivers/scsi/arm/fas216.c://printk("scsi%d.%c: sense buffer: ", info->host->host_no, '0' + SCpnt->device->id);
drivers/scsi/arm/fas216.c:				info->host->host_no, '0' + SCpnt->device->id,
drivers/scsi/arm/fas216.c:		info->host->host_no);
drivers/scsi/arm/fas216.c:			info->host->host_no, '0' + SCpnt->device->id);
drivers/scsi/arm/fas216.c:		       info->host->host_no, '0' + SCpnt->device->id,
drivers/scsi/arm/fas216.c:		info->host->host_no);
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	spin_unlock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:			spin_lock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:			spin_unlock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	spin_lock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	printk(KERN_WARNING "scsi%d: abort command ", info->host->host_no);
drivers/scsi/arm/fas216.c:	printk(KERN_WARNING "scsi%d: abort %p ", info->host->host_no, SCpnt);
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;
drivers/scsi/arm/fas216.c:	spin_lock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:		info->host->host_no, '0' + SCpnt->device->id, __func__);
drivers/scsi/arm/fas216.c:	spin_unlock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	spin_lock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	spin_unlock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)host->hostdata;
drivers/scsi/arm/fas216.c:	info->scsi.cfg[0]    = host->this_id | CNTL1_PERE;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)host->hostdata;
drivers/scsi/arm/fas216.c:	spin_unlock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	spin_lock_irq(info->host->host_lock);
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)host->hostdata;
drivers/scsi/arm/fas216.c:	FAS216_Info *info = (FAS216_Info *)host->hostdata;
drivers/scsi/arm/oak.c:	host->irq = IRQ_NONE;
drivers/scsi/arm/oak.c:	host->n_io_port = 255;
drivers/scsi/arm/oak.c:		host->host_no, host->io_port);
drivers/scsi/arm/oak.c:		host->can_queue, host->cmd_per_lun, OAKSCSI_PUBLIC_RELEASE);
drivers/scsi/arm/oak.c:	printk("\nscsi%d:", host->host_no);
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:		host->hostt->name, info->info.scsi.type, info->ec->slot_no,
drivers/scsi/arm/powertec.c:	info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:	info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/powertec.c:		       host->host_no, ec->irq, ret);
drivers/scsi/arm/powertec.c:			       host->host_no, info->info.scsi.dma);
drivers/scsi/arm/powertec.c:	struct powertec_info *info = (struct powertec_info *)host->hostdata;
drivers/scsi/arm/queue.c:	 * host-available list head, and we wouldn't
drivers/scsi/arm/scsi.h:					SCpnt->device->host->host_no,
drivers/scsi/atari_NCR5380.c:#define	H_NO(cmd)	(cmd)->device->host->host_no
drivers/scsi/atari_NCR5380.c: * been issued, the host->busy array is still employed, as it is without
drivers/scsi/atari_scsi.c:				(atari_scsi_host->hostdata))->dma_len)
drivers/scsi/atari_scsi.c:		   atari_scsi_host->host_no, dma_stat & 0xff);
drivers/scsi/atari_scsi.c:	host->proc_name = "Atari";
drivers/scsi/atari_scsi.c:	host->can_queue =
drivers/scsi/atari_scsi.c:	host->cmd_per_lun =
drivers/scsi/atari_scsi.c:	host->sg_tablesize =
drivers/scsi/atari_scsi.c:		host->this_id = setup_hostid;
drivers/scsi/atari_scsi.c:		host->this_id = 7;
drivers/scsi/atari_scsi.c:				host->this_id = b & 7;
drivers/scsi/atari_scsi.c:		(struct NCR5380_hostdata *)cmd->device->host->hostdata;
drivers/scsi/atp870u.c:	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:			spin_lock_irqsave(dev->host->host_lock, flags);			 			 
drivers/scsi/atp870u.c:			spin_unlock_irqrestore(dev->host->host_lock, flags);
drivers/scsi/atp870u.c:			spin_lock_irqsave(dev->host->host_lock, flags);
drivers/scsi/atp870u.c:			spin_unlock_irqrestore(dev->host->host_lock, flags);
drivers/scsi/atp870u.c:			spin_lock_irqsave(dev->host->host_lock, flags);
drivers/scsi/atp870u.c:			spin_unlock_irqrestore(dev->host->host_lock, flags);
drivers/scsi/atp870u.c:	dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:	dev = (struct atp_unit *)&host->hostdata;
drivers/scsi/atp870u.c:	printk(KERN_INFO "free_irq : %d\n",pshost->irq);
drivers/scsi/atp870u.c:	free_irq(pshost->irq, pshost);
drivers/scsi/atp870u.c:	release_region(pshost->io_port, pshost->n_io_port);
drivers/scsi/be2iscsi/be_main.c:	shost->dma_boundary = pcidev->dma_mask;
drivers/scsi/be2iscsi/be_main.c:	shost->max_id = BE2_MAX_SESSIONS;
drivers/scsi/be2iscsi/be_main.c:	shost->max_channel = 0;
drivers/scsi/be2iscsi/be_main.c:	shost->max_cmd_len = BEISCSI_MAX_CMD_LEN;
drivers/scsi/be2iscsi/be_main.c:	shost->max_lun = BEISCSI_NUM_MAX_LUN;
drivers/scsi/be2iscsi/be_main.c:	shost->transportt = beiscsi_scsi_transport;
drivers/scsi/be2iscsi/be_main.c:				phba->shost->host_no, i);
drivers/scsi/be2iscsi/be_main.c:			phba->shost->host_no);
drivers/scsi/be2iscsi/be_main.c:	phba->boot_kset = iscsi_boot_create_host_kset(phba->shost->host_no);
drivers/scsi/be2iscsi/be_main.c:	phba->shost->max_id = phba->fw_config.iscsi_cid_count;
drivers/scsi/be2iscsi/be_main.c:	phba->shost->can_queue = phba->params.ios_per_ctrl;
drivers/scsi/be2iscsi/be_main.c:		 phba->shost->host_no);
drivers/scsi/be2iscsi/be_main.h:#define BEISCSI_CMD_PER_LUN	128	/* scsi_host->cmd_per_lun */
drivers/scsi/be2iscsi/be_main.h:#define BEISCSI_MAX_SECTORS	2048	/* scsi_host->max_sectors */
drivers/scsi/be2iscsi/be_main.h:#define BEISCSI_MAX_CMD_LEN	16	/* scsi_host->max_cmd_len */
drivers/scsi/be2iscsi/be_main.h:#define BEISCSI_NUM_MAX_LUN	256	/* scsi_host->max_lun */
drivers/scsi/bfa/bfad_attr.c:	im_port = (struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:	im_port = (struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:	im_port = (struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:		(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_attr.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_bsg.c:	iocmd->host = im_port->shost->host_no;
drivers/scsi/bfa/bfad_bsg.c:		iocmd->host = drv_itnim->im_port->shost->host_no;
drivers/scsi/bfa/bfad_bsg.c:			(struct bfad_im_port_s *) job->shost->hostdata[0];
drivers/scsi/bfa/bfad_bsg.c:			(struct bfad_im_port_s *) job->shost->hostdata[0];
drivers/scsi/bfa/bfad_im.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_im.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_im.c:		im_port->shost->host_no, cmnd, hal_io->iotag);
drivers/scsi/bfa/bfad_im.c:		im_port->shost->host_no, cmnd, hal_io->iotag);
drivers/scsi/bfa/bfad_im.c:			(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_im.c:				(struct bfad_im_port_s *) shost->hostdata[0];
drivers/scsi/bfa/bfad_im.c:		port->im_port->shost->host_no,
drivers/scsi/bfa/bfad_im.c:	im_port->shost->hostdata[0] = (unsigned long)im_port;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->unique_id = im_port->idr_id;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->this_id = -1;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->max_id = MAX_FCP_TARGET;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->max_lun = MAX_FCP_LUN;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->max_cmd_len = 16;
drivers/scsi/bfa/bfad_im.c:	im_port->shost->can_queue = bfad->cfg_data.ioc_queue_depth;
drivers/scsi/bfa/bfad_im.c:		im_port->shost->transportt = bfad_im_scsi_transport_template;
drivers/scsi/bfa/bfad_im.c:		im_port->shost->transportt =
drivers/scsi/bfa/bfad_im.c:			im_port->shost->host_no);
drivers/scsi/bfa/bfad_im.c:				im_port->shost->host_no,
drivers/scsi/bfa/bfad_im.c:				im_port->shost->host_no,
drivers/scsi/bfa/bfad_im.c:		(struct bfad_im_port_s *) cmnd->device->host->hostdata[0];
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	shost->max_cmd_len = BNX2FC_MAX_CMD_LEN;
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	shost->max_lun = BNX2FC_MAX_LUN;
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	shost->max_id = BNX2FC_MAX_FCP_TGT;
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	shost->max_channel = 0;
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:		shost->transportt = bnx2fc_vport_xport_template;
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:		shost->transportt = bnx2fc_transport_template;
drivers/scsi/bnx2i/bnx2i_hwi.c:				  bnx2i_conn->hba->shost->host_no,
drivers/scsi/bnx2i/bnx2i_iscsi.c: * bnx2i_setup_host_queue_size - assigns shost->can_queue param
drivers/scsi/bnx2i/bnx2i_iscsi.c:		shost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;
drivers/scsi/bnx2i/bnx2i_iscsi.c:		shost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5709;
drivers/scsi/bnx2i/bnx2i_iscsi.c:		shost->can_queue = ISCSI_MAX_CMDS_PER_HBA_57710;
drivers/scsi/bnx2i/bnx2i_iscsi.c:		shost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->dma_boundary = cnic->pcidev->dma_mask;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->transportt = bnx2i_scsi_xport_template;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->max_id = ISCSI_MAX_CONNS_PER_HBA;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->max_channel = 0;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->max_lun = 512;
drivers/scsi/bnx2i/bnx2i_iscsi.c:	shost->max_cmd_len = 16;
drivers/scsi/bvme6000_scsi.c:	host->base = BVME_NCR53C710_BASE;
drivers/scsi/bvme6000_scsi.c:	host->this_id = 7;
drivers/scsi/bvme6000_scsi.c:	host->irq = BVME_IRQ_SCSI;
drivers/scsi/bvme6000_scsi.c:	free_irq(host->irq, host);
drivers/scsi/cxgbi/libcxgbi.c:		shost->transportt = stt;
drivers/scsi/cxgbi/libcxgbi.c:		shost->max_lun = max_lun;
drivers/scsi/cxgbi/libcxgbi.c:		shost->max_id = max_id;
drivers/scsi/cxgbi/libcxgbi.c:		shost->max_channel = 0;
drivers/scsi/cxgbi/libcxgbi.c:		shost->max_cmd_len = 16;
drivers/scsi/cxgbi/libcxgbi.c: * final destination host-memory buffers based on the Initiator Task Tag (ITT)
drivers/scsi/cxgbi/libcxgbi.c:			shost->host_no, hba,
drivers/scsi/dc395x.c:	if (time_before(jiffies + to, acb->scsi_host->last_reset - HZ / 2))
drivers/scsi/dc395x.c:		    acb->scsi_host->last_reset - HZ / 2 + 1;
drivers/scsi/dc395x.c:	    (struct AdapterCtlBlk *)cmd->device->host->hostdata;
drivers/scsi/dc395x.c:	if (cmd->device->id >= acb->scsi_host->max_id ||
drivers/scsi/dc395x.c:	    cmd->device->lun >= acb->scsi_host->max_lun ||
drivers/scsi/dc395x.c:	acb = (struct AdapterCtlBlk *)sdev->host->hostdata;
drivers/scsi/dc395x.c:		(struct AdapterCtlBlk *)cmd->device->host->hostdata;
drivers/scsi/dc395x.c:	acb->scsi_host->last_reset =
drivers/scsi/dc395x.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/dc395x.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/dc395x.c:	    (struct AdapterCtlBlk *)cmd->device->host->hostdata;
drivers/scsi/dc395x.c:	    (jiffies + HZ, acb->scsi_host->last_reset + HZ / 2))
drivers/scsi/dc395x.c:		    acb->scsi_host->last_reset + HZ / 2 + 1;
drivers/scsi/dc395x.c:	if (time_before(jiffies, acb->scsi_host->last_reset - HZ / 2)) {
drivers/scsi/dc395x.c:	DC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);
drivers/scsi/dc395x.c:		acb->scsi_host->last_reset =
drivers/scsi/dc395x.c:		acb->scsi_host->last_reset = jiffies + HZ / 2 + 1;
drivers/scsi/dc395x.c:	DC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);	/* host   ID */
drivers/scsi/dc395x.c:	DC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);
drivers/scsi/dc395x.c:	acb->scsi_host->last_reset =
drivers/scsi/dc395x.c:	struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;
drivers/scsi/dc395x.c:	struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;
drivers/scsi/dc395x.c:	acb->scsi_host->this_id = eeprom->scsi_id;
drivers/scsi/dc395x.c:	acb->hostid_bit = (1 << acb->scsi_host->this_id);
drivers/scsi/dc395x.c:        struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;
drivers/scsi/dc395x.c:	host->max_cmd_len = 24;
drivers/scsi/dc395x.c:	host->can_queue = DC395x_MAX_CMD_QUEUE;
drivers/scsi/dc395x.c:	host->cmd_per_lun = DC395x_MAX_CMD_PER_LUN;
drivers/scsi/dc395x.c:	host->this_id = (int)eeprom->scsi_id;
drivers/scsi/dc395x.c:	host->io_port = acb->io_port_base;
drivers/scsi/dc395x.c:	host->n_io_port = acb->io_port_len;
drivers/scsi/dc395x.c:	host->dma_channel = -1;
drivers/scsi/dc395x.c:	host->unique_id = acb->io_port_base;
drivers/scsi/dc395x.c:	host->irq = acb->irq_level;
drivers/scsi/dc395x.c:	host->last_reset = jiffies;
drivers/scsi/dc395x.c:	host->max_id = 16;
drivers/scsi/dc395x.c:	if (host->max_id - 1 == eeprom->scsi_id)
drivers/scsi/dc395x.c:		host->max_id--;
drivers/scsi/dc395x.c:		host->max_lun = 8;
drivers/scsi/dc395x.c:		host->max_lun = 1;
drivers/scsi/dc395x.c:	host->max_lun = 1;
drivers/scsi/dc395x.c:		acb->scsi_host->last_reset =
drivers/scsi/dc395x.c:	struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;
drivers/scsi/dc395x.c:	SPRINTF("SCSI Host Nr %i, ", host->host_no);
drivers/scsi/dc395x.c:	SPRINTF("MaxID %i, MaxLUN %i, ", host->max_id, host->max_lun);
drivers/scsi/dc395x.c:	SPRINTF("AdapterID %i\n", host->this_id);
drivers/scsi/dc395x.c: 	acb = (struct AdapterCtlBlk*)scsi_host->hostdata;
drivers/scsi/dc395x.c:	struct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)(scsi_host->hostdata);
drivers/scsi/dmx3191d.c:	shost->io_port = io;
drivers/scsi/dmx3191d.c:	shost->irq = pdev->irq;
drivers/scsi/dmx3191d.c:		shost->irq = SCSI_IRQ_NONE;
drivers/scsi/dmx3191d.c:	free_irq(shost->irq, shost);
drivers/scsi/dmx3191d.c:	if (shost->irq != SCSI_IRQ_NONE)
drivers/scsi/dmx3191d.c:		free_irq(shost->irq, shost);
drivers/scsi/dmx3191d.c:	release_region(shost->io_port, DMX3191D_REGION_LEN);
drivers/scsi/dpt_i2o.c:	if (host->FwDebugBLEDflag_P) {
drivers/scsi/dpt_i2o.c:		if( readb(host->FwDebugBLEDflag_P) == 0xbc ){
drivers/scsi/dpt_i2o.c:			return readb(host->FwDebugBLEDvalue_P);
drivers/scsi/dpt_i2o.c:	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba *) host->hostdata[0];
drivers/scsi/dpt_i2o.c:	if (host->can_queue && device->tagged_supported) {
drivers/scsi/dpt_i2o.c:				host->can_queue - 1);
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:		pHba->host->last_reset = jiffies;
drivers/scsi/dpt_i2o.c:		pHba->host->resetting = 1;
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba *) host->hostdata[0];
drivers/scsi/dpt_i2o.c:			pHba->host->host_no, pHba->name, host->irq);
drivers/scsi/dpt_i2o.c:			host->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);
drivers/scsi/dpt_i2o.c:	spin_unlock(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:				spin_lock(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:	spin_lock(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:	spin_lock_irqsave(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:	spin_unlock_irqrestore(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:		spin_lock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:		spin_unlock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:	pHba = (void*) cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:		spin_lock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:		spin_unlock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:		spin_lock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:		spin_unlock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/dpt_i2o.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/dpt_i2o.c:		free_irq(pHba->host->irq, pHba);
drivers/scsi/dpt_i2o.c:			spin_unlock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:			spin_lock_irq(pHba->host->host_lock);
drivers/scsi/dpt_i2o.c:			spin_lock_irqsave(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:			spin_unlock_irqrestore(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:			spin_lock_irqsave(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:			spin_unlock_irqrestore(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:		spin_lock_irqsave(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:		spin_unlock_irqrestore(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:	host->hostdata[0] = (unsigned long)pHba;
drivers/scsi/dpt_i2o.c:	host->irq = pHba->pDev->irq;
drivers/scsi/dpt_i2o.c:	/* no IO ports, so don't have to set host->io_port and
drivers/scsi/dpt_i2o.c:	 * host->n_io_port
drivers/scsi/dpt_i2o.c:	host->io_port = 0;
drivers/scsi/dpt_i2o.c:	host->n_io_port = 0;
drivers/scsi/dpt_i2o.c:	host->max_id = 16;
drivers/scsi/dpt_i2o.c:	host->max_lun = 256;
drivers/scsi/dpt_i2o.c:	host->max_channel = pHba->top_scsi_channel + 1;
drivers/scsi/dpt_i2o.c:	host->cmd_per_lun = 1;
drivers/scsi/dpt_i2o.c:	host->unique_id = (u32)sys_tbl_pa + pHba->unit;
drivers/scsi/dpt_i2o.c:	host->sg_tablesize = pHba->sg_tablesize;
drivers/scsi/dpt_i2o.c:	host->can_queue = pHba->post_fifo_size;
drivers/scsi/dpt_i2o.c:	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
drivers/scsi/dpt_i2o.c:		spin_lock_irqsave(pHba->host->host_lock, flags);
drivers/scsi/dpt_i2o.c:		spin_unlock_irqrestore(pHba->host->host_lock, flags);
drivers/scsi/dtc.c:	if (shost->irq)
drivers/scsi/dtc.c:		free_irq(shost->irq, shost);
drivers/scsi/dtc.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/dtc.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/eata.c: *        + Use host->host_lock instead of io_request_lock.
drivers/scsi/eata.c: *          Use host->wish_block instead of host->block.
drivers/scsi/eata.c: *          The host->block flag is set for all the detected ISA boards.
drivers/scsi/eata.c: *  the driver sets host->wish_block = 1 for all ISA boards.
drivers/scsi/eata.c:	shost->io_port = port_base;
drivers/scsi/eata.c:	shost->unique_id = port_base;
drivers/scsi/eata.c:	shost->n_io_port = REGION_SIZE;
drivers/scsi/eata.c:	shost->dma_channel = dma_channel;
drivers/scsi/eata.c:	shost->irq = irq;
drivers/scsi/eata.c:	shost->sg_tablesize = (ushort) info.scatt_size;
drivers/scsi/eata.c:	shost->this_id = (ushort) info.host_addr[3];
drivers/scsi/eata.c:	shost->can_queue = (ushort) info.queue_size;
drivers/scsi/eata.c:	shost->cmd_per_lun = MAX_CMD_PER_LUN;
drivers/scsi/eata.c:	ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:		shost->unchecked_isa_dma = 0;
drivers/scsi/eata.c:		shost->unchecked_isa_dma = 1;
drivers/scsi/eata.c:	if (shost->sg_tablesize > MAX_SGLIST || shost->sg_tablesize < 2) {
drivers/scsi/eata.c:		       ha->board_name, shost->sg_tablesize);
drivers/scsi/eata.c:		shost->sg_tablesize = MAX_SGLIST;
drivers/scsi/eata.c:	if (shost->can_queue > MAX_MAILBOXES || shost->can_queue < 2) {
drivers/scsi/eata.c:		       ha->board_name, shost->can_queue);
drivers/scsi/eata.c:		shost->can_queue = MAX_MAILBOXES;
drivers/scsi/eata.c:			shost->max_channel = info.max_chan;
drivers/scsi/eata.c:			shost->max_id = info.max_id + 1;
drivers/scsi/eata.c:		if (info.large_sg && shost->sg_tablesize == MAX_SGLIST)
drivers/scsi/eata.c:			shost->sg_tablesize = MAX_LARGE_SGLIST;
drivers/scsi/eata.c:			shost->max_lun = info.max_lun + 1;
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++)
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++) {
drivers/scsi/eata.c:		size_t sz = shost->sg_tablesize *sizeof(struct sg_list);
drivers/scsi/eata.c:		gfp_t gfp_mask = (shost->unchecked_isa_dma ? GFP_DMA : 0) | GFP_ATOMIC;
drivers/scsi/eata.c:	       (unsigned long)shost->io_port, shost->irq, dma_name,
drivers/scsi/eata.c:	       shost->sg_tablesize, shost->can_queue);
drivers/scsi/eata.c:	if (shost->max_id > 8 || shost->max_lun > 8)
drivers/scsi/eata.c:		     ha->board_name, shost->max_id, shost->max_lun);
drivers/scsi/eata.c:	for (i = 0; i <= shost->max_channel; i++)
drivers/scsi/eata.c:	struct hostdata *ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:	for (k = 0; k < shost->can_queue; k++, i++) {
drivers/scsi/eata.c:		if (i >= shost->can_queue)
drivers/scsi/eata.c:	if (k == shost->can_queue) {
drivers/scsi/eata.c:	if (do_dma(shost->io_port, cpp->cp_dma_addr, SEND_CP_DMA)) {
drivers/scsi/eata.c:	struct hostdata *ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:	if (i >= shost->can_queue)
drivers/scsi/eata.c:	if (wait_on_busy(shost->io_port, MAXLOOP)) {
drivers/scsi/eata.c:		if (inb(shost->io_port + REG_AUX_STATUS) & IRQ_ASSERTED)
drivers/scsi/eata.c:	struct hostdata *ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/eata.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/eata.c:	if (wait_on_busy(shost->io_port, MAXLOOP)) {
drivers/scsi/eata.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/eata.c:	for (c = 0; c <= shost->max_channel; c++)
drivers/scsi/eata.c:		for (k = 0; k < shost->max_id; k++) {
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++) {
drivers/scsi/eata.c:	if (do_dma(shost->io_port, 0, RESET_PIO)) {
drivers/scsi/eata.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/eata.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/eata.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++) {
drivers/scsi/eata.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/eata.c:	for (k = 0; k < dev->host->can_queue; k++) {
drivers/scsi/eata.c:		if (do_dma(dev->host->io_port, cpp->cp_dma_addr, SEND_CP_DMA)) {
drivers/scsi/eata.c:	struct hostdata *ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:	int irq = shost->irq;
drivers/scsi/eata.c:	if (!(inb(shost->io_port + REG_AUX_STATUS) & IRQ_ASSERTED))
drivers/scsi/eata.c:	if (wait_on_busy(shost->io_port, 20 * MAXLOOP)) {
drivers/scsi/eata.c:		reg = inb(shost->io_port + REG_STATUS);
drivers/scsi/eata.c:	reg = inb(shost->io_port + REG_STATUS);
drivers/scsi/eata.c:	if (spp->cpp_index < 0 || spp->cpp_index >= shost->can_queue)
drivers/scsi/eata.c:	    || spp->cpp_index >= shost->can_queue)
drivers/scsi/eata.c:		for (c = 0; c <= shost->max_channel; c++)
drivers/scsi/eata.c:			for (k = 0; k < shost->max_id; k++)
drivers/scsi/eata.c:	spin_lock_irqsave(shost->host_lock, spin_flags);
drivers/scsi/eata.c:	spin_unlock_irqrestore(shost->host_lock, spin_flags);
drivers/scsi/eata.c:	struct hostdata *ha = (struct hostdata *)shost->hostdata;
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++)
drivers/scsi/eata.c:	for (i = 0; i < shost->can_queue; i++)
drivers/scsi/eata.c:	free_irq(shost->irq, &sha[ha->board_number]);
drivers/scsi/eata.c:	if (shost->dma_channel != NO_DMA)
drivers/scsi/eata.c:		free_dma(shost->dma_channel);
drivers/scsi/eata.c:	release_region(shost->io_port, shost->n_io_port);
drivers/scsi/eata_generic.h:#define HD(cmd)	 ((hostdata *)&(cmd->device->host->hostdata))
drivers/scsi/eata_generic.h:#define SD(host) ((hostdata *)&(host->hostdata))
drivers/scsi/eata_pio.c:		   shost->host_no, SD(shost)->name);
drivers/scsi/eata_pio.c:	len += sprintf(buffer + len, "Base IO : %#.4x\n", (u32) shost->base);
drivers/scsi/eata_pio.c:		base = cmd->device->host->base;
drivers/scsi/eata_pio.c:	while (inb(cmd->device->host->base + HA_RAUXSTAT) & HA_ABUSY)
drivers/scsi/eata_pio.c:	spin_lock_irq(host->host_lock);
drivers/scsi/eata_pio.c:		spin_unlock_irq(host->host_lock);
drivers/scsi/eata_pio.c:	for (x = 0; x < cmd->device->host->can_queue; x++) {
drivers/scsi/eata_pio.c:	outb(EATA_CMD_RESET, cmd->device->host->base + HA_WCOMMAND);
drivers/scsi/eata_pio.c:	spin_unlock_irq(host->host_lock);
drivers/scsi/eata_pio.c:	spin_lock_irq(host->host_lock);
drivers/scsi/eata_pio.c:	for (x = 0; x < cmd->device->host->can_queue; x++) {
drivers/scsi/eata_pio.c:	spin_unlock_irq(host->host_lock);
drivers/scsi/esp_scsi.c:	       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, idx,
drivers/scsi/esp_scsi.c:				       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id,
drivers/scsi/esp_scsi.c:				  esp->host->unique_id, tgt, lun);
drivers/scsi/esp_scsi.c:			       esp->host->unique_id, tgt, lun);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, esp->sreg);
drivers/scsi/esp_scsi.c:				       esp->host->unique_id, esp->sreg);
drivers/scsi/esp_scsi.c:			       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, esp->sreg);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, esp->command_block[0]);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, esp->command_block[1]);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, target, lun);
drivers/scsi/esp_scsi.c:			       esp->host->unique_id);
drivers/scsi/esp_scsi.c:			       esp->host->unique_id,
drivers/scsi/esp_scsi.c:/* Runs under host->lock */
drivers/scsi/esp_scsi.c:	spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	esp->host->transportt = esp_transport_template;
drivers/scsi/esp_scsi.c:	esp->host->max_lun = ESP_MAX_LUN;
drivers/scsi/esp_scsi.c:	esp->host->cmd_per_lun = 2;
drivers/scsi/esp_scsi.c:	esp->host->unique_id = instance;
drivers/scsi/esp_scsi.c:	       esp->host->unique_id, esp->regs, esp->dma_regs,
drivers/scsi/esp_scsi.c:	       esp->host->irq);
drivers/scsi/esp_scsi.c:	       esp->host->unique_id, esp_chip_names[esp->rev],
drivers/scsi/esp_scsi.c:	if (queue_depth < dev->host->cmd_per_lun)
drivers/scsi/esp_scsi.c:		queue_depth = dev->host->cmd_per_lun;
drivers/scsi/esp_scsi.c:	spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	       esp->host->unique_id, cmd, cmd->cmnd[0]);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);
drivers/scsi/esp_scsi.c:		       esp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:		spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:		spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:		spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:		spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_lock_irqsave(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.c:	spin_unlock_irqrestore(esp->host->host_lock, flags);
drivers/scsi/esp_scsi.h: * 2) Set host->max_id as appropriate.
drivers/scsi/esp_scsi.h: *    esp->scsi_id (assign to esp->host->this_id too)
drivers/scsi/fcoe/fcoe.c:	lport->host->max_lun = FCOE_MAX_LUN;
drivers/scsi/fcoe/fcoe.c:	lport->host->max_id = FCOE_MAX_FCP_TARGET;
drivers/scsi/fcoe/fcoe.c:	lport->host->max_channel = 0;
drivers/scsi/fcoe/fcoe.c:	lport->host->max_cmd_len = FCOE_MAX_CMD_LEN;
drivers/scsi/fcoe/fcoe.c:		lport->host->transportt = fcoe_vport_scsi_transport;
drivers/scsi/fcoe/fcoe.c:		lport->host->transportt = fcoe_nport_scsi_transport;
drivers/scsi/fcoe/fcoe_ctlr.c:		       fip->lp->host->host_no, fip->dest_addr);
drivers/scsi/fcoe/fcoe_ctlr.c:		       fip->lp->host->host_no, sel->fcf_mac);
drivers/scsi/fcoe/fcoe_ctlr.c:				       fip->lp->host->host_no, fcf->fabric_name,
drivers/scsi/fcoe/libfcoe.h:				     (fip)->lp->host->host_no, ##args);)
drivers/scsi/fdomain.c:         spin_lock_irqsave(current_SC->device->host->host_lock, flags);
drivers/scsi/fdomain.c:         spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
drivers/scsi/fdomain.c:            spin_lock_irqsave(current_SC->device->host->host_lock, flags);
drivers/scsi/fdomain.c:            spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
drivers/scsi/fdomain.c:      spin_lock_irqsave(current_SC->device->host->host_lock, flags);
drivers/scsi/fdomain.c:      spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
drivers/scsi/fnic/fnic_main.c:		 host->host_no);
drivers/scsi/fnic/fnic_main.c:	host->transportt = fnic_fc_transport;
drivers/scsi/fnic/fnic_main.c:	host->max_lun = fnic->config.luns_per_tgt;
drivers/scsi/fnic/fnic_main.c:	host->max_id = FNIC_MAX_FCP_TARGET;
drivers/scsi/fnic/fnic_main.c:	host->max_cmd_len = FCOE_MAX_CMD_LEN;
drivers/scsi/fnic/fnic_scsi.c:	spin_unlock(lp->host->host_lock);
drivers/scsi/fnic/fnic_scsi.c:	spin_lock(lp->host->host_lock);
drivers/scsi/fnic/fnic_scsi.c:						qd = t_sdev->host->cmd_per_lun;
drivers/scsi/fnic/fnic_scsi.c:						     t_sdev->host->host_no,
drivers/scsi/g_NCR5380.c:	PRINTP("host number %d destination target %d, lun %d\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
drivers/scsi/gdth.c:    scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/hosts.c: *  Jiffies wrap fixes (host->resetting), 3 Dec 1998 Andrea Arcangeli
drivers/scsi/hosts.c:	enum scsi_host_state oldstate = shost->shost_state;
drivers/scsi/hosts.c:	shost->shost_state = state;
drivers/scsi/hosts.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/hosts.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/hosts.c:			spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/hosts.c:			mutex_unlock(&shost->scan_mutex);
drivers/scsi/hosts.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/hosts.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/hosts.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/hosts.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/hosts.c:	transport_unregister_device(&shost->shost_gendev);
drivers/scsi/hosts.c:	device_unregister(&shost->shost_dev);
drivers/scsi/hosts.c:	device_del(&shost->shost_gendev);
drivers/scsi/hosts.c:	struct scsi_host_template *sht = shost->hostt;
drivers/scsi/hosts.c:	printk(KERN_INFO "scsi%d : %s\n", shost->host_no,
drivers/scsi/hosts.c:	if (!shost->can_queue) {
drivers/scsi/hosts.c:	if (!shost->shost_gendev.parent)
drivers/scsi/hosts.c:		shost->shost_gendev.parent = dev ? dev : &platform_bus;
drivers/scsi/hosts.c:		dma_dev = shost->shost_gendev.parent;
drivers/scsi/hosts.c:	shost->dma_dev = dma_dev;
drivers/scsi/hosts.c:	error = device_add(&shost->shost_gendev);
drivers/scsi/hosts.c:	pm_runtime_set_active(&shost->shost_gendev);
drivers/scsi/hosts.c:	pm_runtime_enable(&shost->shost_gendev);
drivers/scsi/hosts.c:	device_enable_async_suspend(&shost->shost_gendev);
drivers/scsi/hosts.c:	get_device(shost->shost_gendev.parent);
drivers/scsi/hosts.c:	device_enable_async_suspend(&shost->shost_dev);
drivers/scsi/hosts.c:	error = device_add(&shost->shost_dev);
drivers/scsi/hosts.c:	get_device(&shost->shost_gendev);
drivers/scsi/hosts.c:	if (shost->transportt->host_size) {
drivers/scsi/hosts.c:		shost->shost_data = kzalloc(shost->transportt->host_size,
drivers/scsi/hosts.c:		if (shost->shost_data == NULL) {
drivers/scsi/hosts.c:	if (shost->transportt->create_work_queue) {
drivers/scsi/hosts.c:		snprintf(shost->work_q_name, sizeof(shost->work_q_name),
drivers/scsi/hosts.c:			 "scsi_wq_%d", shost->host_no);
drivers/scsi/hosts.c:		shost->work_q = create_singlethread_workqueue(
drivers/scsi/hosts.c:					shost->work_q_name);
drivers/scsi/hosts.c:		if (!shost->work_q) {
drivers/scsi/hosts.c:	if (shost->work_q)
drivers/scsi/hosts.c:		destroy_workqueue(shost->work_q);
drivers/scsi/hosts.c:	kfree(shost->shost_data);
drivers/scsi/hosts.c:	device_del(&shost->shost_dev);
drivers/scsi/hosts.c:	device_del(&shost->shost_gendev);
drivers/scsi/hosts.c:	scsi_proc_hostdir_rm(shost->hostt);
drivers/scsi/hosts.c:	if (shost->ehandler)
drivers/scsi/hosts.c:		kthread_stop(shost->ehandler);
drivers/scsi/hosts.c:	if (shost->work_q)
drivers/scsi/hosts.c:		destroy_workqueue(shost->work_q);
drivers/scsi/hosts.c:	q = shost->uspace_req_q;
drivers/scsi/hosts.c:	if (shost->bqt)
drivers/scsi/hosts.c:		blk_free_tags(shost->bqt);
drivers/scsi/hosts.c:	kfree(shost->shost_data);
drivers/scsi/hosts.c:	shost->host_lock = &shost->default_lock;
drivers/scsi/hosts.c:	spin_lock_init(shost->host_lock);
drivers/scsi/hosts.c:	shost->shost_state = SHOST_CREATED;
drivers/scsi/hosts.c:	INIT_LIST_HEAD(&shost->__devices);
drivers/scsi/hosts.c:	INIT_LIST_HEAD(&shost->__targets);
drivers/scsi/hosts.c:	INIT_LIST_HEAD(&shost->eh_cmd_q);
drivers/scsi/hosts.c:	INIT_LIST_HEAD(&shost->starved_list);
drivers/scsi/hosts.c:	init_waitqueue_head(&shost->host_wait);
drivers/scsi/hosts.c:	mutex_init(&shost->scan_mutex);
drivers/scsi/hosts.c:	shost->host_no = atomic_inc_return(&scsi_host_next_hn) - 1;
drivers/scsi/hosts.c:	shost->dma_channel = 0xff;
drivers/scsi/hosts.c:	shost->max_channel = 0;
drivers/scsi/hosts.c:	shost->max_id = 8;
drivers/scsi/hosts.c:	shost->max_lun = 8;
drivers/scsi/hosts.c:	shost->transportt = &blank_transport_template;
drivers/scsi/hosts.c:	shost->max_cmd_len = 12;
drivers/scsi/hosts.c:	shost->hostt = sht;
drivers/scsi/hosts.c:	shost->this_id = sht->this_id;
drivers/scsi/hosts.c:	shost->can_queue = sht->can_queue;
drivers/scsi/hosts.c:	shost->sg_tablesize = sht->sg_tablesize;
drivers/scsi/hosts.c:	shost->sg_prot_tablesize = sht->sg_prot_tablesize;
drivers/scsi/hosts.c:	shost->cmd_per_lun = sht->cmd_per_lun;
drivers/scsi/hosts.c:	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
drivers/scsi/hosts.c:	shost->use_clustering = sht->use_clustering;
drivers/scsi/hosts.c:	shost->ordered_tag = sht->ordered_tag;
drivers/scsi/hosts.c:		shost->active_mode = MODE_INITIATOR;
drivers/scsi/hosts.c:		shost->active_mode = sht->supported_mode;
drivers/scsi/hosts.c:		shost->max_host_blocked = sht->max_host_blocked;
drivers/scsi/hosts.c:		shost->max_host_blocked = SCSI_DEFAULT_HOST_BLOCKED;
drivers/scsi/hosts.c:		shost->max_sectors = sht->max_sectors;
drivers/scsi/hosts.c:		shost->max_sectors = SCSI_DEFAULT_MAX_SECTORS;
drivers/scsi/hosts.c:		shost->dma_boundary = sht->dma_boundary;
drivers/scsi/hosts.c:		shost->dma_boundary = 0xffffffff;
drivers/scsi/hosts.c:	device_initialize(&shost->shost_gendev);
drivers/scsi/hosts.c:	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
drivers/scsi/hosts.c:	shost->shost_gendev.bus = &scsi_bus_type;
drivers/scsi/hosts.c:	shost->shost_gendev.type = &scsi_host_type;
drivers/scsi/hosts.c:	device_initialize(&shost->shost_dev);
drivers/scsi/hosts.c:	shost->shost_dev.parent = &shost->shost_gendev;
drivers/scsi/hosts.c:	shost->shost_dev.class = &shost_class;
drivers/scsi/hosts.c:	dev_set_name(&shost->shost_dev, "host%d", shost->host_no);
drivers/scsi/hosts.c:	shost->shost_dev.groups = scsi_sysfs_shost_attr_groups;
drivers/scsi/hosts.c:	shost->ehandler = kthread_run(scsi_error_handler, shost,
drivers/scsi/hosts.c:			"scsi_eh_%d", shost->host_no);
drivers/scsi/hosts.c:	if (IS_ERR(shost->ehandler)) {
drivers/scsi/hosts.c:			shost->host_no, PTR_ERR(shost->ehandler));
drivers/scsi/hosts.c:	scsi_proc_hostdir_add(shost->hostt);
drivers/scsi/hosts.c:		list_add_tail(&shost->sht_legacy_list, &sht->legacy_hosts);
drivers/scsi/hosts.c:	list_del(&shost->sht_legacy_list);
drivers/scsi/hosts.c:	if ((shost->shost_state == SHOST_DEL) ||
drivers/scsi/hosts.c:		!get_device(&shost->shost_gendev))
drivers/scsi/hosts.c:	put_device(&shost->shost_gendev);
drivers/scsi/hosts.c:	if (unlikely(!shost->work_q)) {
drivers/scsi/hosts.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/hosts.c:	return queue_work(shost->work_q, work);
drivers/scsi/hosts.c:	if (!shost->work_q) {
drivers/scsi/hosts.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/hosts.c:	flush_workqueue(shost->work_q);
drivers/scsi/hpsa.c:	hpsa_update_scsi_devices(h, h->scsi_host->host_no);
drivers/scsi/hpsa.c: * complaining.  Doing a host- or bus-reset can't do anything good here.
drivers/scsi/hpsa.c:		h->scsi_host->host_no, dev->bus, dev->target, dev->lun);
drivers/scsi/hptiop.c:		spin_lock_irq(hba->host->host_lock);
drivers/scsi/hptiop.c:		spin_unlock_irq(hba->host->host_lock);
drivers/scsi/hptiop.c:			hba->host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/hptiop.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:			host->host_no, scp->device->channel,
drivers/scsi/hptiop.c:		printk(KERN_ERR "scsi%d: reset failed\n", hba->host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:	struct hptiop_hba * hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:			scp->device->host->host_no, scp->device->channel,
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)sdev->host->hostdata;
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:	hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:	host->max_lun = 1;
drivers/scsi/hptiop.c:	host->max_channel = 0;
drivers/scsi/hptiop.c:	host->io_port = 0;
drivers/scsi/hptiop.c:	host->n_io_port = 0;
drivers/scsi/hptiop.c:	host->irq = pcidev->irq;
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:	host->max_sectors = le32_to_cpu(iop_config.data_transfer_length) >> 9;
drivers/scsi/hptiop.c:	host->max_id = le32_to_cpu(iop_config.max_devices);
drivers/scsi/hptiop.c:	host->sg_tablesize = le32_to_cpu(iop_config.max_sg_count);
drivers/scsi/hptiop.c:	host->can_queue = le32_to_cpu(iop_config.max_requests);
drivers/scsi/hptiop.c:	host->cmd_per_lun = le32_to_cpu(iop_config.max_requests);
drivers/scsi/hptiop.c:	host->max_cmd_len = 16;
drivers/scsi/hptiop.c:	set_config.iop_id = cpu_to_le32(host->host_no);
drivers/scsi/hptiop.c:	set_config.vbus_id = cpu_to_le16(host->host_no);
drivers/scsi/hptiop.c:				hba->host->host_no);
drivers/scsi/hptiop.c:					hba->host->host_no, pcidev->irq);
drivers/scsi/hptiop.c:					hba->host->host_no);
drivers/scsi/hptiop.c:					hba->host->host_no);
drivers/scsi/hptiop.c:	dprintk("scsi%d: hptiop_probe successfully\n", hba->host->host_no);
drivers/scsi/hptiop.c:	dprintk("scsi%d: hptiop_probe fail\n", host ? host->host_no : 0);
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:					hba->host->host_no);
drivers/scsi/hptiop.c:	struct hptiop_hba *hba = (struct hptiop_hba *)host->hostdata;
drivers/scsi/hptiop.c:	dprintk("scsi%d: hptiop_remove\n", hba->host->host_no);
drivers/scsi/hptiop.h:	/* host-to-iop messages */
drivers/scsi/hptiop.h:	u32     req_size; /* host-allocated request buffer size */
drivers/scsi/ibmmca.c:   host-adapter number and the right shows the accessed SCSI-ID. */
drivers/scsi/ibmmca.c:	shpnt = dev;		/* assign host-structure to local pointer */
drivers/scsi/ibmvscsi/ibmvfc.c:	entry = &vhost->trace[vhost->trace_index++];
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_trace_entry *entry = &vhost->trace[vhost->trace_index++];
drivers/scsi/ibmvscsi/ibmvfc.c:	switch (vhost->state) {
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->state = state;
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT)
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->action == IBMVFC_HOST_ACTION_LOGO)
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->action == IBMVFC_HOST_ACTION_INIT)
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		switch (vhost->action) {
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->action == IBMVFC_HOST_ACTION_ALLOC_TGTS)
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		switch (vhost->action) {
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->action = action;
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->action == IBMVFC_HOST_ACTION_NONE) {
drivers/scsi/ibmvscsi/ibmvfc.c:			scsi_block_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->reinit = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	scsi_block_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->events_to_log |= IBMVFC_AE_LINKDOWN;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {
drivers/scsi/ibmvscsi/ibmvfc.c:		if (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev,
drivers/scsi/ibmvscsi/ibmvfc.c:		memset(vhost->async_crq.msgs, 0, PAGE_SIZE);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->async_crq.cur = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:		scsi_block_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->job_step = ibmvfc_npiv_login;
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct vio_dev *vdev = to_vio_dev(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct vio_dev *vdev = to_vio_dev(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_crq_queue *crq = &vhost->crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	tasklet_kill(&vhost->tasklet);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->state = IBMVFC_NO_CRQ;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->logged_in = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_unmap_single(vhost->dev, crq->msg_token, PAGE_SIZE, DMA_BIDIRECTIONAL);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct vio_dev *vdev = to_vio_dev(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Error enabling adapter (rc=%d)\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct vio_dev *vdev = to_vio_dev(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_crq_queue *crq = &vhost->crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->state = IBMVFC_NO_CRQ;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->logged_in = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_warn(vhost->dev, "Partner adapter not ready\n");
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_warn(vhost->dev, "Couldn't register crq (rc=%d)\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_event_pool *pool = &vhost->pool;
drivers/scsi/ibmvscsi/ibmvfc.c:	list_add_tail(&evt->queue, &vhost->free);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry_safe(evt, pos, &vhost->sent, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->logged_in && vhost->action != IBMVFC_HOST_ACTION_LOGO_WAIT &&
drivers/scsi/ibmvscsi/ibmvfc.c:		scsi_block_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->job_step = ibmvfc_npiv_logout;
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->delay_init = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:		if (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev,
drivers/scsi/ibmvscsi/ibmvfc.c:		} else if (vhost->init_retries == IBMVFC_MAX_HOST_INIT_RETRIES)
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->state == IBMVFC_ACTIVE) {
drivers/scsi/ibmvscsi/ibmvfc.c:		switch (vhost->login_buf->resp.link_speed / 100) {
drivers/scsi/ibmvscsi/ibmvfc.c:				   vhost->login_buf->resp.link_speed / 100);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	switch (vhost->state) {
drivers/scsi/ibmvscsi/ibmvfc.c:		ibmvfc_log(vhost, 3, "Unknown port state: %d\n", vhost->state);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	long timeout = wait_event_timeout(vhost->init_wait_q,
drivers/scsi/ibmvscsi/ibmvfc.c:					  ((vhost->state == IBMVFC_ACTIVE ||
drivers/scsi/ibmvscsi/ibmvfc.c:					    vhost->state == IBMVFC_HOST_OFFLINE ||
drivers/scsi/ibmvscsi/ibmvfc.c:					    vhost->state == IBMVFC_LINK_DEAD) &&
drivers/scsi/ibmvscsi/ibmvfc.c:					   vhost->action == IBMVFC_HOST_ACTION_NONE),
drivers/scsi/ibmvscsi/ibmvfc.c:	dev_err(vhost->dev, "Initiating host LIP. Resetting connection\n");
drivers/scsi/ibmvscsi/ibmvfc.c:		strncpy(vhost->partition_name, name, sizeof(vhost->partition_name));
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->partition_number = *num;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_npiv_login *login_info = &vhost->login_info;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct device_node *of_node = vhost->dev->of_node;
drivers/scsi/ibmvscsi/ibmvfc.c:	login_info->partition_num = vhost->partition_number;
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->client_migrated)
drivers/scsi/ibmvscsi/ibmvfc.c:	login_info->async.va = vhost->async_crq.msg_token;
drivers/scsi/ibmvscsi/ibmvfc.c:	login_info->async.len = vhost->async_crq.size * sizeof(*vhost->async_crq.msgs);
drivers/scsi/ibmvscsi/ibmvfc.c:	strncpy(login_info->partition_name, vhost->partition_name, IBMVFC_MAX_NAME);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_name(&vhost->host->shost_gendev), IBMVFC_MAX_NAME);
drivers/scsi/ibmvscsi/ibmvfc.c:	location = location ? location : dev_name(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_event_pool *pool = &vhost->pool;
drivers/scsi/ibmvscsi/ibmvfc.c:	pool->iu_storage = dma_alloc_coherent(vhost->dev,
drivers/scsi/ibmvscsi/ibmvfc.c:		list_add_tail(&evt->queue, &vhost->free);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_event_pool *pool = &vhost->pool;
drivers/scsi/ibmvscsi/ibmvfc.c:			dma_pool_free(vhost->sg_pool,
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_free_coherent(vhost->dev,
drivers/scsi/ibmvscsi/ibmvfc.c:	BUG_ON(list_empty(&vhost->free));
drivers/scsi/ibmvscsi/ibmvfc.c:	evt = list_entry(vhost->free.next, struct ibmvfc_event, queue);
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
drivers/scsi/ibmvscsi/ibmvfc.c:		evt->ext_list = dma_pool_alloc(vhost->sg_pool, GFP_ATOMIC,
drivers/scsi/ibmvscsi/ibmvfc.c:			if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
drivers/scsi/ibmvscsi/ibmvfc.c:	dev_err(vhost->dev, "Command timed out (%p). Resetting connection\n", evt);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_add_tail(&evt->queue, &vhost->sent);
drivers/scsi/ibmvscsi/ibmvfc.c:				dev_warn(vhost->dev, "Send warning. Receive queue closed, will retry.\n");
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Send error (rc=%d)\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!logerr && (vhost->log_level <= (IBMVFC_DEFAULT_LOG_LEVEL + 1)))
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:	switch (vhost->state) {
drivers/scsi/ibmvscsi/ibmvfc.c:	if (likely(!(rc = ibmvfc_map_sg_data(cmnd, evt, vfc_cmd, vhost->dev))))
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->aborting_passthru = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:	dev_info(vhost->dev, "Passthru command cancelled\n");
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->aborting_passthru || vhost->state != IBMVFC_ACTIVE) {
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->aborting_passthru = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->aborting_passthru = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Failed to send cancel event. rc=%d\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_info(vhost->dev, "Cancelling passthru command to port id 0x%lx\n",
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!mutex_trylock(&vhost->passthru_mutex))
drivers/scsi/ibmvscsi/ibmvfc.c:	req_seg = dma_map_sg(vhost->dev, job->request_payload.sg_list,
drivers/scsi/ibmvscsi/ibmvfc.c:		mutex_unlock(&vhost->passthru_mutex);
drivers/scsi/ibmvscsi/ibmvfc.c:	rsp_seg = dma_map_sg(vhost->dev, job->reply_payload.sg_list,
drivers/scsi/ibmvscsi/ibmvfc.c:		dma_unmap_sg(vhost->dev, job->request_payload.sg_list,
drivers/scsi/ibmvscsi/ibmvfc.c:		mutex_unlock(&vhost->passthru_mutex);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_unmap_sg(vhost->dev, job->request_payload.sg_list,
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_unmap_sg(vhost->dev, job->reply_payload.sg_list,
drivers/scsi/ibmvscsi/ibmvfc.c:	mutex_unlock(&vhost->passthru_mutex);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->state == IBMVFC_ACTIVE) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(evt, &vhost->sent, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:				spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:				list_for_each_entry(evt, &vhost->sent, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:				spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:					dev_err(vhost->dev, "Timed out waiting for aborted commands\n");
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(evt, &vhost->sent, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->state == IBMVFC_ACTIVE) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(evt, &vhost->sent, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->state == IBMVFC_ACTIVE) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	dev_err(vhost->dev, "Resetting connection due to error recovery\n");
drivers/scsi/ibmvscsi/ibmvfc.c:	rc = ibmvfc_issue_fc_host_lip(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->events_to_log |= IBMVFC_AE_LINKUP;
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->delay_init = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->events_to_log |= IBMVFC_AE_LINKUP;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->delay_init = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->events_to_log |= IBMVFC_AE_RSCN;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->delay_init = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->events_to_log |= IBMVFC_AE_RSCN;
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Unknown async event received: %lld\n", crq->event);
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_info(vhost->dev, "Partner initialized\n");
drivers/scsi/ibmvscsi/ibmvfc.c:				dev_err(vhost->dev, "Unable to send init rsp. rc=%ld\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_info(vhost->dev, "Partner initialization complete\n");
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev, "Unknown crq message type: %d\n", crq->format);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->state = IBMVFC_NO_CRQ;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->logged_in = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_info(vhost->dev, "Re-enabling adapter\n");
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->client_migrated = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev, "Virtual adapter failed (rc=%d)\n", crq->format);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Got an invalid message type 0x%02x\n", crq->valid);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (unlikely(!ibmvfc_valid_event(&vhost->pool, evt))) {
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Returned correlation_token 0x%08llx is invalid!\n",
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Received duplicate correlation_token 0x%08llx!\n",
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_info(vhost->dev, "Scan taking longer than %d seconds, "
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->scan_complete)
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	sdev->hostdata = (void *)(unsigned long)vhost->task_set++;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	starget->hostdata = (void *)(unsigned long)vhost->task_set++;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->login_buf->resp.partition_name);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->login_buf->resp.device_name);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->login_buf->resp.port_loc_code);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->login_buf->resp.drc_name);
drivers/scsi/ibmvscsi/ibmvfc.c:	return snprintf(buf, PAGE_SIZE, "%d\n", vhost->login_buf->resp.version);
drivers/scsi/ibmvscsi/ibmvfc.c:	return snprintf(buf, PAGE_SIZE, "%llx\n", vhost->login_buf->resp.capabilities);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	len = snprintf(buf, PAGE_SIZE, "%d\n", vhost->log_level);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->log_level = simple_strtoul(buf, NULL, 10);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	char *src = (char *)vhost->trace;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_async_crq_queue *async_crq = &vhost->async_crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_crq_queue *queue = &vhost->crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vio_disable_interrupts(to_vio_dev(vhost->dev));
drivers/scsi/ibmvscsi/ibmvfc.c:	tasklet_schedule(&vhost->tasklet);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct vio_dev *vdev = to_vio_dev(vhost->dev);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&tgt->vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&tgt->vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->discovery_threads >= disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->reinit = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->discovery_threads >= disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->action == IBMVFC_HOST_ACTION_TGT_INIT)
drivers/scsi/ibmvscsi/ibmvfc.c:	else if (vhost->action == IBMVFC_HOST_ACTION_QUERY_TGTS &&
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->discovery_threads >= disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->abort_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->abort_threads >= disc_threads ||
drivers/scsi/ibmvscsi/ibmvfc.c:	    vhost->state != IBMVFC_INITIALIZING ||
drivers/scsi/ibmvscsi/ibmvfc.c:	    vhost->action != IBMVFC_HOST_ACTION_QUERY_TGTS) {
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->abort_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->abort_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->discovery_threads >= disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:	memcpy(&mad->fc_iu.payload[2], &vhost->login_buf->resp.port_name,
drivers/scsi/ibmvscsi/ibmvfc.c:	       sizeof(vhost->login_buf->resp.port_name));
drivers/scsi/ibmvscsi/ibmvfc.c:	memcpy(&mad->fc_iu.payload[4], &vhost->login_buf->resp.node_name,
drivers/scsi/ibmvscsi/ibmvfc.c:	       sizeof(vhost->login_buf->resp.node_name));
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->fc_iu.payload[6] = vhost->login_buf->resp.scsi_id & 0x00ffffff;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->discovery_threads >= disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->discovery_threads++;
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->discovery_threads--;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	tgt = mempool_alloc(vhost->tgt_pool, GFP_NOIO);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Target allocation failure for scsi id %08llx\n",
drivers/scsi/ibmvscsi/ibmvfc.c:	tgt->cancel_key = vhost->task_set++;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_add_tail(&tgt->queue, &vhost->targets);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	for (i = 0, rc = 0; !rc && i < vhost->num_targets; i++)
drivers/scsi/ibmvscsi/ibmvfc.c:					 vhost->disc_buf->scsi_id[i] & IBMVFC_DISC_TGT_SCSI_ID_MASK);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->num_targets = rsp->num_written;
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Invalid Discover Targets response: 0x%x\n", mad_status);
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->bufflen = vhost->disc_buf_sz;
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->buffer.va = vhost->disc_buf_dma;
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->buffer.len = vhost->disc_buf_sz;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_npiv_login_resp *rsp = &vhost->login_buf->resp;
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Invalid NPIV Login response: 0x%x\n", mad_status);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->client_migrated = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Virtual adapter does not support FC. %x\n",
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:		dev_err(vhost->dev, "Virtual adapter supported queue depth too small: %d\n",
drivers/scsi/ibmvscsi/ibmvfc.c:		wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->logged_in = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:	dev_info(vhost->dev, "Host partition: %s, device: %s %s %s max sectors %u\n",
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_fabric_name(vhost->host) = rsp->node_name;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_node_name(vhost->host) = rsp->node_name;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_port_name(vhost->host) = rsp->port_name;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_port_id(vhost->host) = rsp->scsi_id;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_port_type(vhost->host) = FC_PORTTYPE_NPIV;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_supported_classes(vhost->host) = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_supported_classes(vhost->host) |= FC_COS_CLASS1;
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_supported_classes(vhost->host) |= FC_COS_CLASS2;
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_supported_classes(vhost->host) |= FC_COS_CLASS3;
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_host_maxframe_size(vhost->host) =
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->host->can_queue = rsp->max_cmds - IBMVFC_NUM_INTERNAL_REQ;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->host->max_sectors = npiv_max_sectors;
drivers/scsi/ibmvscsi/ibmvfc.c:	wake_up(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	memcpy(vhost->login_buf, &vhost->login_info, sizeof(vhost->login_info));
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->buffer.va = vhost->login_buf_dma;
drivers/scsi/ibmvscsi/ibmvfc.c:	mad->buffer.len = sizeof(*vhost->login_buf);
drivers/scsi/ibmvscsi/ibmvfc.c:		if (list_empty(&vhost->sent) &&
drivers/scsi/ibmvscsi/ibmvfc.c:		    vhost->action == IBMVFC_HOST_ACTION_LOGO_WAIT) {
drivers/scsi/ibmvscsi/ibmvfc.c:	list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:	switch (vhost->action) {
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->discovery_threads == disc_threads)
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_RSCN, 0);
drivers/scsi/ibmvscsi/ibmvfc.c:	    vhost->state >= IBMVFC_HALTED)
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKDOWN, 0);
drivers/scsi/ibmvscsi/ibmvfc.c:	    vhost->state == IBMVFC_INITIALIZING)
drivers/scsi/ibmvscsi/ibmvfc.c:		fc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKUP, 0);
drivers/scsi/ibmvscsi/ibmvfc.c:	rport = fc_remote_port_add(vhost->host, 0, &tgt->ids);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	ibmvfc_log_ae(vhost, vhost->events_to_log);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->events_to_log = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:	switch (vhost->action) {
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->action = IBMVFC_HOST_ACTION_TGT_DEL;
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:			vio_enable_interrupts(to_vio_dev(vhost->dev));
drivers/scsi/ibmvscsi/ibmvfc.c:		    (rc = vio_enable_interrupts(to_vio_dev(vhost->dev)))) {
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev, "Error after reset (rc=%d)\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->action = IBMVFC_HOST_ACTION_TGT_DEL;
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:			dev_err(vhost->dev, "Error after enable (rc=%d)\n", rc);
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->job_step(vhost);
drivers/scsi/ibmvscsi/ibmvfc.c:		BUG_ON(vhost->state != IBMVFC_INITIALIZING);
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->delay_init) {
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->delay_init = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:			spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:			vhost->job_step(vhost);
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue)
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:				spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->state == IBMVFC_INITIALIZING) {
drivers/scsi/ibmvscsi/ibmvfc.c:			if (vhost->action == IBMVFC_HOST_ACTION_TGT_DEL_FAILED) {
drivers/scsi/ibmvscsi/ibmvfc.c:				if (vhost->reinit) {
drivers/scsi/ibmvscsi/ibmvfc.c:					vhost->reinit = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:					scsi_block_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:					spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:					wake_up(&vhost->init_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:					schedule_work(&vhost->rport_add_work_q);
drivers/scsi/ibmvscsi/ibmvfc.c:					vhost->init_retries = 0;
drivers/scsi/ibmvscsi/ibmvfc.c:					spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:					scsi_unblock_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:				vhost->job_step = ibmvfc_discover_targets;
drivers/scsi/ibmvscsi/ibmvfc.c:			spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:			scsi_unblock_requests(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:			wake_up(&vhost->init_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		rc = wait_event_interruptible(vhost->work_wait_q,
drivers/scsi/ibmvscsi/ibmvfc.c:	struct device *dev = vhost->dev;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_crq_queue *crq = &vhost->crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	tasklet_init(&vhost->tasklet, (void *)ibmvfc_tasklet, (unsigned long)vhost);
drivers/scsi/ibmvscsi/ibmvfc.c:	tasklet_kill(&vhost->tasklet);
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_async_crq_queue *async_q = &vhost->async_crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	mempool_destroy(vhost->tgt_pool);
drivers/scsi/ibmvscsi/ibmvfc.c:	kfree(vhost->trace);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_free_coherent(vhost->dev, vhost->disc_buf_sz, vhost->disc_buf,
drivers/scsi/ibmvscsi/ibmvfc.c:			  vhost->disc_buf_dma);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_free_coherent(vhost->dev, sizeof(*vhost->login_buf),
drivers/scsi/ibmvscsi/ibmvfc.c:			  vhost->login_buf, vhost->login_buf_dma);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_pool_destroy(vhost->sg_pool);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_unmap_single(vhost->dev, async_q->msg_token,
drivers/scsi/ibmvscsi/ibmvfc.c:	struct ibmvfc_async_crq_queue *async_q = &vhost->async_crq;
drivers/scsi/ibmvscsi/ibmvfc.c:	struct device *dev = vhost->dev;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->sg_pool = dma_pool_create(IBMVFC_NAME, dev,
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!vhost->sg_pool) {
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->login_buf = dma_alloc_coherent(dev, sizeof(*vhost->login_buf),
drivers/scsi/ibmvscsi/ibmvfc.c:					      &vhost->login_buf_dma, GFP_KERNEL);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!vhost->login_buf) {
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->disc_buf_sz = sizeof(vhost->disc_buf->scsi_id[0]) * max_targets;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->disc_buf = dma_alloc_coherent(dev, vhost->disc_buf_sz,
drivers/scsi/ibmvscsi/ibmvfc.c:					     &vhost->disc_buf_dma, GFP_KERNEL);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!vhost->disc_buf) {
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->trace = kcalloc(IBMVFC_NUM_TRACE_ENTRIES,
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!vhost->trace)
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->tgt_pool = mempool_create_kmalloc_pool(IBMVFC_TGT_MEMPOOL_SZ,
drivers/scsi/ibmvscsi/ibmvfc.c:	if (!vhost->tgt_pool) {
drivers/scsi/ibmvscsi/ibmvfc.c:	kfree(vhost->trace);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_free_coherent(dev, vhost->disc_buf_sz, vhost->disc_buf,
drivers/scsi/ibmvscsi/ibmvfc.c:			  vhost->disc_buf_dma);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_free_coherent(dev, sizeof(*vhost->login_buf),
drivers/scsi/ibmvscsi/ibmvfc.c:			  vhost->login_buf, vhost->login_buf_dma);
drivers/scsi/ibmvscsi/ibmvfc.c:	dma_pool_destroy(vhost->sg_pool);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:		if (vhost->state != IBMVFC_ACTIVE)
drivers/scsi/ibmvscsi/ibmvfc.c:		list_for_each_entry(tgt, &vhost->targets, queue) {
drivers/scsi/ibmvscsi/ibmvfc.c:					spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:					spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:				spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (vhost->state == IBMVFC_ACTIVE)
drivers/scsi/ibmvscsi/ibmvfc.c:		vhost->scan_complete = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->transportt = ibmvfc_transport_template;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->can_queue = max_requests;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->max_lun = max_lun;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->max_id = max_targets;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->max_sectors = IBMVFC_MAX_SECTORS;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->max_cmd_len = IBMVFC_MAX_CDB_LEN;
drivers/scsi/ibmvscsi/ibmvfc.c:	shost->unique_id = shost->host_no;
drivers/scsi/ibmvscsi/ibmvfc.c:	INIT_LIST_HEAD(&vhost->sent);
drivers/scsi/ibmvscsi/ibmvfc.c:	INIT_LIST_HEAD(&vhost->free);
drivers/scsi/ibmvscsi/ibmvfc.c:	INIT_LIST_HEAD(&vhost->targets);
drivers/scsi/ibmvscsi/ibmvfc.c:	sprintf(vhost->name, IBMVFC_NAME);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->host = shost;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->dev = dev;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->partition_number = -1;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->log_level = log_level;
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->task_set = 1;
drivers/scsi/ibmvscsi/ibmvfc.c:	strcpy(vhost->partition_name, "UNKNOWN");
drivers/scsi/ibmvscsi/ibmvfc.c:	init_waitqueue_head(&vhost->work_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	init_waitqueue_head(&vhost->init_wait_q);
drivers/scsi/ibmvscsi/ibmvfc.c:	INIT_WORK(&vhost->rport_add_work_q, ibmvfc_rport_add_thread);
drivers/scsi/ibmvscsi/ibmvfc.c:	mutex_init(&vhost->passthru_mutex);
drivers/scsi/ibmvscsi/ibmvfc.c:	vhost->work_thread = kthread_run(ibmvfc_work, vhost, "%s_%d", IBMVFC_NAME,
drivers/scsi/ibmvscsi/ibmvfc.c:					 shost->host_no);
drivers/scsi/ibmvscsi/ibmvfc.c:	if (IS_ERR(vhost->work_thread)) {
drivers/scsi/ibmvscsi/ibmvfc.c:			PTR_ERR(vhost->work_thread));
drivers/scsi/ibmvscsi/ibmvfc.c:	if ((rc = ibmvfc_create_trace_file(&shost->shost_dev.kobj,
drivers/scsi/ibmvscsi/ibmvfc.c:	list_add_tail(&vhost->queue, &ibmvfc_head);
drivers/scsi/ibmvscsi/ibmvfc.c:	kthread_stop(vhost->work_thread);
drivers/scsi/ibmvscsi/ibmvfc.c:	ibmvfc_remove_trace_file(&vhost->host->shost_dev.kobj, &ibmvfc_trace_attr);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	kthread_stop(vhost->work_thread);
drivers/scsi/ibmvscsi/ibmvfc.c:	fc_remove_host(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:	scsi_remove_host(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	list_del(&vhost->queue);
drivers/scsi/ibmvscsi/ibmvfc.c:	scsi_host_put(vhost->host);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_lock_irqsave(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.c:	tasklet_schedule(&vhost->tasklet);
drivers/scsi/ibmvscsi/ibmvfc.c:	spin_unlock_irqrestore(vhost->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvfc.h:	DBG_CMD(dev_info((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__))
drivers/scsi/ibmvscsi/ibmvfc.h:	dev_info((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
drivers/scsi/ibmvscsi/ibmvfc.h:	dev_err((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
drivers/scsi/ibmvscsi/ibmvfc.h:		if ((t)->vhost->log_level >= level) \
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	strncpy(hostdata->caps.name, dev_name(&hostdata->host->shost_gendev),
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:			hostdata->host->max_sectors = 
drivers/scsi/ibmvscsi/ibmvscsi.c:			hostdata->host->sg_tablesize = MAX_INDIRECT_BUFS;
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:			spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:			spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:			spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:		spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(evt_struct->hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(evt_struct->hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(hostdata->host->host_lock, flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_lock_irqsave(shost->host_lock, lock_flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	scsi_adjust_queue_depth(sdev, 0, shost->cmd_per_lun);
drivers/scsi/ibmvscsi/ibmvscsi.c:	spin_unlock_irqrestore(shost->host_lock, lock_flags);
drivers/scsi/ibmvscsi/ibmvscsi.c:	host->transportt = ibmvscsi_transport_template;
drivers/scsi/ibmvscsi/ibmvscsi.c:	hostdata->host->max_sectors = IBMVSCSI_MAX_SECTORS_DEFAULT;
drivers/scsi/ibmvscsi/ibmvscsi.c:					    "ibmvscsi", host->host_no);
drivers/scsi/ibmvscsi/ibmvscsi.c:	host->max_lun = 8;
drivers/scsi/ibmvscsi/ibmvscsi.c:	host->max_id = max_id;
drivers/scsi/ibmvscsi/ibmvscsi.c:	host->max_channel = max_channel;
drivers/scsi/ibmvscsi/ibmvscsi.c:	host->max_cmd_len = 16;
drivers/scsi/ibmvscsi/ibmvstgt.c:	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
drivers/scsi/ibmvscsi/ibmvstgt.c:	shost->transportt = ibmvstgt_transport_template;
drivers/scsi/imm.c:	return *(imm_struct **)&host->hostdata;
drivers/scsi/imm.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/imm.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/imm.c:	host->io_port = pb->base;
drivers/scsi/imm.c:	host->n_io_port = ports;
drivers/scsi/imm.c:	host->dma_channel = -1;
drivers/scsi/imm.c:	host->unique_id = pb->number;
drivers/scsi/imm.c:	*(imm_struct **)&host->hostdata = dev;
drivers/scsi/in2000.c:	hostdata = (struct IN2000_hostdata *) cmd->device->host->hostdata;
drivers/scsi/in2000.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/in2000.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/in2000.c:	if (shost->irq)
drivers/scsi/in2000.c:		free_irq(shost->irq, shost);
drivers/scsi/in2000.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/in2000.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/in2000.h:# define CLISPIN_LOCK(host,flags)   spin_lock_irqsave(host->host_lock, flags)
drivers/scsi/in2000.h:# define CLISPIN_UNLOCK(host,flags) spin_unlock_irqrestore(host->host_lock, \
drivers/scsi/initio.c:	if (inb(host->addr + TUL_XStatus) & XPEND) {	/* if DMA xfer is pending, abort DMA xfer */
drivers/scsi/initio.c:		outb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);
drivers/scsi/initio.c:		while ((inb(host->addr + TUL_Int) & XABT) == 0)
drivers/scsi/initio.c:	outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	outb(TSC_RST_BUS, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	while (!((host->jsint = inb(host->addr + TUL_SInt)) & TSS_SCSIRST_INT))
drivers/scsi/initio.c:	outb(0, host->addr + TUL_SSignal);
drivers/scsi/initio.c:	inb(host->addr + TUL_SInt);
drivers/scsi/initio.c:	initio_read_eeprom(host->addr);
drivers/scsi/initio.c:		host->max_tar = 8;
drivers/scsi/initio.c:		host->max_tar = 16;
drivers/scsi/initio.c:	host->config = i91unvramp->NVM_SCSIInfo[0].NVM_ChConfig1;
drivers/scsi/initio.c:	host->scsi_id = i91unvramp->NVM_SCSIInfo[0].NVM_ChSCSIID;
drivers/scsi/initio.c:	host->idmask = ~(1 << host->scsi_id);
drivers/scsi/initio.c:	outb(inb(host->addr + TUL_PCMD) | 0x40, host->addr + TUL_PCMD);
drivers/scsi/initio.c:	outb(0x1F, host->addr + TUL_Mask);
drivers/scsi/initio.c:	outb(TSC_RST_CHIP, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	outb(host->scsi_id << 4, host->addr + TUL_SScsiId);
drivers/scsi/initio.c:	if (host->config & HCC_EN_PAR)
drivers/scsi/initio.c:		host->sconf1 = (TSC_INITDEFAULT | TSC_EN_SCSI_PAR);
drivers/scsi/initio.c:		host->sconf1 = (TSC_INITDEFAULT);
drivers/scsi/initio.c:	outb(host->sconf1, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);
drivers/scsi/initio.c:	outb(0, host->addr + TUL_SPeriod);
drivers/scsi/initio.c:	outb(153, host->addr + TUL_STimeOut);
drivers/scsi/initio.c:	outb((host->config & (HCC_ACT_TERM1 | HCC_ACT_TERM2)),
drivers/scsi/initio.c:		host->addr + TUL_XCtrl);
drivers/scsi/initio.c:	outb(((host->config & HCC_AUTO_TERM) >> 4) |
drivers/scsi/initio.c:		(inb(host->addr + TUL_GCTRL1) & 0xFE),
drivers/scsi/initio.c:		host->addr + TUL_GCTRL1);
drivers/scsi/initio.c:	     i < host->max_tar;
drivers/scsi/initio.c:		host->targets[i].flags = *flags & ~(TCF_SYNC_DONE | TCF_WDTR_DONE);
drivers/scsi/initio.c:		if (host->targets[i].flags & TCF_EN_255)
drivers/scsi/initio.c:			host->targets[i].drv_flags = TCF_DRV_255_63;
drivers/scsi/initio.c:			host->targets[i].drv_flags = 0;
drivers/scsi/initio.c:		host->targets[i].js_period = 0;
drivers/scsi/initio.c:		host->targets[i].sconfig0 = host->sconf1;
drivers/scsi/initio.c:		host->targets[i].heads = *heads++;
drivers/scsi/initio.c:		if (host->targets[i].heads == 255)
drivers/scsi/initio.c:			host->targets[i].drv_flags = TCF_DRV_255_63;
drivers/scsi/initio.c:			host->targets[i].drv_flags = 0;
drivers/scsi/initio.c:		host->targets[i].sectors = *heads++;
drivers/scsi/initio.c:		host->targets[i].flags &= ~TCF_BUSY;
drivers/scsi/initio.c:		host->act_tags[i] = 0;
drivers/scsi/initio.c:		host->max_tags[i] = 0xFF;
drivers/scsi/initio.c:	       host->addr, host->pci_dev->irq,
drivers/scsi/initio.c:	       host->bios_addr, host->scsi_id);
drivers/scsi/initio.c:	if (host->config & HCC_SCSI_RESET) {
drivers/scsi/initio.c:	outb(0x17, host->addr + TUL_SCFG1);
drivers/scsi/initio.c:	outb(0xE9, host->addr + TUL_SIntEnable);
drivers/scsi/initio.c:	spin_lock_irqsave(&host->avail_lock, flags);
drivers/scsi/initio.c:	if ((scb = host->first_avail) != NULL) {
drivers/scsi/initio.c:		if ((host->first_avail = scb->next) == NULL)
drivers/scsi/initio.c:			host->last_avail = NULL;
drivers/scsi/initio.c:	spin_unlock_irqrestore(&host->avail_lock, flags);
drivers/scsi/initio.c:	spin_lock_irqsave(&(host->avail_lock), flags);
drivers/scsi/initio.c:	if (host->last_avail != NULL) {
drivers/scsi/initio.c:		host->last_avail->next = cmnd;
drivers/scsi/initio.c:		host->last_avail = cmnd;
drivers/scsi/initio.c:		host->first_avail = cmnd;
drivers/scsi/initio.c:		host->last_avail = cmnd;
drivers/scsi/initio.c:	spin_unlock_irqrestore(&(host->avail_lock), flags);
drivers/scsi/initio.c:	if (host->last_pending != NULL) {
drivers/scsi/initio.c:		host->last_pending->next = scbp;
drivers/scsi/initio.c:		host->last_pending = scbp;
drivers/scsi/initio.c:		host->first_pending = scbp;
drivers/scsi/initio.c:		host->last_pending = scbp;
drivers/scsi/initio.c:	if ((scbp->next = host->first_pending) != NULL) {
drivers/scsi/initio.c:		host->first_pending = scbp;
drivers/scsi/initio.c:		host->first_pending = scbp;
drivers/scsi/initio.c:		host->last_pending = scbp;
drivers/scsi/initio.c:	first = host->first_pending;
drivers/scsi/initio.c:			if ((host->act_tags[first->target] == 0) &&
drivers/scsi/initio.c:			    !(host->targets[first->target].flags & TCF_BUSY))
drivers/scsi/initio.c:			if ((host->act_tags[first->target] >=
drivers/scsi/initio.c:			  host->max_tags[first->target]) |
drivers/scsi/initio.c:			    (host->targets[first->target].flags & TCF_BUSY)) {
drivers/scsi/initio.c:	prev = tmp = host->first_pending;
drivers/scsi/initio.c:			if (tmp == host->first_pending) {
drivers/scsi/initio.c:				if ((host->first_pending = tmp->next) == NULL)
drivers/scsi/initio.c:					host->last_pending = NULL;
drivers/scsi/initio.c:				if (tmp == host->last_pending)
drivers/scsi/initio.c:					host->last_pending = prev;
drivers/scsi/initio.c:		host->act_tags[scbp->target]++;
drivers/scsi/initio.c:		host->targets[scbp->target].flags |= TCF_BUSY;
drivers/scsi/initio.c:	if (host->last_busy != NULL) {
drivers/scsi/initio.c:		host->last_busy->next = scbp;
drivers/scsi/initio.c:		host->last_busy = scbp;
drivers/scsi/initio.c:		host->first_busy = scbp;
drivers/scsi/initio.c:		host->last_busy = scbp;
drivers/scsi/initio.c:	if ((tmp = host->first_busy) != NULL) {
drivers/scsi/initio.c:		if ((host->first_busy = tmp->next) == NULL)
drivers/scsi/initio.c:			host->last_busy = NULL;
drivers/scsi/initio.c:			host->act_tags[tmp->target]--;
drivers/scsi/initio.c:			host->targets[tmp->target].flags &= ~TCF_BUSY;
drivers/scsi/initio.c:	prev = tmp = host->first_busy;
drivers/scsi/initio.c:			if (tmp == host->first_busy) {
drivers/scsi/initio.c:				if ((host->first_busy = tmp->next) == NULL)
drivers/scsi/initio.c:					host->last_busy = NULL;
drivers/scsi/initio.c:				if (tmp == host->last_busy)
drivers/scsi/initio.c:					host->last_busy = prev;
drivers/scsi/initio.c:				host->act_tags[tmp->target]--;
drivers/scsi/initio.c:				host->targets[tmp->target].flags &= ~TCF_BUSY;
drivers/scsi/initio.c:	prev = tmp = host->first_busy;
drivers/scsi/initio.c:	if (host->last_done != NULL) {
drivers/scsi/initio.c:		host->last_done->next = scbp;
drivers/scsi/initio.c:		host->last_done = scbp;
drivers/scsi/initio.c:		host->first_done = scbp;
drivers/scsi/initio.c:		host->last_done = scbp;
drivers/scsi/initio.c:	if ((tmp = host->first_done) != NULL) {
drivers/scsi/initio.c:		if ((host->first_done = tmp->next) == NULL)
drivers/scsi/initio.c:			host->last_done = NULL;
drivers/scsi/initio.c:	spin_lock_irqsave(&host->semaph_lock, flags);
drivers/scsi/initio.c:	if ((host->semaph == 0) && (host->active == NULL)) {
drivers/scsi/initio.c:		outb(0x1F, host->addr + TUL_Mask);
drivers/scsi/initio.c:		spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:		spin_lock_irqsave(&host->semaph_lock, flags);
drivers/scsi/initio.c:		host->semaph = 1;
drivers/scsi/initio.c:		outb(0x0F, host->addr + TUL_Mask);
drivers/scsi/initio.c:		spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:	prev = tmp = host->first_pending;	/* Check Pend queue */
drivers/scsi/initio.c:			if (tmp == host->active) {
drivers/scsi/initio.c:				spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:			} else if (tmp == host->first_pending) {
drivers/scsi/initio.c:				if ((host->first_pending = tmp->next) == NULL)
drivers/scsi/initio.c:					host->last_pending = NULL;
drivers/scsi/initio.c:				if (tmp == host->last_pending)
drivers/scsi/initio.c:					host->last_pending = prev;
drivers/scsi/initio.c:			spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:	prev = tmp = host->first_busy;	/* Check Busy queue */
drivers/scsi/initio.c:			if (tmp == host->active) {
drivers/scsi/initio.c:				spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:				spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:				host->act_tags[tmp->target]--;
drivers/scsi/initio.c:				if (tmp == host->first_busy) {
drivers/scsi/initio.c:					if ((host->first_busy = tmp->next) == NULL)
drivers/scsi/initio.c:						host->last_busy = NULL;
drivers/scsi/initio.c:					if (tmp == host->last_busy)
drivers/scsi/initio.c:						host->last_busy = prev;
drivers/scsi/initio.c:				spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:	spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:	printk("initio_bad_seg c=%d\n", host->index);
drivers/scsi/initio.c:	if ((scb = host->active) != NULL) {
drivers/scsi/initio.c:	spin_lock_irqsave(&host->semaph_lock, flags);
drivers/scsi/initio.c:	if (host->semaph == 1) {
drivers/scsi/initio.c:		outb(0x1F, host->addr + TUL_Mask);
drivers/scsi/initio.c:		host->semaph = 0;
drivers/scsi/initio.c:		spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:		spin_lock_irqsave(&host->semaph_lock, flags);
drivers/scsi/initio.c:		host->semaph = 1;
drivers/scsi/initio.c:		outb(0x0F, host->addr + TUL_Mask);
drivers/scsi/initio.c:	spin_unlock_irqrestore(&host->semaph_lock, flags);
drivers/scsi/initio.c:	if (inb(host->addr + TUL_Int) & TSS_INT_PENDING) {
drivers/scsi/initio.c:		if (host->semaph == 1) {
drivers/scsi/initio.c:			outb(0x1F, host->addr + TUL_Mask);
drivers/scsi/initio.c:			host->semaph = 0;
drivers/scsi/initio.c:			host->semaph = 1;
drivers/scsi/initio.c:			outb(0x0F, host->addr + TUL_Mask);
drivers/scsi/initio.c:				host->max_tags[scb->target] =
drivers/scsi/initio.c:				    host->act_tags[scb->target] - 1;
drivers/scsi/initio.c:		if (inb(host->addr + TUL_SStatus0) & TSS_INT_PENDING)
drivers/scsi/initio.c:		if (host->active)	/* return to OS and wait for xfer_done_ISR/Selected_ISR */
drivers/scsi/initio.c:	if ((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING) {
drivers/scsi/initio.c:		host->phase = host->jsstatus0 & TSS_PH_MASK;
drivers/scsi/initio.c:		host->jsstatus1 = inb(host->addr + TUL_SStatus1);
drivers/scsi/initio.c:		host->jsint = inb(host->addr + TUL_SInt);
drivers/scsi/initio.c:		if (host->jsint & TSS_SCSIRST_INT) {	/* SCSI bus reset detected      */
drivers/scsi/initio.c:		if (host->jsint & TSS_RESEL_INT) {	/* if selected/reselected interrupt */
drivers/scsi/initio.c:		if (host->jsint & TSS_SEL_TIMEOUT) {
drivers/scsi/initio.c:		if (host->jsint & TSS_DISC_INT) {	/* BUS disconnection            */
drivers/scsi/initio.c:		if (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV)) {	/* func complete or Bus service */
drivers/scsi/initio.c:			if ((scb = host->active) != NULL)
drivers/scsi/initio.c:	if (host->active != NULL)
drivers/scsi/initio.c:	outb((host->scsi_id << 4) | (scb->target & 0x0F),
drivers/scsi/initio.c:		host->addr + TUL_SScsiId);
drivers/scsi/initio.c:		active_tc = &host->targets[scb->target];
drivers/scsi/initio.c:		outb(active_tc->js_period, host->addr + TUL_SPeriod);
drivers/scsi/initio.c:	next = host->active->next_state;
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:	outb(active_tc->sconfig0, host->addr + TUL_SConfig );
drivers/scsi/initio.c:	if (host->phase == MSG_OUT) {
drivers/scsi/initio.c:		outb(TSC_EN_BUS_IN | TSC_HW_RESELECT, host->addr + TUL_SCtrl1);
drivers/scsi/initio.c:		outb(scb->ident, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(scb->tagmsg, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(scb->tagid, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(MSG_EXTEND, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(2, host->addr + TUL_SFifo);	/* Extended msg length */
drivers/scsi/initio.c:			outb(3, host->addr + TUL_SFifo);	/* Sync request */
drivers/scsi/initio.c:			outb(1, host->addr + TUL_SFifo);	/* Start from 16 bits */
drivers/scsi/initio.c:			outb(MSG_EXTEND, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(3, host->addr + TUL_SFifo);	/* extended msg length */
drivers/scsi/initio.c:			outb(1, host->addr + TUL_SFifo);	/* sync request */
drivers/scsi/initio.c:			outb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(MAX_OFFSET, host->addr + TUL_SFifo);	/* REQ/ACK offset */
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	outb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:	outb(active_tc->sconfig0, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	if (host->jsstatus1 & TSS_CMD_PH_CMP)
drivers/scsi/initio.c:	outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	outb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:		switch (host->phase) {
drivers/scsi/initio.c:				outb(scb->cdb[i], host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:			if (host->phase == CMD_OUT)
drivers/scsi/initio.c:				outb(MSG_NOP, host->addr + TUL_SFifo);		/* msg nop */
drivers/scsi/initio.c:				outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:				outb(MSG_EXTEND, host->addr + TUL_SFifo);
drivers/scsi/initio.c:				outb(3, host->addr + TUL_SFifo);	/* ext. msg len */
drivers/scsi/initio.c:				outb(1, host->addr + TUL_SFifo);	/* sync request */
drivers/scsi/initio.c:				outb(initio_rate_tbl[active_tc->flags & TCF_SCSI_RATE], host->addr + TUL_SFifo);
drivers/scsi/initio.c:				outb(MAX_OFFSET, host->addr + TUL_SFifo);	/* REQ/ACK offset */
drivers/scsi/initio.c:				outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:				outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:				outb(inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:		switch (host->phase) {
drivers/scsi/initio.c:			if (host->jsstatus0 & TSS_PAR_ERROR) {
drivers/scsi/initio.c:				outb(MSG_NOP, host->addr + TUL_SFifo);		/* msg nop */
drivers/scsi/initio.c:				outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	cnt = inl(host->addr + TUL_SCnt0) & 0x0FFFFFF;
drivers/scsi/initio.c:	if (inb(host->addr + TUL_XCmd) & 0x20) {
drivers/scsi/initio.c:		if (host->jsstatus0 & TSS_PAR_ERROR)
drivers/scsi/initio.c:		if (inb(host->addr + TUL_XStatus) & XPEND) {	/* DMA xfer pending, Send STOP  */
drivers/scsi/initio.c:			outb(inb(host->addr + TUL_XCtrl) | 0x80, host->addr + TUL_XCtrl);
drivers/scsi/initio.c:			while (inb(host->addr + TUL_XStatus) & XPEND)
drivers/scsi/initio.c:		if ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0) {
drivers/scsi/initio.c:			if (host->active_tc->js_period & TSC_WIDE_SCSI)
drivers/scsi/initio.c:				cnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F) << 1;
drivers/scsi/initio.c:				cnt += (inb(host->addr + TUL_SFifoCnt) & 0x1F);
drivers/scsi/initio.c:		if (inb(host->addr + TUL_XStatus) & XPEND) {	/* if DMA xfer is pending, abort DMA xfer */
drivers/scsi/initio.c:			outb(TAX_X_ABT, host->addr + TUL_XCmd);
drivers/scsi/initio.c:			while ((inb(host->addr + TUL_Int) & XABT) == 0)
drivers/scsi/initio.c:		if ((cnt == 1) && (host->phase == DATA_OUT)) {
drivers/scsi/initio.c:			outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:			if ((inb(host->addr + TUL_SStatus1) & TSS_XFER_CMP) == 0)
drivers/scsi/initio.c:				outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:		switch (host->phase) {
drivers/scsi/initio.c:			outb(MSG_NOP, host->addr + TUL_SFifo);		/* msg nop */
drivers/scsi/initio.c:			outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	cnt = inb(host->addr + TUL_SFifoCnt) & 0x1F;
drivers/scsi/initio.c:			inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:	switch (host->phase) {
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	outl(scb->buflen, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:	outb(TSC_XF_DMA_IN, host->addr + TUL_SCmd);	/* 7/25/95 */
drivers/scsi/initio.c:		outl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);
drivers/scsi/initio.c:		outl(scb->bufptr, host->addr + TUL_XAddH);
drivers/scsi/initio.c:		outb(TAX_SG_IN, host->addr + TUL_XCmd);
drivers/scsi/initio.c:		outl(scb->buflen, host->addr + TUL_XCntH);
drivers/scsi/initio.c:		outl(scb->bufptr, host->addr + TUL_XAddH);
drivers/scsi/initio.c:		outb(TAX_X_IN, host->addr + TUL_XCmd);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	outl(scb->buflen, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:	outb(TSC_XF_DMA_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		outl(((u32) scb->sglen) << 3, host->addr + TUL_XCntH);
drivers/scsi/initio.c:		outl(scb->bufptr, host->addr + TUL_XAddH);
drivers/scsi/initio.c:		outb(TAX_SG_OUT, host->addr + TUL_XCmd);
drivers/scsi/initio.c:		outl(scb->buflen, host->addr + TUL_XCntH);
drivers/scsi/initio.c:		outl(scb->bufptr, host->addr + TUL_XAddH);
drivers/scsi/initio.c:		outb(TAX_X_OUT, host->addr + TUL_XCmd);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:			outl(2, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:			outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		if (host->phase != DATA_IN) {
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:		inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:			outl(2, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:			outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(0, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		if (host->phase != DATA_OUT) {	/* Disable wide CPU to allow read 16 bits */
drivers/scsi/initio.c:			outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	outb(TSC_CMD_COMP, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	scb->tastat = inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:	if (host->phase == MSG_OUT) {
drivers/scsi/initio.c:		if (host->jsstatus0 & TSS_PAR_ERROR)
drivers/scsi/initio.c:			outb(MSG_PARITY, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(MSG_NOP, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	if (host->phase == MSG_IN) {
drivers/scsi/initio.c:		msg = inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:		if (host->jsstatus0 & TSS_PAR_ERROR) {	/* Parity error                 */
drivers/scsi/initio.c:			if (host->phase != MSG_OUT)
drivers/scsi/initio.c:			outb(MSG_PARITY, host->addr + TUL_SFifo);
drivers/scsi/initio.c:			outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:			outb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:		host->active = NULL;
drivers/scsi/initio.c:		host->active_tc = NULL;
drivers/scsi/initio.c:	outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);		/* Flush SCSI FIFO  */
drivers/scsi/initio.c:	outb(TSC_INITDEFAULT, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);	/* Enable HW reselect       */
drivers/scsi/initio.c:	if (inb(host->addr + TUL_XStatus) & 0x01) {
drivers/scsi/initio.c:		outb(TAX_X_ABT | TAX_X_CLR_FIFO, host->addr + TUL_XCmd);
drivers/scsi/initio.c:		while ((inb(host->addr + TUL_Int) & 0x04) == 0)
drivers/scsi/initio.c:		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:	host->active = NULL;
drivers/scsi/initio.c:	host->active_tc = NULL;
drivers/scsi/initio.c:	for (i = 0; i < host->max_tar; i++)
drivers/scsi/initio.c:		host->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);
drivers/scsi/initio.c:	if ((scb = host->active) != NULL) {
drivers/scsi/initio.c:		host->active = NULL;
drivers/scsi/initio.c:	tar = inb(host->addr + TUL_SBusId);
drivers/scsi/initio.c:	lun = inb(host->addr + TUL_SIdent) & 0x0F;
drivers/scsi/initio.c:	active_tc = &host->targets[tar];
drivers/scsi/initio.c:	host->active_tc = active_tc;
drivers/scsi/initio.c:	outb(active_tc->sconfig0, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	outb(active_tc->js_period, host->addr + TUL_SPeriod);
drivers/scsi/initio.c:		if (host->phase != MSG_IN)
drivers/scsi/initio.c:		outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		msg = inb(host->addr + TUL_SFifo);	/* Read Tag Message    */
drivers/scsi/initio.c:		if (host->phase != MSG_IN)
drivers/scsi/initio.c:		outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		tag = inb(host->addr + TUL_SFifo);	/* Read Tag ID       */
drivers/scsi/initio.c:		scb = host->scb + tag;
drivers/scsi/initio.c:		host->active = scb;
drivers/scsi/initio.c:		host->active = scb;
drivers/scsi/initio.c:	for (i = 0; i < host->max_tar; i++)
drivers/scsi/initio.c:		host->targets[i].flags &= ~(TCF_SYNC_DONE | TCF_WDTR_DONE);
drivers/scsi/initio.c:	outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	if (host->phase != MSG_OUT)
drivers/scsi/initio.c:	outb(MSG_ABORT, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	if (host->phase != MSG_OUT)
drivers/scsi/initio.c:	outb(MSG_ABORT_TAG, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:		outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		switch (inb(host->addr + TUL_SFifo)) {
drivers/scsi/initio.c:			outb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:			outb((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)),
drivers/scsi/initio.c:				host->addr + TUL_SSignal);
drivers/scsi/initio.c:			active_tc = host->active_tc;
drivers/scsi/initio.c:				outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN),
drivers/scsi/initio.c:					host->addr + TUL_SSignal);
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:			outb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		if (host->phase != MSG_IN)
drivers/scsi/initio.c:			return host->phase;
drivers/scsi/initio.c:	outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	if (host->phase == MSG_OUT) {
drivers/scsi/initio.c:		outb(MSG_REJ, host->addr + TUL_SFifo);		/* Msg reject           */
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	return host->phase;
drivers/scsi/initio.c:	outb(MSG_IDE, host->addr + TUL_SFifo);		/* Initiator Detected Error */
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		return host->phase;
drivers/scsi/initio.c:	outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	len = inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:	host->msg[0] = len;
drivers/scsi/initio.c:			return host->phase;
drivers/scsi/initio.c:		outl(1, host->addr + TUL_SCnt0);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_IN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:		host->msg[idx++] = inb(host->addr + TUL_SFifo);
drivers/scsi/initio.c:	if (host->msg[1] == 1) {		/* if it's synchronous data transfer request */
drivers/scsi/initio.c:		if (host->msg[0] != 3)	/* if length is not right */
drivers/scsi/initio.c:		if (host->active_tc->flags & TCF_NO_SYNC_NEGO) {	/* Set OFFSET=0 to do async, nego back */
drivers/scsi/initio.c:			host->msg[3] = 0;
drivers/scsi/initio.c:			    (host->active_tc->flags & TCF_SYNC_DONE)) {
drivers/scsi/initio.c:		r = inb(host->addr + TUL_SSignal);
drivers/scsi/initio.c:			host->addr + TUL_SSignal);
drivers/scsi/initio.c:			return host->phase;
drivers/scsi/initio.c:		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);
drivers/scsi/initio.c:		outb(MSG_EXTEND, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(3, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(1, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(host->msg[2], host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(host->msg[3], host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	if (host->msg[0] != 2 || host->msg[1] != 3)
drivers/scsi/initio.c:	if (host->active_tc->flags & TCF_NO_WDTR) {
drivers/scsi/initio.c:		host->msg[2] = 0;
drivers/scsi/initio.c:		if (host->msg[2] > 2)	/* > 32 bits            */
drivers/scsi/initio.c:		if (host->msg[2] == 2) {		/* == 32                */
drivers/scsi/initio.c:			host->msg[2] = 1;
drivers/scsi/initio.c:			if ((host->active_tc->flags & TCF_NO_WDTR) == 0) {
drivers/scsi/initio.c:				if ((host->active_tc->flags & (TCF_SYNC_DONE | TCF_NO_SYNC_NEGO)) == 0)
drivers/scsi/initio.c:					outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);
drivers/scsi/initio.c:	outb(((inb(host->addr + TUL_SSignal) & (TSC_SET_ACK | 7)) | TSC_SET_ATN), host->addr + TUL_SSignal);
drivers/scsi/initio.c:		return host->phase;
drivers/scsi/initio.c:	outb(MSG_EXTEND, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(2, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(3, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(host->msg[2], host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	default_period = initio_rate_tbl[host->active_tc->flags & TCF_SCSI_RATE];
drivers/scsi/initio.c:	if (host->msg[3] > MAX_OFFSET) {
drivers/scsi/initio.c:		host->msg[3] = MAX_OFFSET;
drivers/scsi/initio.c:		if (host->msg[2] < default_period) {
drivers/scsi/initio.c:			host->msg[2] = default_period;
drivers/scsi/initio.c:		if (host->msg[2] >= 59)	/* Change to async              */
drivers/scsi/initio.c:			host->msg[3] = 0;
drivers/scsi/initio.c:	if (host->msg[3] == 0) {
drivers/scsi/initio.c:	if (host->msg[2] < default_period) {
drivers/scsi/initio.c:		host->msg[2] = default_period;
drivers/scsi/initio.c:	if (host->msg[2] >= 59) {
drivers/scsi/initio.c:		host->msg[3] = 0;
drivers/scsi/initio.c:	host->active_tc->flags &= ~TCF_SYNC_DONE;
drivers/scsi/initio.c:	host->active_tc->flags |= TCF_WDTR_DONE;
drivers/scsi/initio.c:	host->active_tc->js_period = 0;
drivers/scsi/initio.c:	if (host->msg[2])	/* if 16 bit */
drivers/scsi/initio.c:		host->active_tc->js_period |= TSC_WIDE_SCSI;
drivers/scsi/initio.c:	host->active_tc->sconfig0 &= ~TSC_ALT_PERIOD;
drivers/scsi/initio.c:	outb(host->active_tc->sconfig0, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	outb(host->active_tc->js_period, host->addr + TUL_SPeriod);
drivers/scsi/initio.c:	host->active_tc->flags |= TCF_SYNC_DONE;
drivers/scsi/initio.c:	if (host->msg[3]) {
drivers/scsi/initio.c:		host->active_tc->js_period |= host->msg[3];
drivers/scsi/initio.c:			if (initio_rate_tbl[i] >= host->msg[2])	/* pick the big one */
drivers/scsi/initio.c:		host->active_tc->js_period |= (i << 4);
drivers/scsi/initio.c:		host->active_tc->sconfig0 |= TSC_ALT_PERIOD;
drivers/scsi/initio.c:	outb(host->active_tc->sconfig0, host->addr + TUL_SConfig);
drivers/scsi/initio.c:	outb(host->active_tc->js_period, host->addr + TUL_SPeriod);
drivers/scsi/initio.c:	host->active = NULL;
drivers/scsi/initio.c:	host->active_tc = NULL;
drivers/scsi/initio.c:	host->flags = 0;
drivers/scsi/initio.c:	active_tc = &host->targets[0];
drivers/scsi/initio.c:	for (i = 0; i < host->max_tar; active_tc++, i++) {
drivers/scsi/initio.c:		active_tc->sconfig0 = host->sconf1;
drivers/scsi/initio.c:		host->act_tags[0] = 0;	/* 07/22/98 */
drivers/scsi/initio.c:		host->targets[i].flags &= ~TCF_BUSY;	/* 07/22/98 */
drivers/scsi/initio.c:	host->active = scb;
drivers/scsi/initio.c:	host->active_tc = &host->targets[scb->target];
drivers/scsi/initio.c:	outb(TSC_SELATNSTOP, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	outb(scb->ident, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(scb->cdb[i], host->addr + TUL_SFifo);
drivers/scsi/initio.c:	host->active_tc = &host->targets[scb->target];
drivers/scsi/initio.c:	host->active = scb;
drivers/scsi/initio.c:	outb(TSC_SEL_ATN, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	outb(scb->ident, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(scb->tagmsg, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(scb->tagid, host->addr + TUL_SFifo);
drivers/scsi/initio.c:		outb(scb->cdb[i], host->addr + TUL_SFifo);
drivers/scsi/initio.c:	host->active_tc = &host->targets[scb->target];
drivers/scsi/initio.c:	host->active = scb;
drivers/scsi/initio.c:	outb(TSC_SEL_ATN3, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	struct scsi_ctrl_blk *scb = host->active;
drivers/scsi/initio.c:	struct target_control *active_tc = host->active_tc;
drivers/scsi/initio.c:	if (host->phase != MSG_OUT)
drivers/scsi/initio.c:	prev = tmp = host->first_busy;	/* Check Busy queue */
drivers/scsi/initio.c:			if (tmp == host->first_busy) {
drivers/scsi/initio.c:				if ((host->first_busy = tmp->next) == NULL)
drivers/scsi/initio.c:					host->last_busy = NULL;
drivers/scsi/initio.c:				if (tmp == host->last_busy)
drivers/scsi/initio.c:					host->last_busy = prev;
drivers/scsi/initio.c:	outb(MSG_DEVRST, host->addr + TUL_SFifo);
drivers/scsi/initio.c:	outb(TSC_XF_FIFO_OUT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	outb(TSC_MSG_ACCEPT, host->addr + TUL_SCmd);
drivers/scsi/initio.c:	while (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))
drivers/scsi/initio.c:	host->jsint = inb(host->addr + TUL_SInt);
drivers/scsi/initio.c:	host->phase = host->jsstatus0 & TSS_PH_MASK;
drivers/scsi/initio.c:	host->jsstatus1 = inb(host->addr + TUL_SStatus1);
drivers/scsi/initio.c:	if (host->jsint & TSS_RESEL_INT)	/* if SCSI bus reset detected */
drivers/scsi/initio.c:	if (host->jsint & TSS_SEL_TIMEOUT)	/* if selected/reselected timeout interrupt */
drivers/scsi/initio.c:	if (host->jsint & TSS_SCSIRST_INT)	/* if SCSI bus reset detected   */
drivers/scsi/initio.c:	if (host->jsint & TSS_DISC_INT) {	/* BUS disconnection            */
drivers/scsi/initio.c:		if (host->flags & HCF_EXPECT_DONE_DISC) {
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0); /* Flush SCSI FIFO */
drivers/scsi/initio.c:			initio_unlink_busy_scb(host, host->active);
drivers/scsi/initio.c:			host->active->hastat = 0;
drivers/scsi/initio.c:			initio_append_done_scb(host, host->active);
drivers/scsi/initio.c:			host->active = NULL;
drivers/scsi/initio.c:			host->active_tc = NULL;
drivers/scsi/initio.c:			host->flags &= ~HCF_EXPECT_DONE_DISC;
drivers/scsi/initio.c:			outb(TSC_INITDEFAULT, host->addr + TUL_SConfig);
drivers/scsi/initio.c:			outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);	/* Enable HW reselect */
drivers/scsi/initio.c:		if (host->flags & HCF_EXPECT_DISC) {
drivers/scsi/initio.c:			outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0); /* Flush SCSI FIFO */
drivers/scsi/initio.c:			host->active = NULL;
drivers/scsi/initio.c:			host->active_tc = NULL;
drivers/scsi/initio.c:			host->flags &= ~HCF_EXPECT_DISC;
drivers/scsi/initio.c:			outb(TSC_INITDEFAULT, host->addr + TUL_SConfig);
drivers/scsi/initio.c:			outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);	/* Enable HW reselect */
drivers/scsi/initio.c:	if (host->jsint & (TSS_FUNC_COMP | TSS_BUS_SERV))
drivers/scsi/initio.c:		return host->phase;
drivers/scsi/initio.c:	return host->phase;
drivers/scsi/initio.c:	while (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0)) & TSS_INT_PENDING))
drivers/scsi/initio.c:	host->jsint = inb(host->addr + TUL_SInt);
drivers/scsi/initio.c:	if (host->jsint & TSS_SCSIRST_INT)	/* if SCSI bus reset detected */
drivers/scsi/initio.c:	if (host->jsint & TSS_DISC_INT) {	/* BUS disconnection */
drivers/scsi/initio.c:		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0); /* Flush SCSI FIFO */
drivers/scsi/initio.c:		outb(TSC_INITDEFAULT, host->addr + TUL_SConfig);
drivers/scsi/initio.c:		outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);	/* Enable HW reselect */
drivers/scsi/initio.c:		host->active = NULL;
drivers/scsi/initio.c:	while (!((host->jsstatus0 = inb(host->addr + TUL_SStatus0))
drivers/scsi/initio.c:	host->jsint = inb(host->addr + TUL_SInt);
drivers/scsi/initio.c:	if (host->jsint & TSS_SCSIRST_INT)	/* if SCSI bus reset detected */
drivers/scsi/initio.c:	if (host->jsint & TSS_DISC_INT) {	/* BUS disconnection */
drivers/scsi/initio.c:		outb(TSC_FLUSH_FIFO, host->addr + TUL_SCtrl0);		/* Flush SCSI FIFO */
drivers/scsi/initio.c:		outb(TSC_INITDEFAULT, host->addr + TUL_SConfig);
drivers/scsi/initio.c:		outb(TSC_HW_RESELECT, host->addr + TUL_SCtrl1);		/* Enable HW reselect */
drivers/scsi/initio.c:		initio_unlink_busy_scb(host, host->active);
drivers/scsi/initio.c:		initio_append_done_scb(host, host->active);
drivers/scsi/initio.c:		host->active = NULL;
drivers/scsi/initio.c:	dma_addr = dma_map_single(&host->pci_dev->dev, cmnd->sense_buffer,
drivers/scsi/initio.c:		dma_addr = dma_map_single(&host->pci_dev->dev, &cblk->sglist[0],
drivers/scsi/initio.c:	struct initio_host *host = (struct initio_host *) cmd->device->host->hostdata;
drivers/scsi/initio.c:	host = (struct initio_host *) cmnd->device->host->hostdata;
drivers/scsi/initio.c:	spin_lock_irq(cmnd->device->host->host_lock);
drivers/scsi/initio.c:	spin_unlock_irq(cmnd->device->host->host_lock);
drivers/scsi/initio.c:	host = (struct initio_host *) sdev->host->hostdata;
drivers/scsi/initio.c:	tc = &host->targets[sdev->id];
drivers/scsi/initio.c:	i91u_unmap_scb(host->pci_dev, cmnd);
drivers/scsi/initio.c:	host = (struct initio_host *)shost->hostdata;
drivers/scsi/initio.c:	host->addr = pci_resource_start(pdev, 0);
drivers/scsi/initio.c:	host->bios_addr = bios_seg;
drivers/scsi/initio.c:	if (!request_region(host->addr, 256, "i91u")) {
drivers/scsi/initio.c:		printk(KERN_WARNING "initio: I/O port range 0x%x is busy.\n", host->addr);
drivers/scsi/initio.c:	host->pci_dev = pdev;
drivers/scsi/initio.c:	host->semaph = 1;
drivers/scsi/initio.c:	spin_lock_init(&host->semaph_lock);
drivers/scsi/initio.c:	host->num_scbs = num_scb;
drivers/scsi/initio.c:	host->scb = scb;
drivers/scsi/initio.c:	host->next_pending = scb;
drivers/scsi/initio.c:	host->next_avail = scb;
drivers/scsi/initio.c:	host->scb_end = tmp;
drivers/scsi/initio.c:	host->first_avail = scb;
drivers/scsi/initio.c:	host->last_avail = prev;
drivers/scsi/initio.c:	spin_lock_init(&host->avail_lock);
drivers/scsi/initio.c:	host->jsstatus0 = 0;
drivers/scsi/initio.c:	shost->io_port = host->addr;
drivers/scsi/initio.c:	shost->n_io_port = 0xff;
drivers/scsi/initio.c:	shost->can_queue = num_scb;		/* 03/05/98                      */
drivers/scsi/initio.c:	shost->unique_id = host->addr;
drivers/scsi/initio.c:	shost->max_id = host->max_tar;
drivers/scsi/initio.c:	shost->max_lun = 32;	/* 10/21/97                     */
drivers/scsi/initio.c:	shost->irq = pdev->irq;
drivers/scsi/initio.c:	shost->this_id = host->scsi_id;	/* Assign HCS index           */
drivers/scsi/initio.c:	shost->base = host->addr;
drivers/scsi/initio.c:	shost->sg_tablesize = TOTAL_SG_ENTRY;
drivers/scsi/initio.c:	kfree(host->scb);
drivers/scsi/initio.c:	release_region(host->addr, 256);
drivers/scsi/initio.c:	struct initio_host *s = (struct initio_host *)host->hostdata;
drivers/scsi/ipr.c:	spin_unlock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:		ioa_cfg->host->host_no,
drivers/scsi/ipr.c:		ioa_cfg->host->host_no,
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:					spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:					spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	kobject_uevent(&ioa_cfg->host->shost_dev.kobj, KOBJ_CHANGE);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		len = snprintf(buf, PAGE_SIZE, "%d:%d:%d:%d\n", ioa_cfg->host->host_no,
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	struct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *) scsi_cmd->device->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/ipr.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *) scsi_cmd->device->host->hostdata;
drivers/scsi/ipr.c:		spin_unlock_irq(scsi_cmd->device->host->host_lock);
drivers/scsi/ipr.c:		spin_lock_irq(scsi_cmd->device->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/ipr.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *)scsi_cmd->device->host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(scsi_cmd->device->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(scsi_cmd->device->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:				spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *)scsi_cmd->device->host->hostdata;
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *) host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_unlock(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:			spin_unlock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:			spin_lock_irq(ioa_cfg->host->host_lock);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:		host->max_id = IPR_MAX_SIS64_TARGETS_PER_BUS;
drivers/scsi/ipr.c:		host->max_lun = IPR_MAX_SIS64_LUNS_PER_TARGET;
drivers/scsi/ipr.c:		host->max_id = IPR_MAX_NUM_TARGETS_PER_BUS;
drivers/scsi/ipr.c:		host->max_lun = IPR_MAX_NUM_LUNS_PER_TARGET;
drivers/scsi/ipr.c:	host->max_channel = IPR_MAX_BUS_TO_SCAN;
drivers/scsi/ipr.c:	host->unique_id = host->host_no;
drivers/scsi/ipr.c:	host->max_cmd_len = IPR_MAX_CDB_LEN;
drivers/scsi/ipr.c:	host->can_queue = ioa_cfg->max_cmds;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	ioa_cfg = (struct ipr_ioa_cfg *)host->hostdata;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);
drivers/scsi/ipr.c:	ipr_remove_trace_file(&ioa_cfg->host->shost_dev.kobj,
drivers/scsi/ipr.c:	ipr_remove_dump_file(&ioa_cfg->host->shost_dev.kobj,
drivers/scsi/ipr.c:	rc = ipr_create_trace_file(&ioa_cfg->host->shost_dev.kobj,
drivers/scsi/ipr.c:	rc = ipr_create_dump_file(&ioa_cfg->host->shost_dev.kobj,
drivers/scsi/ipr.c:		ipr_remove_trace_file(&ioa_cfg->host->shost_dev.kobj,
drivers/scsi/ipr.c:	ioa_cfg->host->max_channel = IPR_VSET_BUS;
drivers/scsi/ipr.c:	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:	spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
drivers/scsi/ipr.c:		spin_lock_irqsave(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:			spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.c:		spin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);
drivers/scsi/ipr.h:	printk(level IPR_NAME ": %d:%d:%d:%d: " fmt, (ioa_cfg)->host->host_no, \
drivers/scsi/ipr.h:	printk(level IPR_NAME ": %d:%d:%d:%d: " fmt, (ioa_cfg)->host->host_no, \
drivers/scsi/ipr.h:			##__VA_ARGS__, (ioa_cfg)->host->host_no,	\
drivers/scsi/ips.c:	ha = (ips_ha_t *) SC->device->host->hostdata;
drivers/scsi/ips.c:	spin_lock(host->host_lock);
drivers/scsi/ips.c:	spin_unlock(host->host_lock);
drivers/scsi/ips.c:	ha = (ips_ha_t *) SC->device->host->hostdata;
drivers/scsi/ips.c:	spin_lock_irq(SC->device->host->host_lock);
drivers/scsi/ips.c:	spin_unlock_irq(SC->device->host->host_lock);
drivers/scsi/ips.c:	ha = (ips_ha_t *) SC->device->host->hostdata;
drivers/scsi/ips.c:	ips_ha_t *ha = (ips_ha_t *) sdev->host->hostdata;
drivers/scsi/ips.c:	spin_lock(host->host_lock);
drivers/scsi/ips.c:		spin_unlock(host->host_lock);
drivers/scsi/ips.c:	spin_unlock(host->host_lock);
drivers/scsi/ips.c:		spin_lock(host->host_lock);
drivers/scsi/ips.c:			spin_unlock(host->host_lock);
drivers/scsi/ips.c:			spin_lock(host->host_lock);
drivers/scsi/ips.c:			spin_unlock(host->host_lock);	/* Unlock HA after command is taken off queue */
drivers/scsi/ips.c:			spin_lock(host->host_lock);
drivers/scsi/ips.c:		spin_unlock(host->host_lock);
drivers/scsi/isci/host.c:	u32 get_value = ihost->completion_queue_get;
drivers/scsi/isci/host.c:	    COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index]))
drivers/scsi/isci/host.c:		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:		writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:		writel(0, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:		tasklet_schedule(&ihost->completion_tasklet);
drivers/scsi/isci/host.c:		readl(&ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:	writel(0xff, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:	writel(0, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:	struct isci_request *ireq = ihost->reqs[index];
drivers/scsi/isci/host.c:	    ISCI_TAG_SEQ(ireq->io_tag) == ihost->io_request_sequence[index])
drivers/scsi/isci/host.c:		ireq = ihost->reqs[index];
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: %x for io request %p\n",
drivers/scsi/isci/host.c:		idev = ihost->device_table[index];
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: %x for device %p\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: unknown completion type %x\n",
drivers/scsi/isci/host.c:	frame_header = ihost->uf_control.buffers.array[frame_index].header;
drivers/scsi/isci/host.c:	ihost->uf_control.buffers.array[frame_index].state = UNSOLICITED_FRAME_IN_USE;
drivers/scsi/isci/host.c:		iphy = &ihost->phys[index];
drivers/scsi/isci/host.c:			iphy = &ihost->phys[index];
drivers/scsi/isci/host.c:			if (index < ihost->remote_node_entries)
drivers/scsi/isci/host.c:				idev = ihost->device_table[index];
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		ireq = ihost->reqs[index];
drivers/scsi/isci/host.c:			ireq = ihost->reqs[index];
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			idev = ihost->device_table[index];
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		iphy = &ihost->phys[index];
drivers/scsi/isci/host.c:		if (index < ihost->remote_node_entries) {
drivers/scsi/isci/host.c:			idev = ihost->device_table[index];
drivers/scsi/isci/host.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		ihost->completion_queue_get);
drivers/scsi/isci/host.c:	get_index = NORMALIZE_GET_POINTER(ihost->completion_queue_get);
drivers/scsi/isci/host.c:	get_cycle = SMU_CQGR_CYCLE_BIT & ihost->completion_queue_get;
drivers/scsi/isci/host.c:	event_get = NORMALIZE_EVENT_POINTER(ihost->completion_queue_get);
drivers/scsi/isci/host.c:	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & ihost->completion_queue_get;
drivers/scsi/isci/host.c:		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
drivers/scsi/isci/host.c:		ent = ihost->completion_queue[get_index];
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		ihost->completion_queue_get =
drivers/scsi/isci/host.c:		writel(ihost->completion_queue_get,
drivers/scsi/isci/host.c:		       &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		ihost->completion_queue_get);
drivers/scsi/isci/host.c:		readl(&ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:		writel(SMU_ISR_QUEUE_SUSPEND, &ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev, "%s: status: %#x\n", __func__,
drivers/scsi/isci/host.c:		sci_change_state(&ihost->sm, SCIC_FAILED);
drivers/scsi/isci/host.c:	writel(0, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:		tasklet_schedule(&ihost->completion_tasklet);
drivers/scsi/isci/host.c:		spin_lock(&ihost->scic_lock);
drivers/scsi/isci/host.c:		spin_unlock(&ihost->scic_lock);
drivers/scsi/isci/host.c:		dev_info(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	clear_bit(IHOST_START_PENDING, &ihost->flags);
drivers/scsi/isci/host.c:	wake_up(&ihost->eventq);
drivers/scsi/isci/host.c:	if (test_bit(IHOST_START_PENDING, &ihost->flags))
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		"%s: ihost->status = %d, time = %ld\n",
drivers/scsi/isci/host.c:	BUG_ON(ihost->smu_registers == NULL);
drivers/scsi/isci/host.c:	writel(0, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:	BUG_ON(ihost->smu_registers == NULL);
drivers/scsi/isci/host.c:	writel(0xffffffff, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:		readl(&ihost->scu_registers->peg0.ptsg.control);
drivers/scsi/isci/host.c:	       &ihost->scu_registers->peg0.ptsg.control);
drivers/scsi/isci/host.c:		readl(&ihost->smu_registers->task_context_assignment[0]);
drivers/scsi/isci/host.c:		(SMU_TCA_GEN_VAL(ENDING,  ihost->task_context_entries - 1)) |
drivers/scsi/isci/host.c:		&ihost->smu_registers->task_context_assignment[0]);
drivers/scsi/isci/host.c:	ihost->completion_queue_get = 0;
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_control);
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:	       &ihost->smu_registers->completion_queue_put);
drivers/scsi/isci/host.c:		ihost->completion_queue[index] = 0x80000000;
drivers/scsi/isci/host.c:	       &ihost->scu_registers->sdma.unsolicited_frame_queue_control);
drivers/scsi/isci/host.c:	       &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
drivers/scsi/isci/host.c:	       &ihost->scu_registers->sdma.unsolicited_frame_put_pointer);
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id == SCIC_STARTING) {
drivers/scsi/isci/host.c:		sci_change_state(&ihost->sm, SCIC_READY);
drivers/scsi/isci/host.c:	struct sci_oem_params *oem = &ihost->oem_parameters;
drivers/scsi/isci/host.c:	if (ihost->phy_startup_timer_pending)
drivers/scsi/isci/host.c:	if (ihost->next_phy_to_start >= SCI_MAX_PHYS) {
drivers/scsi/isci/host.c:			iphy = &ihost->phys[index];
drivers/scsi/isci/host.c:			    (ihost->port_agent.phy_ready_mask != ihost->port_agent.phy_configured_mask)) {
drivers/scsi/isci/host.c:			sci_del_timer(&ihost->phy_timer);
drivers/scsi/isci/host.c:			ihost->phy_startup_timer_pending = false;
drivers/scsi/isci/host.c:		iphy = &ihost->phys[ihost->next_phy_to_start];
drivers/scsi/isci/host.c:				ihost->next_phy_to_start++;
drivers/scsi/isci/host.c:			sci_mod_timer(&ihost->phy_timer,
drivers/scsi/isci/host.c:			ihost->phy_startup_timer_pending = true;
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:				 ihost->phys[ihost->next_phy_to_start].phy_index,
drivers/scsi/isci/host.c:		ihost->next_phy_to_start++;
drivers/scsi/isci/host.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:	ihost->phy_startup_timer_pending = false;
drivers/scsi/isci/host.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:	return CIRC_CNT(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_INITIALIZED) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	BUILD_BUG_ON(SCI_MAX_IO_REQUESTS > 1 << sizeof(ihost->tci_pool[0]) * 8);
drivers/scsi/isci/host.c:	ihost->tci_head = 0;
drivers/scsi/isci/host.c:	ihost->tci_tail = 0;
drivers/scsi/isci/host.c:	for (index = 0; index < ihost->task_context_entries; index++)
drivers/scsi/isci/host.c:	sci_remote_node_table_initialize(&ihost->available_remote_nodes,
drivers/scsi/isci/host.c:					 ihost->remote_node_entries);
drivers/scsi/isci/host.c:	for (index = 0; index < ihost->logical_port_entries; index++) {
drivers/scsi/isci/host.c:		struct isci_port *iport = &ihost->ports[index];
drivers/scsi/isci/host.c:	sci_mod_timer(&ihost->timer, timeout);
drivers/scsi/isci/host.c:	sci_change_state(&ihost->sm, SCIC_STARTING);
drivers/scsi/isci/host.c:	set_bit(IHOST_START_PENDING, &ihost->flags);
drivers/scsi/isci/host.c:	spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
drivers/scsi/isci/host.c:	wake_up(&ihost->eventq);
drivers/scsi/isci/host.c:	writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
drivers/scsi/isci/host.c:	writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:	writel(0, &ihost->smu_registers->interrupt_mask);
drivers/scsi/isci/host.c:	spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	list_splice_init(&ihost->requests_to_complete,
drivers/scsi/isci/host.c:	list_splice_init(&ihost->requests_to_errorback,
drivers/scsi/isci/host.c:	spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:		spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:			spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	       &ihost->smu_registers->interrupt_coalesce_control);
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_READY) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	sci_mod_timer(&ihost->timer, timeout);
drivers/scsi/isci/host.c:	sci_change_state(&ihost->sm, SCIC_STOPPING);
drivers/scsi/isci/host.c:	switch (ihost->sm.current_state_id) {
drivers/scsi/isci/host.c:		sci_change_state(&ihost->sm, SCIC_RESETTING);
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
drivers/scsi/isci/host.c:		struct isci_port *iport = &ihost->ports[i];
drivers/scsi/isci/host.c:	set_bit(IHOST_STOP_PENDING, &ihost->flags);
drivers/scsi/isci/host.c:	spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	writel(0, &ihost->scu_registers->peg0.sgpio.interface_control);
drivers/scsi/isci/host.c:	for (i = 0; i < ihost->logical_port_entries; i++) {
drivers/scsi/isci/host.c:		struct isci_port *iport = &ihost->ports[i];
drivers/scsi/isci/host.c:		struct isci_phy *iphy = &ihost->phys[i];
drivers/scsi/isci/host.c:	del_timer_sync(&ihost->port_agent.timer.timer);
drivers/scsi/isci/host.c:	del_timer_sync(&ihost->power_control.timer.timer);
drivers/scsi/isci/host.c:	del_timer_sync(&ihost->timer.timer);
drivers/scsi/isci/host.c:	del_timer_sync(&ihost->phy_timer.timer);
drivers/scsi/isci/host.c:	struct pci_dev *pdev = isci_host->pdev;
drivers/scsi/isci/host.c:	int id = isci_host->id;
drivers/scsi/isci/host.c:	struct pci_dev *pdev = isci_host->pdev;
drivers/scsi/isci/host.c:	int id = isci_host->id;
drivers/scsi/isci/host.c:	sci_change_state(&ihost->sm, SCIC_RESET);
drivers/scsi/isci/host.c:	sci_del_timer(&ihost->timer);
drivers/scsi/isci/host.c:	       &ihost->smu_registers->interrupt_coalesce_control);
drivers/scsi/isci/host.c:	ihost->interrupt_coalesce_number = (u16)coalesce_number;
drivers/scsi/isci/host.c:	ihost->interrupt_coalesce_timeout = coalesce_timeout / 100;
drivers/scsi/isci/host.c:	val = readl(&ihost->smu_registers->clock_gating_control);
drivers/scsi/isci/host.c:	writel(val, &ihost->smu_registers->clock_gating_control);
drivers/scsi/isci/host.c:		phy_status = sci_phy_stop(&ihost->phys[index]);
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:				 ihost->phys[index].phy_index, phy_status);
drivers/scsi/isci/host.c:	for (index = 0; index < ihost->logical_port_entries; index++) {
drivers/scsi/isci/host.c:		struct isci_port *iport = &ihost->ports[index];
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	for (index = 0; index < ihost->remote_node_entries; index++) {
drivers/scsi/isci/host.c:		if (ihost->device_table[index] != NULL) {
drivers/scsi/isci/host.c:			device_status = sci_remote_device_stop(ihost->device_table[index], 0);
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:					 ihost->device_table[index], device_status);
drivers/scsi/isci/host.c:	sci_del_timer(&ihost->timer);
drivers/scsi/isci/host.c:	writel(0xFFFFFFFF, &ihost->smu_registers->soft_reset_control);
drivers/scsi/isci/host.c:	writel(0x00000000, &ihost->smu_registers->completion_queue_get);
drivers/scsi/isci/host.c:	writel(0, &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
drivers/scsi/isci/host.c:	sci_change_state(&ihost->sm, SCIC_RESET);
drivers/scsi/isci/host.c:	ihost->oem_parameters.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
drivers/scsi/isci/host.c:	ihost->oem_parameters.controller.max_concurr_spin_up = 1;
drivers/scsi/isci/host.c:	ihost->oem_parameters.controller.do_enable_ssc = false;
drivers/scsi/isci/host.c:	ihost->oem_parameters.controller.cable_selection_mask = 0;
drivers/scsi/isci/host.c:		ihost->oem_parameters.ports[index].phy_mask = 0;
drivers/scsi/isci/host.c:		ihost->user_parameters.phys[index].max_speed_generation =
drivers/scsi/isci/host.c:		ihost->user_parameters.phys[index].align_insertion_frequency = 0x7f;
drivers/scsi/isci/host.c:		ihost->user_parameters.phys[index].in_connection_align_insertion_frequency = 0xff;
drivers/scsi/isci/host.c:		ihost->user_parameters.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
drivers/scsi/isci/host.c:		ihost->oem_parameters.phys[index].sas_address.low = 0x1 + ihost->id;
drivers/scsi/isci/host.c:		ihost->oem_parameters.phys[index].sas_address.high = 0x5FCFFFFF;
drivers/scsi/isci/host.c:	ihost->user_parameters.stp_inactivity_timeout = 5;
drivers/scsi/isci/host.c:	ihost->user_parameters.ssp_inactivity_timeout = 5;
drivers/scsi/isci/host.c:	ihost->user_parameters.stp_max_occupancy_timeout = 5;
drivers/scsi/isci/host.c:	ihost->user_parameters.ssp_max_occupancy_timeout = 20;
drivers/scsi/isci/host.c:	ihost->user_parameters.no_outbound_task_timeout = 2;
drivers/scsi/isci/host.c:	struct sci_base_state_machine *sm = &ihost->sm;
drivers/scsi/isci/host.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:	sci_init_sm(&ihost->sm, sci_controller_state_table, SCIC_INITIAL);
drivers/scsi/isci/host.c:	ihost->scu_registers = scu_base;
drivers/scsi/isci/host.c:	ihost->smu_registers = smu_base;
drivers/scsi/isci/host.c:	sci_port_configuration_agent_construct(&ihost->port_agent);
drivers/scsi/isci/host.c:		sci_port_construct(&ihost->ports[i], i, ihost);
drivers/scsi/isci/host.c:	sci_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, ihost);
drivers/scsi/isci/host.c:		sci_phy_construct(&ihost->phys[i],
drivers/scsi/isci/host.c:				  &ihost->ports[SCI_MAX_PORTS], i);
drivers/scsi/isci/host.c:	ihost->invalid_phy_mask = 0;
drivers/scsi/isci/host.c:	sci_init_timer(&ihost->timer, controller_timeout);
drivers/scsi/isci/host.c:	u32 state = ihost->sm.current_state_id;
drivers/scsi/isci/host.c:	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
drivers/scsi/isci/host.c:		if (sci_oem_parameters_validate(&ihost->oem_parameters,
drivers/scsi/isci/host.c:	if (ihost->user_parameters.max_concurr_spinup)
drivers/scsi/isci/host.c:		return min_t(u8, ihost->user_parameters.max_concurr_spinup,
drivers/scsi/isci/host.c:		return min_t(u8, ihost->oem_parameters.controller.max_concurr_spin_up,
drivers/scsi/isci/host.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:	ihost->power_control.phys_granted_power = 0;
drivers/scsi/isci/host.c:	if (ihost->power_control.phys_waiting == 0) {
drivers/scsi/isci/host.c:		ihost->power_control.timer_started = false;
drivers/scsi/isci/host.c:		if (ihost->power_control.phys_waiting == 0)
drivers/scsi/isci/host.c:		iphy = ihost->power_control.requesters[i];
drivers/scsi/isci/host.c:		if (ihost->power_control.phys_granted_power >= max_spin_up(ihost))
drivers/scsi/isci/host.c:		ihost->power_control.requesters[i] = NULL;
drivers/scsi/isci/host.c:		ihost->power_control.phys_waiting--;
drivers/scsi/isci/host.c:		ihost->power_control.phys_granted_power++;
drivers/scsi/isci/host.c:				struct isci_phy *requester = ihost->power_control.requesters[j];
drivers/scsi/isci/host.c:						ihost->power_control.requesters[j] = NULL;
drivers/scsi/isci/host.c:						ihost->power_control.phys_waiting--;
drivers/scsi/isci/host.c:	ihost->power_control.timer_started = true;
drivers/scsi/isci/host.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/host.c:	if (ihost->power_control.phys_granted_power < max_spin_up(ihost)) {
drivers/scsi/isci/host.c:		ihost->power_control.phys_granted_power++;
drivers/scsi/isci/host.c:		if (ihost->power_control.timer_started)
drivers/scsi/isci/host.c:			sci_del_timer(&ihost->power_control.timer);
drivers/scsi/isci/host.c:		sci_mod_timer(&ihost->power_control.timer,
drivers/scsi/isci/host.c:		ihost->power_control.timer_started = true;
drivers/scsi/isci/host.c:			current_phy = &ihost->phys[i];
drivers/scsi/isci/host.c:			ihost->power_control.requesters[iphy->phy_index] = iphy;
drivers/scsi/isci/host.c:			ihost->power_control.phys_waiting++;
drivers/scsi/isci/host.c:	if (ihost->power_control.requesters[iphy->phy_index])
drivers/scsi/isci/host.c:		ihost->power_control.phys_waiting--;
drivers/scsi/isci/host.c:	ihost->power_control.requesters[iphy->phy_index] = NULL;
drivers/scsi/isci/host.c:			+ ihost->id;
drivers/scsi/isci/host.c:		return &ihost->oem_parameters.controller.cable_selection_mask;
drivers/scsi/isci/host.c:	struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
drivers/scsi/isci/host.c:	const struct sci_oem_params *oem = &ihost->oem_parameters;
drivers/scsi/isci/host.c:	struct pci_dev *pdev = ihost->pdev;
drivers/scsi/isci/host.c:	sci_init_timer(&ihost->power_control.timer, power_control_timeout);
drivers/scsi/isci/host.c:	memset(ihost->power_control.requesters, 0,
drivers/scsi/isci/host.c:	       sizeof(ihost->power_control.requesters));
drivers/scsi/isci/host.c:	ihost->power_control.phys_waiting = 0;
drivers/scsi/isci/host.c:	ihost->power_control.phys_granted_power = 0;
drivers/scsi/isci/host.c:	struct sci_base_state_machine *sm = &ihost->sm;
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_RESET) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	sci_init_timer(&ihost->phy_timer, phy_startup_timeout);
drivers/scsi/isci/host.c:	ihost->next_phy_to_start = 0;
drivers/scsi/isci/host.c:	ihost->phy_startup_timer_pending = false;
drivers/scsi/isci/host.c:	writel(0, &ihost->smu_registers->soft_reset_control);
drivers/scsi/isci/host.c:		status = readl(&ihost->smu_registers->control_status);
drivers/scsi/isci/host.c:	val = readl(&ihost->smu_registers->device_context_capacity);
drivers/scsi/isci/host.c:	ihost->logical_port_entries = min(smu_max_ports(val), SCI_MAX_PORTS);
drivers/scsi/isci/host.c:	ihost->task_context_entries = min(smu_max_task_contexts(val), SCI_MAX_IO_REQUESTS);
drivers/scsi/isci/host.c:	ihost->remote_node_entries = min(smu_max_rncs(val), SCI_MAX_REMOTE_DEVICES);
drivers/scsi/isci/host.c:	for (i = 0; i < ihost->logical_port_entries; i++) {
drivers/scsi/isci/host.c:			*ptsg = &ihost->scu_registers->peg0.ptsg;
drivers/scsi/isci/host.c:	val = readl(&ihost->scu_registers->sdma.pdma_configuration);
drivers/scsi/isci/host.c:	writel(val, &ihost->scu_registers->sdma.pdma_configuration);
drivers/scsi/isci/host.c:	val = readl(&ihost->scu_registers->sdma.cdma_configuration);
drivers/scsi/isci/host.c:	writel(val, &ihost->scu_registers->sdma.cdma_configuration);
drivers/scsi/isci/host.c:		result = sci_phy_initialize(&ihost->phys[i],
drivers/scsi/isci/host.c:					    &ihost->scu_registers->peg0.pe[i].tl,
drivers/scsi/isci/host.c:					    &ihost->scu_registers->peg0.pe[i].ll);
drivers/scsi/isci/host.c:	for (i = 0; i < ihost->logical_port_entries; i++) {
drivers/scsi/isci/host.c:		struct isci_port *iport = &ihost->ports[i];
drivers/scsi/isci/host.c:		iport->port_task_scheduler_registers = &ihost->scu_registers->peg0.ptsg.port[i];
drivers/scsi/isci/host.c:		iport->port_pe_configuration_register = &ihost->scu_registers->peg0.ptsg.protocol_engine[0];
drivers/scsi/isci/host.c:		iport->viit_registers = &ihost->scu_registers->peg0.viit[i];
drivers/scsi/isci/host.c:	result = sci_port_configuration_agent_initialize(ihost, &ihost->port_agent);
drivers/scsi/isci/host.c:	u32 state = ihost->sm.current_state_id;
drivers/scsi/isci/host.c:		memcpy(&ihost->user_parameters, sci_parms, sizeof(*sci_parms));
drivers/scsi/isci/host.c:	struct device *dev = &ihost->pdev->dev;
drivers/scsi/isci/host.c:	ihost->completion_queue = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
drivers/scsi/isci/host.c:	if (!ihost->completion_queue)
drivers/scsi/isci/host.c:	writel(lower_32_bits(dma), &ihost->smu_registers->completion_queue_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(dma), &ihost->smu_registers->completion_queue_upper);
drivers/scsi/isci/host.c:	size = ihost->remote_node_entries * sizeof(union scu_remote_node_context);
drivers/scsi/isci/host.c:	ihost->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
drivers/scsi/isci/host.c:	if (!ihost->remote_node_context_table)
drivers/scsi/isci/host.c:	writel(lower_32_bits(dma), &ihost->smu_registers->remote_node_context_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(dma), &ihost->smu_registers->remote_node_context_upper);
drivers/scsi/isci/host.c:	size = ihost->task_context_entries * sizeof(struct scu_task_context),
drivers/scsi/isci/host.c:	ihost->task_context_table = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
drivers/scsi/isci/host.c:	if (!ihost->task_context_table)
drivers/scsi/isci/host.c:	ihost->task_context_dma = dma;
drivers/scsi/isci/host.c:	writel(lower_32_bits(dma), &ihost->smu_registers->host_task_table_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(dma), &ihost->smu_registers->host_task_table_upper);
drivers/scsi/isci/host.c:	writel(lower_32_bits(ihost->uf_control.headers.physical_address),
drivers/scsi/isci/host.c:		&ihost->scu_registers->sdma.uf_header_base_address_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(ihost->uf_control.headers.physical_address),
drivers/scsi/isci/host.c:		&ihost->scu_registers->sdma.uf_header_base_address_upper);
drivers/scsi/isci/host.c:	writel(lower_32_bits(ihost->uf_control.address_table.physical_address),
drivers/scsi/isci/host.c:		&ihost->scu_registers->sdma.uf_address_table_lower);
drivers/scsi/isci/host.c:	writel(upper_32_bits(ihost->uf_control.address_table.physical_address),
drivers/scsi/isci/host.c:		&ihost->scu_registers->sdma.uf_address_table_upper);
drivers/scsi/isci/host.c:	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
drivers/scsi/isci/host.c:	spin_lock_init(&ihost->state_lock);
drivers/scsi/isci/host.c:	spin_lock_init(&ihost->scic_lock);
drivers/scsi/isci/host.c:	init_waitqueue_head(&ihost->eventq);
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	ihost->sas_ha.dev = &ihost->pdev->dev;
drivers/scsi/isci/host.c:	ihost->sas_ha.lldd_ha = ihost;
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		status = isci_parse_oem_parameters(&ihost->oem_parameters,
drivers/scsi/isci/host.c:						   ihost->id);
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	tasklet_init(&ihost->completion_tasklet,
drivers/scsi/isci/host.c:	INIT_LIST_HEAD(&ihost->requests_to_complete);
drivers/scsi/isci/host.c:	INIT_LIST_HEAD(&ihost->requests_to_errorback);
drivers/scsi/isci/host.c:	spin_lock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:	spin_unlock_irq(&ihost->scic_lock);
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		isci_port_init(&ihost->ports[i], ihost, i);
drivers/scsi/isci/host.c:		isci_phy_init(&ihost->phys[i], ihost, i);
drivers/scsi/isci/host.c:	writel(1, &ihost->scu_registers->peg0.sgpio.interface_control);
drivers/scsi/isci/host.c:		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
drivers/scsi/isci/host.c:	writel(0, &ihost->scu_registers->peg0.sgpio.vendor_specific_code);
drivers/scsi/isci/host.c:		struct isci_remote_device *idev = &ihost->devices[i];
drivers/scsi/isci/host.c:		ireq = dmam_alloc_coherent(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		ireq->tc = &ihost->task_context_table[i];
drivers/scsi/isci/host.c:		ihost->reqs[i] = ireq;
drivers/scsi/isci/host.c:	switch (ihost->sm.current_state_id) {
drivers/scsi/isci/host.c:		sci_del_timer(&ihost->phy_timer);
drivers/scsi/isci/host.c:		ihost->phy_startup_timer_pending = false;
drivers/scsi/isci/host.c:		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
drivers/scsi/isci/host.c:		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			ihost->sm.current_state_id);
drivers/scsi/isci/host.c:	switch (ihost->sm.current_state_id) {
drivers/scsi/isci/host.c:		ihost->port_agent.link_down_handler(ihost, &ihost->port_agent,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			ihost->sm.current_state_id);
drivers/scsi/isci/host.c:	for (index = 0; index < ihost->remote_node_entries; index++) {
drivers/scsi/isci/host.c:		if ((ihost->device_table[index] != NULL) &&
drivers/scsi/isci/host.c:		   (ihost->device_table[index]->sm.current_state_id == SCI_DEV_STOPPING))
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_STOPPING) {
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			ihost->sm.current_state_id);
drivers/scsi/isci/host.c:		sci_change_state(&ihost->sm, SCIC_STOPPED);
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev, "%s[%d]: %#x\n",
drivers/scsi/isci/host.c:		__func__, ihost->id, request);
drivers/scsi/isci/host.c:	writel(request, &ihost->smu_registers->post_context_port);
drivers/scsi/isci/host.c:	if (task_index < ihost->task_context_entries) {
drivers/scsi/isci/host.c:		struct isci_request *ireq = ihost->reqs[task_index];
drivers/scsi/isci/host.c:			if (task_sequence == ihost->io_request_sequence[task_index])
drivers/scsi/isci/host.c:		&ihost->available_remote_nodes, remote_node_count
drivers/scsi/isci/host.c:		ihost->device_table[node_index] = idev;
drivers/scsi/isci/host.c:	if (ihost->device_table[node_id] == idev) {
drivers/scsi/isci/host.c:		ihost->device_table[node_id] = NULL;
drivers/scsi/isci/host.c:			&ihost->available_remote_nodes, remote_node_count, node_id
drivers/scsi/isci/host.c:	if (sci_unsolicited_frame_control_release_frame(&ihost->uf_control, frame_index))
drivers/scsi/isci/host.c:		writel(ihost->uf_control.get,
drivers/scsi/isci/host.c:			&ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
drivers/scsi/isci/host.c:	u16 tail = ihost->tci_tail & (SCI_MAX_IO_REQUESTS-1);
drivers/scsi/isci/host.c:	ihost->tci_pool[tail] = tci;
drivers/scsi/isci/host.c:	ihost->tci_tail = tail + 1;
drivers/scsi/isci/host.c:	u16 head = ihost->tci_head & (SCI_MAX_IO_REQUESTS-1);
drivers/scsi/isci/host.c:	u16 tci = ihost->tci_pool[head];
drivers/scsi/isci/host.c:	ihost->tci_head = head + 1;
drivers/scsi/isci/host.c:	return CIRC_SPACE(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
drivers/scsi/isci/host.c:		u8 seq = ihost->io_request_sequence[tci];
drivers/scsi/isci/host.c:	if (seq == ihost->io_request_sequence[tci]) {
drivers/scsi/isci/host.c:		ihost->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_READY) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "invalid state to start I/O");
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_READY) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	switch (ihost->sm.current_state_id) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "invalid state to complete I/O");
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_READY) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "invalid state to continue I/O");
drivers/scsi/isci/host.c:	if (ihost->sm.current_state_id != SCIC_READY) {
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		writel(val, &ihost->scu_registers->peg0.sgpio.output_data_select[d]);
drivers/scsi/isci/host.h:	return isci_host->status;
drivers/scsi/isci/host.h:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/host.h:	spin_lock_irqsave(&isci_host->state_lock, flags);
drivers/scsi/isci/host.h:	isci_host->status = status;
drivers/scsi/isci/host.h:	spin_unlock_irqrestore(&isci_host->state_lock, flags);
drivers/scsi/isci/host.h:	wait_event(ihost->eventq, !test_bit(IHOST_START_PENDING, &ihost->flags));
drivers/scsi/isci/host.h:	wait_event(ihost->eventq, !test_bit(IHOST_STOP_PENDING, &ihost->flags));
drivers/scsi/isci/host.h:	wait_event(ihost->eventq, !test_bit(IDEV_START_PENDING, &idev->flags));
drivers/scsi/isci/host.h:	wait_event(ihost->eventq, !test_bit(IDEV_STOP_PENDING, &idev->flags));
drivers/scsi/isci/host.h:	return &idev->isci_port->isci_host->pdev->dev;
drivers/scsi/isci/host.h:	return ARRAY_SIZE(ihost->scu_registers->peg0.sgpio.output_data_select);
drivers/scsi/isci/init.c:	return snprintf(buf, PAGE_SIZE, "%d\n", ihost->id);
drivers/scsi/isci/init.c:	struct sas_ha_struct *sas_ha = &(isci_host->sas_ha);
drivers/scsi/isci/init.c:	sas_phys = devm_kzalloc(&isci_host->pdev->dev,
drivers/scsi/isci/init.c:	sas_ports = devm_kzalloc(&isci_host->pdev->dev,
drivers/scsi/isci/init.c:	sas_ha->sas_addr    = &isci_host->phys[0].sas_addr[0];
drivers/scsi/isci/init.c:		sas_phys[i] = &isci_host->phys[i].sas_phy;
drivers/scsi/isci/init.c:		sas_ports[i] = &isci_host->sas_ports[i];
drivers/scsi/isci/init.c:	shost = isci_host->shost;
drivers/scsi/isci/init.c:	sas_unregister_ha(&isci_host->sas_ha);
drivers/scsi/isci/init.c:	sas_remove_host(isci_host->shost);
drivers/scsi/isci/init.c:	scsi_remove_host(isci_host->shost);
drivers/scsi/isci/init.c:	scsi_host_put(isci_host->shost);
drivers/scsi/isci/init.c:	isci_host->pdev = pdev;
drivers/scsi/isci/init.c:	isci_host->id = id;
drivers/scsi/isci/init.c:	isci_host->shost = shost;
drivers/scsi/isci/init.c:		 (is_cable_select_overridden() ? "* " : ""), isci_host->id,
drivers/scsi/isci/init.c:	SHOST_TO_SAS_HA(shost) = &isci_host->sas_ha;
drivers/scsi/isci/init.c:	isci_host->sas_ha.core.shost = shost;
drivers/scsi/isci/init.c:	shost->transportt = isci_transport_template;
drivers/scsi/isci/init.c:	shost->max_id = ~0;
drivers/scsi/isci/init.c:	shost->max_lun = ~0;
drivers/scsi/isci/init.c:	shost->max_cmd_len = MAX_COMMAND_SIZE;
drivers/scsi/isci/init.c:		scsi_scan_host(isci_host->shost);
drivers/scsi/isci/phy.c:	phy_user = &ihost->user_parameters.phys[phy_idx];
drivers/scsi/isci/phy.c:	phy_oem = &ihost->oem_parameters.phys[phy_idx];
drivers/scsi/isci/phy.c:	if (ihost->oem_parameters.controller.do_enable_ssc) {
drivers/scsi/isci/phy.c:		struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
drivers/scsi/isci/phy.c:		struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
drivers/scsi/isci/phy.c:			sata_spread = ihost->oem_parameters.controller.ssc_sata_tx_spread_level;
drivers/scsi/isci/phy.c:			sas_spread = ihost->oem_parameters.controller.ssc_sas_tx_spread_level;
drivers/scsi/isci/phy.c:				sas_type = ihost->oem_parameters.controller.ssc_sas_tx_type;
drivers/scsi/isci/phy.c:	if (is_c0(ihost->pdev) || is_c1(ihost->pdev)) {
drivers/scsi/isci/phy.c:		(u8)ihost->user_parameters.no_outbound_task_timeout);
drivers/scsi/isci/phy.c:	if (is_a2(ihost->pdev)) {
drivers/scsi/isci/phy.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:		result = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/phy.c:		result = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/phy.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/phy.c:	struct sci_oem_params *oem = &ihost->oem_parameters;
drivers/scsi/isci/phy.c:	iphy->sas_phy.ha = &ihost->sas_ha;
drivers/scsi/isci/phy.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/phy.c:		spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:		spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/phy.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:	return &ihost->pdev->dev;
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
drivers/scsi/isci/port.c:		isci_host->sas_ha.notify_port_event(&iphy->sas_phy,
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:				dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:	isci_host->sas_ha.notify_phy_event(&isci_phy->sas_phy,
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:			struct isci_phy *iphy = &ihost->phys[phy_idx];
drivers/scsi/isci/port.c:	wake_up(&ihost->eventq);
drivers/scsi/isci/port.c:	struct sci_user_parameters *user = &ihost->user_parameters;
drivers/scsi/isci/port.c:		sci_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
drivers/scsi/isci/port.c:	task_context = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
drivers/scsi/isci/port.c:		sci_remote_node_table_release_remote_node_index(&ihost->available_remote_nodes,
drivers/scsi/isci/port.c:	if ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
drivers/scsi/isci/port.c:		ihost->invalid_phy_mask |= 1 << iphy->phy_index;
drivers/scsi/isci/port.c:		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
drivers/scsi/isci/port.c:			struct isci_port *dst_port = &(ihost->ports[iphy->phy_index]);
drivers/scsi/isci/port.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	tc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
drivers/scsi/isci/port.c:	tc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: port%d ready\n",
drivers/scsi/isci/port.c:	rnc = &ihost->remote_node_context_table[rni];
drivers/scsi/isci/port.c:	readl(&ihost->smu_registers->interrupt_status); /* flush */
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:				&ihost->available_remote_nodes, 1);
drivers/scsi/isci/port.c:	rnc = &ihost->remote_node_context_table[rni];
drivers/scsi/isci/port.c:	readl(&ihost->smu_registers->interrupt_status); /* flush */
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:	wait_event(ihost->eventq, !test_bit(IPORT_RESET_PENDING, &iport->state));
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
drivers/scsi/isci/port.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/port.c:		wake_up(&ihost->eventq);
drivers/scsi/isci/port.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/port.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/port.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port: %ld\n",
drivers/scsi/isci/port.c:			__func__, (long) (iport - &ihost->ports[0]));
drivers/scsi/isci/port.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port.c:		iport = &ihost->ports[i];
drivers/scsi/isci/port.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port_config.c:	for (i = 0; i < ihost->logical_port_entries; i++) {
drivers/scsi/isci/port_config.c:		struct isci_port *iport = &ihost->ports[i];
drivers/scsi/isci/port_config.c:	sci_phy_get_sas_address(&ihost->phys[0], &first_address);
drivers/scsi/isci/port_config.c:	sci_phy_get_sas_address(&ihost->phys[3], &second_address);
drivers/scsi/isci/port_config.c:		sci_phy_get_sas_address(&ihost->phys[0], &first_address);
drivers/scsi/isci/port_config.c:		sci_phy_get_sas_address(&ihost->phys[2], &second_address);
drivers/scsi/isci/port_config.c:		sci_phy_get_sas_address(&ihost->phys[1], &first_address);
drivers/scsi/isci/port_config.c:		sci_phy_get_sas_address(&ihost->phys[3], &second_address);
drivers/scsi/isci/port_config.c:		phy_mask = ihost->oem_parameters.ports[port_index].phy_mask;
drivers/scsi/isci/port_config.c:			sci_phy_get_sas_address(&ihost->phys[phy_index],
drivers/scsi/isci/port_config.c:			sci_phy_get_sas_address(&ihost->phys[phy_index],
drivers/scsi/isci/port_config.c:			sci_port_add_phy(&ihost->ports[port_index],
drivers/scsi/isci/port_config.c:					      &ihost->phys[phy_index]);
drivers/scsi/isci/port_config.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port_config.c:		struct isci_phy *iphy = &ihost->phys[index];
drivers/scsi/isci/port_config.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port_config.c:		sci_phy_get_sas_address(&ihost->phys[phy_index],
drivers/scsi/isci/port_config.c:			sci_phy_get_sas_address(&ihost->phys[phy_index],
drivers/scsi/isci/port_config.c:			iport = &ihost->ports[port_index];
drivers/scsi/isci/port_config.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/port_config.c:						   &ihost->phys[index], false);
drivers/scsi/isci/port_config.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/port_config.c:	mode = ihost->oem_parameters.controller.mode_type;
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:		wake_up(&ihost->eventq);
drivers/scsi/isci/remote_device.c:		struct isci_request *ireq = ihost->reqs[i];
drivers/scsi/isci/remote_device.c:		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/remote_device.c:		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
drivers/scsi/isci/remote_device.c:		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:		idev = &ihost->devices[i];
drivers/scsi/isci/remote_device.c:		dev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);
drivers/scsi/isci/remote_device.c:	wake_up(&ihost->eventq);
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/remote_device.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/remote_device.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/remote_device.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/remote_device.c:	spin_lock_irq(&isci_host->scic_lock);
drivers/scsi/isci/remote_device.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/remote_device.c:	spin_unlock_irq(&isci_host->scic_lock);
drivers/scsi/isci/remote_node_context.c:	if (id < ihost->remote_node_entries &&
drivers/scsi/isci/remote_node_context.c:	    ihost->device_table[id])
drivers/scsi/isci/remote_node_context.c:		return &ihost->remote_node_context_table[id];
drivers/scsi/isci/remote_node_context.c:			ihost->user_parameters.stp_max_occupancy_timeout;
drivers/scsi/isci/remote_node_context.c:			ihost->user_parameters.stp_inactivity_timeout;
drivers/scsi/isci/remote_node_context.c:			ihost->user_parameters.ssp_max_occupancy_timeout;
drivers/scsi/isci/remote_node_context.c:			ihost->user_parameters.ssp_inactivity_timeout;
drivers/scsi/isci/request.c:			 (void *) &ihost->task_context_table[0];
drivers/scsi/isci/request.c:		return ihost->task_context_dma + offset;
drivers/scsi/isci/request.c:			 (void *) &ihost->task_context_table[0];
drivers/scsi/isci/request.c:		return ihost->task_context_dma + offset;
drivers/scsi/isci/request.c:		dma_addr = dma_map_single(&ihost->pdev->dev,
drivers/scsi/isci/request.c:	if (readl(&ihost->smu_registers->address_modifier) == 0) {
drivers/scsi/isci/request.c:		void __iomem *scu_reg_base = ihost->scu_registers;
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev, "%s: (%x) in wrong state %s\n",
drivers/scsi/isci/request.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:	status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:		sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:	status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:		dev_err(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:		sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev, "%s: %x in wrong state %s\n",
drivers/scsi/isci/request.c:	dev_dbg(&request->isci_host->pdev->dev,
drivers/scsi/isci/request.c:			 &host->requests_to_complete);
drivers/scsi/isci/request.c:			 &host->requests_to_errorback);
drivers/scsi/isci/request.c:			 &host->requests_to_errorback);
drivers/scsi/isci/request.c:	dev_dbg(&host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:								 &ihost->pdev->dev);
drivers/scsi/isci/request.c:				dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:				dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dma_unmap_single(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dma_unmap_sg(&ihost->pdev->dev, task->scatter,
drivers/scsi/isci/request.c:		dma_unmap_sg(&ihost->pdev->dev, sg, 1, DMA_TO_DEVICE);
drivers/scsi/isci/request.c:	dev_dbg(&request->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	struct device *dev = &ireq->isci_host->pdev->dev;
drivers/scsi/isci/request.c:		dev_dbg(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:	ireq = ihost->reqs[ISCI_TAG_TCI(tag)];
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/request.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/request.h:	dev_dbg(&isci_request->isci_host->pdev->dev,
drivers/scsi/isci/request.h:	dev_dbg(&isci_request->isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: num=%d\n", __func__, num);
drivers/scsi/isci/task.c:		spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:			spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:			spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev, "%s: tmf_code %d, managed tag %#x\n",
drivers/scsi/isci/task.c:	dev_warn(&ihost->pdev->dev, "task context unrecoverable (tag: %#x)\n",
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:			spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:			spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c: *    state is changed to aborted. NOTE: isci_host->scic_lock MUST BE HELD
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:				spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:				spin_unlock_irqrestore(&ihost->scic_lock,
drivers/scsi/isci/task.c:					dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:				spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:				spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev, "%s: No dev\n", __func__);
drivers/scsi/isci/task.c:	dev_dbg(&old_request->isci_host->pdev->dev,
drivers/scsi/isci/task.c:			dev_dbg(&old_request->isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&old_request->isci_host->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:	spin_lock_irqsave(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
drivers/scsi/isci/task.c:			dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: idev %p\n", __func__, idev);
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		struct isci_phy *iphy = &ihost->phys[phy->number];
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: idev %p complete.\n", __func__, idev);
drivers/scsi/isci/task.c:	spin_lock_irqsave(&ihost->scic_lock, flags);
drivers/scsi/isci/task.c:	spin_unlock_irqrestore(&ihost->scic_lock, flags);
drivers/scsi/isci/task.h:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.h:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/unsolicited_frame_control.c:	struct sci_unsolicited_frame_control *uf_control = &ihost->uf_control;
drivers/scsi/isci/unsolicited_frame_control.c:	virt = dmam_alloc_coherent(&ihost->pdev->dev, size, &dma, GFP_KERNEL);
drivers/scsi/iscsi_tcp.c:	struct iscsi_session *session = tcp_sw_host->session;
drivers/scsi/iscsi_tcp.c:	shost->transportt = iscsi_sw_tcp_scsi_transport;
drivers/scsi/iscsi_tcp.c:	shost->cmd_per_lun = qdepth;
drivers/scsi/iscsi_tcp.c:	shost->max_lun = iscsi_max_lun;
drivers/scsi/iscsi_tcp.c:	shost->max_id = 0;
drivers/scsi/iscsi_tcp.c:	shost->max_channel = 0;
drivers/scsi/iscsi_tcp.c:	shost->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;
drivers/scsi/iscsi_tcp.c:	tcp_sw_host->session = session;
drivers/scsi/iscsi_tcp.c:	shost->can_queue = session->scsi_cmds_max;
drivers/scsi/jazz_esp.c:	host->max_id = 8;
drivers/scsi/jazz_esp.c:	host->irq = platform_get_irq(dev, 0);
drivers/scsi/jazz_esp.c:	err = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, "ESP", esp);
drivers/scsi/jazz_esp.c:	esp->host->this_id = esp->scsi_id;
drivers/scsi/jazz_esp.c:	free_irq(host->irq, esp);
drivers/scsi/jazz_esp.c:	unsigned int irq = esp->host->irq;
drivers/scsi/lasi700.c:	host->this_id = 7;
drivers/scsi/lasi700.c:	host->base = base;
drivers/scsi/lasi700.c:	host->irq = dev->irq;
drivers/scsi/lasi700.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/lasi700.c:	free_irq(host->irq, host);
drivers/scsi/libfc/fc_fcp.c:	spin_lock_irqsave(lport->host->host_lock, flags);
drivers/scsi/libfc/fc_fcp.c:	can_queue = lport->host->can_queue << 1;
drivers/scsi/libfc/fc_fcp.c:	lport->host->can_queue = can_queue;
drivers/scsi/libfc/fc_fcp.c:	spin_unlock_irqrestore(lport->host->host_lock, flags);
drivers/scsi/libfc/fc_fcp.c:	spin_lock_irqsave(lport->host->host_lock, flags);
drivers/scsi/libfc/fc_fcp.c:	can_queue = lport->host->can_queue;
drivers/scsi/libfc/fc_fcp.c:	lport->host->can_queue = can_queue;
drivers/scsi/libfc/fc_fcp.c:	spin_unlock_irqrestore(lport->host->host_lock, flags);
drivers/scsi/libfc/fc_fcp.c:	si->max_can_queue = lport->host->can_queue;
drivers/scsi/libfc/fc_libfc.h:				(lport)->host->host_no,			\
drivers/scsi/libfc/fc_libfc.h:				fc_disc_lport(disc)->host->host_no,	\
drivers/scsi/libfc/fc_libfc.h:				(lport)->host->host_no,			\
drivers/scsi/libfc/fc_libfc.h:				(pkt)->lp->host->host_no,		\
drivers/scsi/libfc/fc_libfc.h:				(pkt)->lp->host->host_no,		\
drivers/scsi/libfc/fc_libfc.h:				(exch)->lp->host->host_no,		\
drivers/scsi/libfc/fc_libfc.h:				(lport)->host->host_no,	##args))
drivers/scsi/libfc/fc_lport.c:	       lport->host->host_no, lport->port_id);
drivers/scsi/libfc/fc_lport.c:	       lport->host->host_no, lport->port_id);
drivers/scsi/libfc/fc_lport.c:		       lport->host->host_no, lport->port_id);
drivers/scsi/libfc/fc_lport.c:		       lport->host->host_no, port_id);
drivers/scsi/libfc/fc_lport.c:		       lport->host->host_no, remote_wwpn);
drivers/scsi/libfc/fc_lport.c:		       lport->host->host_no, did);
drivers/scsi/libfc/fc_npiv.c:	vn_port = libfc_host_alloc(shost->hostt, privsize);
drivers/scsi/libiscsi.c:	if (ihost->workq)
drivers/scsi/libiscsi.c:		queue_work(ihost->workq, &conn->xmitwork);
drivers/scsi/libiscsi.c:	if (!ihost->workq) {
drivers/scsi/libiscsi.c:	if (!ihost->workq) {
drivers/scsi/libiscsi.c:	if (ihost->workq)
drivers/scsi/libiscsi.c:		flush_workqueue(ihost->workq);
drivers/scsi/libiscsi.c:	if (!shost->can_queue)
drivers/scsi/libiscsi.c:		shost->can_queue = ISCSI_DEF_XMIT_CMDS_MAX;
drivers/scsi/libiscsi.c:	if (!shost->cmd_per_lun)
drivers/scsi/libiscsi.c:		shost->cmd_per_lun = ISCSI_DEF_CMD_PER_LUN;
drivers/scsi/libiscsi.c:	if (!shost->transportt->eh_timed_out)
drivers/scsi/libiscsi.c:		shost->transportt->eh_timed_out = iscsi_eh_cmd_timed_out;
drivers/scsi/libiscsi.c:		snprintf(ihost->workq_name, sizeof(ihost->workq_name),
drivers/scsi/libiscsi.c:			"iscsi_q_%d", shost->host_no);
drivers/scsi/libiscsi.c:		ihost->workq = create_singlethread_workqueue(ihost->workq_name);
drivers/scsi/libiscsi.c:		if (!ihost->workq)
drivers/scsi/libiscsi.c:	spin_lock_init(&ihost->lock);
drivers/scsi/libiscsi.c:	ihost->state = ISCSI_HOST_SETUP;
drivers/scsi/libiscsi.c:	ihost->num_sessions = 0;
drivers/scsi/libiscsi.c:	init_waitqueue_head(&ihost->session_removal_wq);
drivers/scsi/libiscsi.c:	spin_lock_irqsave(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	ihost->state = ISCSI_HOST_REMOVED;
drivers/scsi/libiscsi.c:	spin_unlock_irqrestore(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	wait_event_interruptible(ihost->session_removal_wq,
drivers/scsi/libiscsi.c:				 ihost->num_sessions == 0);
drivers/scsi/libiscsi.c:	if (ihost->workq)
drivers/scsi/libiscsi.c:		destroy_workqueue(ihost->workq);
drivers/scsi/libiscsi.c:	kfree(ihost->netdev);
drivers/scsi/libiscsi.c:	kfree(ihost->hwaddress);
drivers/scsi/libiscsi.c:	kfree(ihost->initiatorname);
drivers/scsi/libiscsi.c:	spin_lock_irqsave(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	ihost->num_sessions--;
drivers/scsi/libiscsi.c:	if (ihost->num_sessions == 0)
drivers/scsi/libiscsi.c:		wake_up(&ihost->session_removal_wq);
drivers/scsi/libiscsi.c:	spin_unlock_irqrestore(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	spin_lock_irqsave(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	if (ihost->state == ISCSI_HOST_REMOVED) {
drivers/scsi/libiscsi.c:		spin_unlock_irqrestore(&ihost->lock, flags);
drivers/scsi/libiscsi.c:	ihost->num_sessions++;
drivers/scsi/libiscsi.c:	spin_unlock_irqrestore(&ihost->lock, flags);
drivers/scsi/libiscsi.c:		spin_lock_irqsave(session->host->host_lock, flags);
drivers/scsi/libiscsi.c:		if (!session->host->host_busy) { /* OK for ERL == 0 */
drivers/scsi/libiscsi.c:			spin_unlock_irqrestore(session->host->host_lock, flags);
drivers/scsi/libiscsi.c:		spin_unlock_irqrestore(session->host->host_lock, flags);
drivers/scsi/libiscsi.c:				  session->host->host_busy,
drivers/scsi/libiscsi.c:				  session->host->host_failed);
drivers/scsi/libiscsi.c:		len = sprintf(buf, "%s\n", ihost->netdev);
drivers/scsi/libiscsi.c:		len = sprintf(buf, "%s\n", ihost->hwaddress);
drivers/scsi/libiscsi.c:		len = sprintf(buf, "%s\n", ihost->initiatorname);
drivers/scsi/libiscsi.c:		return iscsi_switch_str_param(&ihost->netdev, buf);
drivers/scsi/libiscsi.c:		return iscsi_switch_str_param(&ihost->hwaddress, buf);
drivers/scsi/libiscsi.c:		return iscsi_switch_str_param(&ihost->initiatorname, buf);
drivers/scsi/libsas/sas_ata.c:	struct sas_internal *i = to_sas_internal(host->transportt);
drivers/scsi/libsas/sas_ata.c:	return to_sas_internal(dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_discover.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/libsas/sas_discover.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/libsas/sas_event.c:	struct workqueue_struct *wq = ha->core.shost->work_q;
drivers/scsi/libsas/sas_expander.c:		to_sas_internal(dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_host_smp.c:	struct sas_internal *i = to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_host_smp.c:		to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_host_smp.c:		memcpy(resp_data + 12, shost->hostt->name,
drivers/scsi/libsas/sas_init.c:			to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_init.c:			to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_init.c:			to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_init.c:			to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_init.c:			to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_phy.c:		to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_phy.c:		to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_phy.c:		phy->phy = sas_phy_alloc(&sas_ha->core.shost->shost_gendev, i);
drivers/scsi/libsas/sas_port.c:		to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_port.c:		to_sas_internal(sas_ha->core.shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:	struct sas_internal *i = to_sas_internal(host->transportt);
drivers/scsi/libsas/sas_scsi_host.c:		to_sas_internal(task->dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:		to_sas_internal(dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:		to_sas_internal(dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:		to_sas_internal(dev->port->ha->core.shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:	if (!shost->hostt->eh_device_reset_handler)
drivers/scsi/libsas/sas_scsi_host.c:	res = shost->hostt->eh_device_reset_handler(cmd);
drivers/scsi/libsas/sas_scsi_host.c:	if (shost->hostt->eh_bus_reset_handler)
drivers/scsi/libsas/sas_scsi_host.c:		return shost->hostt->eh_bus_reset_handler(cmd);
drivers/scsi/libsas/sas_scsi_host.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/libsas/sas_scsi_host.c:	list_splice_init(&shost->eh_cmd_q, &eh_work_q);
drivers/scsi/libsas/sas_scsi_host.c:	shost->host_eh_scheduled = 0;
drivers/scsi/libsas/sas_scsi_host.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/libsas/sas_scsi_host.c:		    __func__, shost->host_busy, shost->host_failed);
drivers/scsi/libsas/sas_scsi_host.c:		    __func__, shost->host_busy, shost->host_failed);
drivers/scsi/libsas/sas_scsi_host.c:	struct sas_internal *i = to_sas_internal(core->shost->transportt);
drivers/scsi/libsas/sas_scsi_host.c:					 "sas_queue_%d", core->shost->host_no);
drivers/scsi/libsas/sas_scsi_host.c:	res = request_firmware(&fw, "sas_addr", &shost->shost_gendev);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:			spin_lock_irq(v_shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(v_shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_lock_irq(v_shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(v_shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	error = sysfs_create_bin_file(&shost->shost_dev.kobj,
drivers/scsi/lpfc/lpfc_attr.c:	error = sysfs_create_bin_file(&shost->shost_dev.kobj,
drivers/scsi/lpfc/lpfc_attr.c:	error = sysfs_create_bin_file(&shost->shost_dev.kobj,
drivers/scsi/lpfc/lpfc_attr.c:	sysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);
drivers/scsi/lpfc/lpfc_attr.c:	sysfs_remove_bin_file(&shost->shost_dev.kobj,
drivers/scsi/lpfc/lpfc_attr.c:	sysfs_remove_bin_file(&shost->shost_dev.kobj,
drivers/scsi/lpfc/lpfc_attr.c:	sysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_mbox_attr);
drivers/scsi/lpfc/lpfc_attr.c:	sysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_attr.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_attr.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_bsg.c:	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
drivers/scsi/lpfc/lpfc_ct.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_ct.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_debugfs.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_debugfs.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:					spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:					spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_els.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irqsave(shost->host_lock, iflags);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irqrestore(shost->host_lock, iflags);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irqsave(shost->host_lock, iflags);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irqrestore(shost->host_lock, iflags);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_hbadisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_init.c:	shost->unique_id = instance;
drivers/scsi/lpfc/lpfc_init.c:	shost->max_id = LPFC_MAX_TARGET;
drivers/scsi/lpfc/lpfc_init.c:	shost->max_lun = vport->cfg_max_luns;
drivers/scsi/lpfc/lpfc_init.c:	shost->this_id = -1;
drivers/scsi/lpfc/lpfc_init.c:	shost->max_cmd_len = 16;
drivers/scsi/lpfc/lpfc_init.c:		shost->dma_boundary =
drivers/scsi/lpfc/lpfc_init.c:		shost->sg_tablesize = phba->cfg_sg_seg_cnt;
drivers/scsi/lpfc/lpfc_init.c:	shost->can_queue = phba->cfg_hba_queue_depth - 10;
drivers/scsi/lpfc/lpfc_init.c:		shost->transportt = lpfc_vport_transport_template;
drivers/scsi/lpfc/lpfc_init.c:		shost->transportt = lpfc_transport_template;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_init.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_init.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	shost->can_queue = phba->cfg_hba_queue_depth - 10;
drivers/scsi/lpfc/lpfc_init.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_init.c:	struct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:				spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:				spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:			spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_nportdisc.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:			spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:			spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) host->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:		spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;
drivers/scsi/lpfc/lpfc_scsi.c:	struct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;
drivers/scsi/lpfc/lpfc_sli.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:			shost->host_no, ndlp->nlp_DID,
drivers/scsi/lpfc/lpfc_sli.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_sli.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_sli.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_sli.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/lpfc/lpfc_sli.c:				spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:				spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:				spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:				spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:		spin_lock(shost->host_lock);
drivers/scsi/lpfc/lpfc_sli.c:		spin_unlock(shost->host_lock);
drivers/scsi/lpfc/lpfc_vport.c:	struct lpfc_vport *pport = (struct lpfc_vport *) shost->hostdata;
drivers/scsi/lpfc/lpfc_vport.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_vport.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_vport.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/lpfc/lpfc_vport.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/mac53c94.c:	state = (struct fsc_state *) cmd->device->host->hostdata;
drivers/scsi/mac53c94.c:	struct fsc_state *state = (struct fsc_state *) cmd->device->host->hostdata;
drivers/scsi/mac53c94.c:	spin_lock_irqsave(cmd->device->host->host_lock, flags);
drivers/scsi/mac53c94.c:	spin_unlock_irqrestore(cmd->device->host->host_lock, flags);
drivers/scsi/mac53c94.c:	writeb(state->host->this_id | CF1_PAR_ENABLE, &regs->config1);
drivers/scsi/mac53c94.c:	state = (struct fsc_state *) host->hostdata;
drivers/scsi/mac53c94.c:       	dma_cmd_space = kmalloc((host->sg_tablesize + 2) *
drivers/scsi/mac53c94.c:	memset(state->dma_cmds, 0, (host->sg_tablesize + 1)
drivers/scsi/mac_esp.c:	host->max_id = 8;
drivers/scsi/mac_esp.c:	host->use_clustering = DISABLE_CLUSTERING;
drivers/scsi/mac_esp.c:	host->this_id = esp->scsi_id;
drivers/scsi/mac_esp.c:	host->irq = IRQ_MAC_SCSI;
drivers/scsi/mac_esp.c:		err = request_irq(host->irq, mac_scsi_esp_intr, 0, "ESP", NULL);
drivers/scsi/mac_esp.c:		free_irq(host->irq, esp);
drivers/scsi/mac_esp.c:	unsigned int irq = esp->host->irq;
drivers/scsi/megaraid.c:				adapter->host->io_port + MBOX_PORT0);
drivers/scsi/megaraid.c:				adapter->host->io_port + MBOX_PORT1);
drivers/scsi/megaraid.c:				adapter->host->io_port + MBOX_PORT2);
drivers/scsi/megaraid.c:				adapter->host->io_port + MBOX_PORT3);
drivers/scsi/megaraid.c:				adapter->host->io_port + ENABLE_MBOX_REGION);
drivers/scsi/megaraid.c:	adapter->host->max_channel =
drivers/scsi/megaraid.c:	adapter->host->max_id = 16;	/* max targets per channel */
drivers/scsi/megaraid.c:	adapter->host->max_lun = 7;	/* Up to 7 luns for non disk devices */
drivers/scsi/megaraid.c:	adapter->host->cmd_per_lun = max_cmd_per_lun;
drivers/scsi/megaraid.c:	adapter->host->can_queue = adapter->max_cmds - 1;
drivers/scsi/megaraid.c:	adapter->host->sg_tablesize = adapter->sglen;
drivers/scsi/megaraid.c:	adapter = (adapter_t *)scmd->device->host->hostdata;
drivers/scsi/megaraid.c:						adapter->host->host_no,
drivers/scsi/megaraid.c:					adapter->host->host_no,
drivers/scsi/megaraid.c:					adapter->host->host_no,
drivers/scsi/megaraid.c:	adapter = (adapter_t *)host->hostdata;
drivers/scsi/megaraid.c:		 adapter->host->max_id, adapter->host->max_channel,
drivers/scsi/megaraid.c:		 adapter->host->max_lun);
drivers/scsi/megaraid.c:	adapter = (adapter_t *)cmd->device->host->hostdata;
drivers/scsi/megaraid.c:	adapter = (adapter_t *)cmd->device->host->hostdata;
drivers/scsi/megaraid.c:	sprintf(string, "hba%d", adapter->host->host_no);
drivers/scsi/megaraid.c:			adapter->host->irq);
drivers/scsi/megaraid.c:	adapter = (adapter_t *)sdev->host->hostdata;
drivers/scsi/megaraid.c:		adapter->host->this_id = adapter->this_id;
drivers/scsi/megaraid.c:	adapter = (adapter_t *)scmd->device->host->hostdata;
drivers/scsi/megaraid.c:	adapter = (adapter_t *)host->hostdata;
drivers/scsi/megaraid.c:		host->host_no, mega_baseport, irq);
drivers/scsi/megaraid.c:	host->cmd_per_lun = max_cmd_per_lun;
drivers/scsi/megaraid.c:	host->max_sectors = max_sectors_per_io;
drivers/scsi/megaraid.c:	adapter->host->irq = irq;
drivers/scsi/megaraid.c:		adapter->host->base = tbase;
drivers/scsi/megaraid.c:		adapter->host->io_port = tbase;
drivers/scsi/megaraid.c:		adapter->host->n_io_port = 16;
drivers/scsi/megaraid.c:	adapter->host->unique_id = (pci_bus << 8) | pci_dev_func;
drivers/scsi/megaraid.c:	adapter->host->this_id = DEFAULT_INITIATOR_ID;
drivers/scsi/megaraid.c:	free_irq(adapter->host->irq, adapter);
drivers/scsi/megaraid.c:	free_irq(adapter->host->irq, adapter);
drivers/scsi/megaraid.c:	adapter_t *adapter = (adapter_t *)host->hostdata;
drivers/scsi/megaraid.c:		release_mem_region(adapter->host->base, 128);
drivers/scsi/megaraid.c:			sprintf(buf, "hba%d", adapter->host->host_no);
drivers/scsi/megaraid.c:	adapter_t *adapter = (adapter_t *)host->hostdata;
drivers/scsi/megaraid/mega_common.h:#define SCSIHOST2ADAP(host)	(((caddr_t *)(host->hostdata))[0])
drivers/scsi/megaraid/megaraid_mbox.c:	host->irq		= adapter->irq;
drivers/scsi/megaraid/megaraid_mbox.c:	host->unique_id		= adapter->unique_id;
drivers/scsi/megaraid/megaraid_mbox.c:	host->can_queue		= adapter->max_cmds;
drivers/scsi/megaraid/megaraid_mbox.c:	host->this_id		= adapter->init_id;
drivers/scsi/megaraid/megaraid_mbox.c:	host->sg_tablesize	= adapter->sglen;
drivers/scsi/megaraid/megaraid_mbox.c:	host->max_sectors	= adapter->max_sectors;
drivers/scsi/megaraid/megaraid_mbox.c:	host->cmd_per_lun	= adapter->cmd_per_lun;
drivers/scsi/megaraid/megaraid_mbox.c:	host->max_channel	= adapter->max_channel;
drivers/scsi/megaraid/megaraid_mbox.c:	host->max_id		= adapter->max_target;
drivers/scsi/megaraid/megaraid_mbox.c:	host->max_lun		= adapter->max_lun;
drivers/scsi/megaraid/megaraid_mbox.c:					adapter->host->host_no,
drivers/scsi/megaraid/megaraid_mbox.c:				adapter->host->host_no));
drivers/scsi/megaraid/megaraid_mbox.c:				adapter->host->host_no, ss, SCP2CHANNEL(scp),
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->irq		= adapter->host->irq;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->host_no		= adapter->host->host_no;
drivers/scsi/megaraid/megaraid_sas_base.c:	printk(KERN_ERR "\nmegasas[%d]: Dumping Frame Phys Address of all pending cmds in FW\n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:	printk(KERN_ERR "megasas[%d]: Total OS Pending cmds : %d\n",instance->host->host_no,atomic_read(&instance->fw_outstanding));
drivers/scsi/megaraid/megaraid_sas_base.c:		printk(KERN_ERR "\nmegasas[%d]: 64 bit SGLs were sent to FW\n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:		printk(KERN_ERR "\nmegasas[%d]: 32 bit SGLs were sent to FW\n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:	printk(KERN_ERR "megasas[%d]: Pending OS cmds in FW : \n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:		printk(KERN_ERR "megasas[%d]: Frame addr :0x%08lx : ",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);
drivers/scsi/megaraid/megaraid_sas_base.c:			printk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",instance->host->host_no, cmd->frame_count,ldio->cmd,ldio->target_id, ldio->start_lba_lo,ldio->start_lba_hi,ldio->sense_buf_phys_addr_lo,sgcount);
drivers/scsi/megaraid/megaraid_sas_base.c:			printk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",instance->host->host_no,cmd->frame_count,pthru->cmd,pthru->target_id,pthru->lun,pthru->cdb_len , pthru->data_xfer_len,pthru->sense_buf_phys_addr_lo,sgcount);
drivers/scsi/megaraid/megaraid_sas_base.c:	printk(KERN_ERR "\nmegasas[%d]: Pending Internal cmds in FW : \n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:	printk(KERN_ERR "megasas[%d]: Dumping Done.\n\n",instance->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:	    scmd->device->host->hostdata;
drivers/scsi/megaraid/megaraid_sas_base.c:		    (megasas_mgmt_info.instance[i]->host->host_no == host_no))
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = megasas_lookup_instance(sdev->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = megasas_lookup_instance(sdev->host->host_no);
drivers/scsi/megaraid/megaraid_sas_base.c:		spin_lock_irqsave(instance->host->host_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:			instance->host->can_queue =
drivers/scsi/megaraid/megaraid_sas_base.c:			instance->host->can_queue =
drivers/scsi/megaraid/megaraid_sas_base.c:		spin_unlock_irqrestore(instance->host->host_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = (struct megasas_instance *)scmd->device->host->hostdata;
drivers/scsi/megaraid/megaraid_sas_base.c: * Sets the FW busy flag and reduces the host->can_queue if the
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = (struct megasas_instance *)scmd->device->host->hostdata;
drivers/scsi/megaraid/megaraid_sas_base.c:		spin_lock_irqsave(instance->host->host_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:		instance->host->can_queue = 16;
drivers/scsi/megaraid/megaraid_sas_base.c:		spin_unlock_irqrestore(instance->host->host_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = (struct megasas_instance *)scmd->device->host->hostdata;
drivers/scsi/megaraid/megaraid_sas_base.c:	if (queue_depth > sdev->host->can_queue)
drivers/scsi/megaraid/megaraid_sas_base.c:		queue_depth = sdev->host->can_queue;
drivers/scsi/megaraid/megaraid_sas_base.c:			spin_lock_irqsave(instance->host->host_lock, flags);
drivers/scsi/megaraid/megaraid_sas_base.c:						instance->host->host_lock,
drivers/scsi/megaraid/megaraid_sas_base.c:			spin_unlock_irqrestore(instance->host->host_lock,
drivers/scsi/megaraid/megaraid_sas_base.c:	host->irq = instance->pdev->irq;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->unique_id = instance->unique_id;
drivers/scsi/megaraid/megaraid_sas_base.c:		host->can_queue =
drivers/scsi/megaraid/megaraid_sas_base.c:		host->can_queue =
drivers/scsi/megaraid/megaraid_sas_base.c:	host->this_id = instance->init_id;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->sg_tablesize = instance->max_num_sge;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->max_sectors = instance->max_sectors_per_req;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->max_channel = MEGASAS_MAX_CHANNELS - 1;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->max_lun = MEGASAS_MAX_LUN;
drivers/scsi/megaraid/megaraid_sas_base.c:	host->max_cmd_len = 16;
drivers/scsi/megaraid/megaraid_sas_base.c:		host->hostt->eh_device_reset_handler = NULL;
drivers/scsi/megaraid/megaraid_sas_base.c:		host->hostt->eh_bus_reset_handler = NULL;
drivers/scsi/megaraid/megaraid_sas_base.c:	instance = (struct megasas_instance *)host->hostdata;
drivers/scsi/megaraid/megaraid_sas_fusion.c:	instance = (struct megasas_instance *)shost->hostdata;
drivers/scsi/mesh.c:	out_8(&mr->source_id, ms->host->this_id);
drivers/scsi/mesh.c:		ms->conn_tgt = ms->host->this_id;
drivers/scsi/mesh.c:		if ((b & (1 << t)) != 0 && t != ms->host->this_id)
drivers/scsi/mesh.c:	if (b != (1 << t) + (1 << ms->host->this_id)) {
drivers/scsi/mesh.c:		ms->conn_tgt = ms->host->this_id;
drivers/scsi/mesh.c:	ms = (struct mesh_state *) cmd->device->host->hostdata;
drivers/scsi/mesh.c:	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
drivers/scsi/mesh.c:	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
drivers/scsi/mesh.c:	spin_lock_irqsave(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	out_8(&mr->source_id, ms->host->this_id);
drivers/scsi/mesh.c:	spin_unlock_irqrestore(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_lock_irqsave(ms->host->host_lock, flags);
drivers/scsi/mesh.c:		spin_unlock_irqrestore(ms->host->host_lock, flags);
drivers/scsi/mesh.c:		spin_lock_irqsave(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_unlock_irqrestore(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_lock_irqsave(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_unlock_irqrestore(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_lock_irqsave(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	spin_unlock_irqrestore(ms->host->host_lock, flags);
drivers/scsi/mesh.c:	mesh_host->base = macio_resource_start(mdev, 0);
drivers/scsi/mesh.c:	mesh_host->irq = macio_irq(mdev, 0);
drivers/scsi/mesh.c:       	ms = (struct mesh_state *) mesh_host->hostdata;
drivers/scsi/mesh.c:	ms->dma_cmd_size = (mesh_host->sg_tablesize + 2) * sizeof(struct dbdma_cmd);
drivers/scsi/mpt2sas/mpt2sas_base.c:		ioc->shost->sg_tablesize = (max_sgl_entries <
drivers/scsi/mpt2sas/mpt2sas_base.c:		ioc->shost->sg_tablesize = MPT2SAS_SG_DEPTH;
drivers/scsi/mpt2sas/mpt2sas_base.c:	chains_needed_per_io = ((ioc->shost->sg_tablesize -
drivers/scsi/mpt2sas/mpt2sas_base.c:		ioc->shost->sg_tablesize = min_t(u16,
drivers/scsi/mpt2sas/mpt2sas_base.c:		* chains_needed_per_io), ioc->shost->sg_tablesize);
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->max_sges_in_chain_message, ioc->shost->sg_tablesize,
drivers/scsi/mpt2sas/mpt2sas_base.c:	ioc->shost->can_queue = ioc->scsiio_depth - (2);
drivers/scsi/mpt2sas/mpt2sas_base.c:	    "can_queue depth (%d)\n", ioc->name, ioc->shost->can_queue));
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->name, ioc->shost->can_queue, facts->RequestCredit);
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->name, ioc->shost->sg_tablesize);
drivers/scsi/mpt2sas/mpt2sas_base.c:	ioc->shost->max_id = -1;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	max_depth = shost->can_queue;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	ioc->sas_hba.parent_dev = &ioc->shost->shost_gendev;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	shost->max_cmd_len = 32;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	shost->max_lun = max_lun;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	shost->transportt = mpt2sas_transport_template;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	shost->unique_id = ioc->id;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:			shost->max_sectors = 64;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:			shost->max_sectors = 32767;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:			shost->max_sectors = max_sectors & 0xFFFE;
drivers/scsi/mpt2sas/mpt2sas_scsih.c:			    "set to %d\n", ioc->name, shost->max_sectors);
drivers/scsi/mvme147.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/mvme147.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/mvme16x_scsi.c:	host->this_id = 7;
drivers/scsi/mvme16x_scsi.c:	host->base = 0xfff47000UL;
drivers/scsi/mvme16x_scsi.c:	host->irq = MVME16x_IRQ_SCSI;
drivers/scsi/mvme16x_scsi.c:	if (request_irq(host->irq, NCR_700_intr, 0, "mvme16x-scsi", host)) {
drivers/scsi/mvme16x_scsi.c:	free_irq(host->irq, host);
drivers/scsi/mvsas/mv_init.c:	sas_phy->ha = (struct sas_ha_struct *)mvi->shost->hostdata;
drivers/scsi/mvsas/mv_init.c:	shost->transportt = mvs_stt;
drivers/scsi/mvsas/mv_init.c:	shost->max_id = MVS_MAX_DEVICES;
drivers/scsi/mvsas/mv_init.c:	shost->max_lun = ~0;
drivers/scsi/mvsas/mv_init.c:	shost->max_channel = 1;
drivers/scsi/mvsas/mv_init.c:	shost->max_cmd_len = 16;
drivers/scsi/mvsas/mv_init.c:	shost->sg_tablesize = min_t(u16, SG_ALL, MVS_MAX_SG);
drivers/scsi/mvsas/mv_init.c:	shost->can_queue = can_queue;
drivers/scsi/mvsas/mv_init.c:	mvi->shost->cmd_per_lun = MVS_QUEUE_SIZE;
drivers/scsi/mvsas/mv_sas.h:	/* host-wide lock */
drivers/scsi/mvumi.c:	mhba = (struct mvumi_hba *) scmd->device->host->hostdata;
drivers/scsi/mvumi.c:	spin_lock_irqsave(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	spin_unlock_irqrestore(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:		spin_lock_irqsave(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:		spin_unlock_irqrestore(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	spin_lock_irqsave(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:		spin_unlock_irqrestore(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	spin_unlock_irqrestore(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	mhba = (struct mvumi_hba *) sdev->host->hostdata;
drivers/scsi/mvumi.c:	spin_lock_irqsave(shost->host_lock, irq_flags);
drivers/scsi/mvumi.c:	mhba = (struct mvumi_hba *) shost->hostdata;
drivers/scsi/mvumi.c:		spin_unlock_irqrestore(shost->host_lock, irq_flags);
drivers/scsi/mvumi.c:	spin_unlock_irqrestore(shost->host_lock, irq_flags);
drivers/scsi/mvumi.c:	spin_unlock_irqrestore(shost->host_lock, irq_flags);
drivers/scsi/mvumi.c:	spin_lock_irqsave(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	spin_unlock_irqrestore(mhba->shost->host_lock, flags);
drivers/scsi/mvumi.c:	host->irq = mhba->pdev->irq;
drivers/scsi/mvumi.c:	host->unique_id = mhba->unique_id;
drivers/scsi/mvumi.c:	host->can_queue = (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;
drivers/scsi/mvumi.c:	host->sg_tablesize = mhba->max_sge > max_sg ? max_sg : mhba->max_sge;
drivers/scsi/mvumi.c:	host->max_sectors = mhba->max_transfer_size / 512;
drivers/scsi/mvumi.c:	host->cmd_per_lun =  (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;
drivers/scsi/mvumi.c:	host->max_id = mhba->max_target_id;
drivers/scsi/mvumi.c:	host->max_cmd_len = MAX_COMMAND_SIZE;
drivers/scsi/mvumi.c:	host->transportt = &mvumi_transport_template;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *) host->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *) host->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:     struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:     struct host_data *host_data = (struct host_data *)shost->hostdata;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct host_data *host_data = (struct host_data *)host->hostdata;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *)shost->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *)shost->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *)shost->hostdata)->ncb;
drivers/scsi/ncr53c8xx.c:	struct ncb *np = ((struct host_data *)shost->hostdata)->ncb;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int base = SCpnt->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data  *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int	base    = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	unsigned int	host_id = SCpnt->device->host->this_id;
drivers/scsi/nsp32.c:	nsp32_hw_data  *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int	base    = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	unsigned int	host_id = SCpnt->device->host->this_id;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int   host_id = SCpnt->device->host->this_id;
drivers/scsi/nsp32.c:	unsigned int   base    = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	if (scmd_id(SCpnt) == SCpnt->device->host->this_id) {
drivers/scsi/nsp32.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/nsp32.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/nsp32.c:	hostno = host->host_no;
drivers/scsi/nsp32.c:	data = (nsp32_hw_data *)host->hostdata;
drivers/scsi/nsp32.c:	base = host->io_port;
drivers/scsi/nsp32.c:	SPRINTF("IRQ:                   %d\n",		host->irq);
drivers/scsi/nsp32.c:	SPRINTF("IO:                    0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);
drivers/scsi/nsp32.c:	SPRINTF("MMIO(virtual address): 0x%lx-0x%lx\n",	host->base, host->base + data->MmioLength - 1);
drivers/scsi/nsp32.c:	SPRINTF("sg_tablesize:          %d\n",		host->sg_tablesize);
drivers/scsi/nsp32.c:		if (id == host->this_id) {
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int   base = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int base   = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int base   = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int   base = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data   *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	data = (nsp32_hw_data *)host->hostdata;
drivers/scsi/nsp32.c:	host->irq       = data->IrqNumber;
drivers/scsi/nsp32.c:	host->io_port   = data->BaseAddress;
drivers/scsi/nsp32.c:	host->unique_id = data->BaseAddress;
drivers/scsi/nsp32.c:	host->n_io_port	= data->NumAddress;
drivers/scsi/nsp32.c:	host->base      = (unsigned long)data->MmioAddress;
drivers/scsi/nsp32.c:		 host->irq, host->io_port, host->n_io_port);
drivers/scsi/nsp32.c:	ret = request_irq(host->irq, do_nsp32_isr, IRQF_SHARED, "nsp32", data);
drivers/scsi/nsp32.c:			  "SCSI PCI controller. Interrupt: %d", host->irq);
drivers/scsi/nsp32.c:	res = request_region(host->io_port, host->n_io_port, "nsp32");
drivers/scsi/nsp32.c:	release_region(host->io_port, host->n_io_port);
drivers/scsi/nsp32.c:	free_irq(host->irq, data);
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)host->hostdata;
drivers/scsi/nsp32.c:	if (host->irq) {
drivers/scsi/nsp32.c:		free_irq(host->irq, data);
drivers/scsi/nsp32.c:	if (host->io_port && host->n_io_port) {
drivers/scsi/nsp32.c:		release_region(host->io_port, host->n_io_port);
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int   base = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data *data = (nsp32_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/nsp32.c:	unsigned int   base = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/nsp32.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/nsp32.c:	unsigned int      base = SCpnt->device->host->io_port;
drivers/scsi/nsp32.c:	nsp32_hw_data    *data = (nsp32_hw_data *)host->hostdata;
drivers/scsi/nsp32.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/nsp32.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/nsp32.c:	nsp32_hw_data    *data = (nsp32_hw_data *)host->hostdata;
drivers/scsi/osst.c:#define OSST_FW_NEED_POLL(x,d) ((x) >= OSST_FW_NEED_POLL_MIN && (x) <= OSST_FW_NEED_POLL_MAX && d->host->this_id != 7)
drivers/scsi/osst.c:	if (sdev->host->hostt->compat_ioctl) {
drivers/scsi/osst.c:		ret = sdev->host->hostt->compat_ioctl(sdev, cmd_in, (void __user *)arg);
drivers/scsi/osst.c:	i = SDp->host->sg_tablesize;
drivers/scsi/osst.c:	buffer = new_tape_buffer(1, SDp->host->unchecked_isa_dma, i);
drivers/scsi/pas16.c:	if (shost->irq)
drivers/scsi/pas16.c:		free_irq(shost->irq, shost);
drivers/scsi/pas16.c:	if (shost->dma_channel != 0xff)
drivers/scsi/pas16.c:		free_dma(shost->dma_channel);
drivers/scsi/pas16.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/pas16.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	/*unsigned int host_id = SCpnt->device->host->this_id;*/
drivers/scsi/pcmcia/nsp_cs.c:	/*unsigned int base    = SCpnt->device->host->io_port;*/
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  host_id	 = SCpnt->device->host->this_id;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base	 = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data  *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data           *data   = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base	 = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data  *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base    = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  host_id = SCpnt->device->host->this_id;
drivers/scsi/pcmcia/nsp_cs.c:	//nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base      = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned long mmio_base = SCpnt->device->host->base;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data  *data      = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int  base      = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned long mmio_base = SCpnt->device->host->base;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data  *data      = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	unsigned int   base   = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:		data = (nsp_hw_data *)info->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	memcpy(host->hostdata, data_b, sizeof(nsp_hw_data));
drivers/scsi/pcmcia/nsp_cs.c:	data = (nsp_hw_data *)host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_dbg(NSP_DEBUG_INIT, "irq=%d,%d", data_b->IrqNumber, ((nsp_hw_data *)host->hostdata)->IrqNumber);
drivers/scsi/pcmcia/nsp_cs.c:	host->unique_id	  = data->BaseAddress;
drivers/scsi/pcmcia/nsp_cs.c:	host->io_port	  = data->BaseAddress;
drivers/scsi/pcmcia/nsp_cs.c:	host->n_io_port	  = data->NumAddress;
drivers/scsi/pcmcia/nsp_cs.c:	host->irq	  = data->IrqNumber;
drivers/scsi/pcmcia/nsp_cs.c:	host->base        = data->MmioAddress;
drivers/scsi/pcmcia/nsp_cs.c:		 host->io_port, host->io_port + host->n_io_port - 1,
drivers/scsi/pcmcia/nsp_cs.c:		 host->base,
drivers/scsi/pcmcia/nsp_cs.c:		 host->irq);
drivers/scsi/pcmcia/nsp_cs.c:	hostno = host->host_no;
drivers/scsi/pcmcia/nsp_cs.c:	data = (nsp_hw_data *)host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	SPRINTF("IRQ:                   %d\n",          host->irq);
drivers/scsi/pcmcia/nsp_cs.c:	SPRINTF("IO:                    0x%lx-0x%lx\n", host->io_port, host->io_port + host->n_io_port - 1);
drivers/scsi/pcmcia/nsp_cs.c:	SPRINTF("MMIO(virtual address): 0x%lx-0x%lx\n", host->base, host->base + data->MmioLength - 1);
drivers/scsi/pcmcia/nsp_cs.c:	SPRINTF("sg_tablesize:          %d\n",          host->sg_tablesize);
drivers/scsi/pcmcia/nsp_cs.c:		if (id == host->this_id) {
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:		data = (nsp_hw_data *)info->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:		data = (nsp_hw_data *)info->host->hostdata;
drivers/scsi/pcmcia/nsp_cs.c:		data = (nsp_hw_data *)info->host->hostdata;
drivers/scsi/pcmcia/nsp_message.c:	unsigned int  base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/nsp_message.c:	nsp_hw_data  *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/nsp_message.c:	nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/qlogic_stub.c:	qinitid = host->this_id;
drivers/scsi/pcmcia/qlogic_stub.c:	host->name = qlogic_name;
drivers/scsi/pcmcia/qlogic_stub.c:	shost->io_port = qbase;
drivers/scsi/pcmcia/qlogic_stub.c:	shost->n_io_port = 16;
drivers/scsi/pcmcia/qlogic_stub.c:	shost->dma_channel = -1;
drivers/scsi/pcmcia/qlogic_stub.c:		shost->irq = qlirq;
drivers/scsi/pcmcia/sym53c500_cs.c:	if (shost->irq)
drivers/scsi/pcmcia/sym53c500_cs.c:		free_irq(shost->irq, shost);
drivers/scsi/pcmcia/sym53c500_cs.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/pcmcia/sym53c500_cs.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/pcmcia/sym53c500_cs.c:	    (struct sym53c500_data *)SChost->hostdata;
drivers/scsi/pcmcia/sym53c500_cs.c:	    SChost->io_port, SChost->irq, data->fast_pio ? "fast" : "slow");
drivers/scsi/pcmcia/sym53c500_cs.c:	int port_base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/sym53c500_cs.c:	    (struct sym53c500_data *)SCpnt->device->host->hostdata;
drivers/scsi/pcmcia/sym53c500_cs.c:	int port_base = SCpnt->device->host->io_port;
drivers/scsi/pcmcia/sym53c500_cs.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/pcmcia/sym53c500_cs.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/pcmcia/sym53c500_cs.c:	data = (struct sym53c500_data *)host->hostdata;
drivers/scsi/pcmcia/sym53c500_cs.c:	host->unique_id = port_base;
drivers/scsi/pcmcia/sym53c500_cs.c:	host->irq = irq_level;
drivers/scsi/pcmcia/sym53c500_cs.c:	host->io_port = port_base;
drivers/scsi/pcmcia/sym53c500_cs.c:	host->n_io_port = 0x10;
drivers/scsi/pcmcia/sym53c500_cs.c:	host->dma_channel = -1;
drivers/scsi/pm8001/pm8001_init.c:	sas_phy->ha = (struct sas_ha_struct *)pm8001_ha->shost->hostdata;
drivers/scsi/pm8001/pm8001_init.c:	shost->transportt = pm8001_stt;
drivers/scsi/pm8001/pm8001_init.c:	shost->max_id = PM8001_MAX_DEVICES;
drivers/scsi/pm8001/pm8001_init.c:	shost->max_lun = 8;
drivers/scsi/pm8001/pm8001_init.c:	shost->max_channel = 0;
drivers/scsi/pm8001/pm8001_init.c:	shost->unique_id = pm8001_id;
drivers/scsi/pm8001/pm8001_init.c:	shost->max_cmd_len = 16;
drivers/scsi/pm8001/pm8001_init.c:	shost->can_queue = PM8001_CAN_QUEUE;
drivers/scsi/pm8001/pm8001_init.c:	shost->cmd_per_lun = 32;
drivers/scsi/pm8001/pm8001_sas.h:	spinlock_t		lock;/* host-wide lock */
drivers/scsi/pmcraid.c: * to host->cmd_per_lun value
drivers/scsi/pmcraid.c:		     scsi_dev->host->unique_id,
drivers/scsi/pmcraid.c:					scsi_dev->host->cmd_per_lun);
drivers/scsi/pmcraid.c:					scsi_dev->host->cmd_per_lun);
drivers/scsi/pmcraid.c:			pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:			pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	aen_msg->hostno = (pinstance->host->unique_id << 16 |
drivers/scsi/pmcraid.c:		 pinstance->host->unique_id,
drivers/scsi/pmcraid.c:			spin_lock_irqsave(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:			spin_lock_irqsave(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, host_lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)(scmd->device->host->hostdata);
drivers/scsi/pmcraid.c: * this routine within host->lock. Some of the functions called by queuecommand
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;
drivers/scsi/pmcraid.c:		     scsi_cmd->cmnd[0], pinstance->host->unique_id,
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)shost->hostdata;
drivers/scsi/pmcraid.c:	pinstance = (struct pmcraid_instance *)shost->hostdata;
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)shost->hostdata;
drivers/scsi/pmcraid.c:				spin_lock_irqsave(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:					pinstance->host->host_lock,
drivers/scsi/pmcraid.c:		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
drivers/scsi/pmcraid.c:			spin_lock_irqsave(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:						pinstance->host->host_lock,
drivers/scsi/pmcraid.c:						pinstance->host->host_lock,
drivers/scsi/pmcraid.c:			spin_lock_irqsave(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:			spin_unlock_irqrestore(pinstance->host->host_lock,
drivers/scsi/pmcraid.c:		pinstance->host->unique_id);
drivers/scsi/pmcraid.c:		pinstance->host->unique_id);
drivers/scsi/pmcraid.c:		(struct pmcraid_instance *)host->hostdata;
drivers/scsi/pmcraid.c:	spin_lock_irqsave(pinstance->host->host_lock, flags);
drivers/scsi/pmcraid.c:	spin_unlock_irqrestore(pinstance->host->host_lock, flags);
drivers/scsi/pmcraid.c:	host->max_id = PMCRAID_MAX_NUM_TARGETS_PER_BUS;
drivers/scsi/pmcraid.c:	host->max_lun = PMCRAID_MAX_NUM_LUNS_PER_TARGET;
drivers/scsi/pmcraid.c:	host->unique_id = host->host_no;
drivers/scsi/pmcraid.c:	host->max_channel = PMCRAID_MAX_BUS_TO_SCAN;
drivers/scsi/pmcraid.c:	host->max_cmd_len = PMCRAID_MAX_CDB_LEN;
drivers/scsi/pmcraid.c:	pinstance = (struct pmcraid_instance *)host->hostdata;
drivers/scsi/ppa.c:	return *(ppa_struct **)&host->hostdata;
drivers/scsi/ppa.c:	host->io_port = pb->base;
drivers/scsi/ppa.c:	host->n_io_port = ports;
drivers/scsi/ppa.c:	host->dma_channel = -1;
drivers/scsi/ppa.c:	host->unique_id = pb->number;
drivers/scsi/ppa.c:	*(ppa_struct **)&host->hostdata = dev;
drivers/scsi/ps3rom.c:	host->max_id = 1;
drivers/scsi/ps3rom.c:	host->max_lun = 1;
drivers/scsi/qla1280.c:	- Grab host->host_lock while calling qla1280_isr() from abort()
drivers/scsi/qla1280.c:	ha = (struct scsi_qla_host *)host->hostdata;
drivers/scsi/qla1280.c:	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
drivers/scsi/qla1280.c:	spin_unlock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock(ha->host->host_lock);
drivers/scsi/qla1280.c:	ha = (struct scsi_qla_host *)device->host->hostdata;
drivers/scsi/qla1280.c:	spin_lock_irqsave(ha->host->host_lock, flags);
drivers/scsi/qla1280.c:	spin_unlock_irqrestore(ha->host->host_lock, flags);
drivers/scsi/qla1280.c:	spin_lock_irqsave(ha->host->host_lock, flags);
drivers/scsi/qla1280.c:	spin_unlock_irqrestore(ha->host->host_lock, flags);
drivers/scsi/qla1280.c:	spin_unlock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_unlock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	spin_lock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:		spin_unlock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:		spin_lock_irq(ha->host->host_lock);
drivers/scsi/qla1280.c:	ha = (struct scsi_qla_host *)host->hostdata;
drivers/scsi/qla1280.c:	ha = (struct scsi_qla_host *)host->hostdata;
drivers/scsi/qla1280.c:	ha->host_no = host->host_no;
drivers/scsi/qla1280.c:	host->irq = pdev->irq;
drivers/scsi/qla1280.c:	host->max_channel = bdp->numPorts - 1;
drivers/scsi/qla1280.c:	host->max_lun = MAX_LUNS - 1;
drivers/scsi/qla1280.c:	host->max_id = MAX_TARGETS;
drivers/scsi/qla1280.c:	host->max_sectors = 1024;
drivers/scsi/qla1280.c:	host->unique_id = host->host_no;
drivers/scsi/qla1280.c:	host->base = (unsigned long)ha->mmpbase;
drivers/scsi/qla1280.c:	host->io_port = pci_resource_start(ha->pdev, 0);
drivers/scsi/qla1280.c:	if (!request_region(host->io_port, 0xff, "qla1280")) {
drivers/scsi/qla1280.c:		       host->io_port, host->io_port + 0xff);
drivers/scsi/qla1280.c:	ha->iobase = (struct device_reg *)host->io_port;
drivers/scsi/qla1280.c:	host->this_id = ha->bus_settings[0].id;
drivers/scsi/qla1280.c:	release_region(host->io_port, 0xff);
drivers/scsi/qla1280.c:	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
drivers/scsi/qla1280.c:	release_region(host->io_port, 0xff);
drivers/scsi/qla1280.h:#define CDMA_CONF_DIR    BIT_0	/* DMA direction (0=fifo->host 1=host->fifo) */
drivers/scsi/qla1280.h:#define DDMA_CONF_DIR    BIT_0	/* DMA direction (0=fifo->host 1=host->fifo) */
drivers/scsi/qla2xxx/qla_attr.c:		ret = sysfs_create_bin_file(&host->shost_gendev.kobj,
drivers/scsi/qla2xxx/qla_attr.c:		sysfs_remove_bin_file(&host->shost_gendev.kobj,
drivers/scsi/qla2xxx/qla_attr.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/qla2xxx/qla_attr.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qla2xxx/qla_init.c:	 * BIT_7 in the host-parameters section allows for modification to
drivers/scsi/qla2xxx/qla_init.c:	spin_lock_irqsave(fcport->vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_init.c:	spin_unlock_irqrestore(fcport->vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_init.c:	spin_lock_irqsave(fcport->vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_init.c:	spin_unlock_irqrestore(fcport->vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_mid.c:	host->can_queue = base_vha->req->length + 128;
drivers/scsi/qla2xxx/qla_mid.c:	host->this_id = 255;
drivers/scsi/qla2xxx/qla_mid.c:	host->cmd_per_lun = 3;
drivers/scsi/qla2xxx/qla_mid.c:		host->max_cmd_len = 32;
drivers/scsi/qla2xxx/qla_mid.c:		host->max_cmd_len = MAX_CMDSZ;
drivers/scsi/qla2xxx/qla_mid.c:	host->max_channel = MAX_BUSES - 1;
drivers/scsi/qla2xxx/qla_mid.c:	host->max_lun = ql2xmaxlun;
drivers/scsi/qla2xxx/qla_mid.c:	host->unique_id = host->host_no;
drivers/scsi/qla2xxx/qla_mid.c:	host->max_id = ha->max_fibre_devices;
drivers/scsi/qla2xxx/qla_mid.c:	host->transportt = qla2xxx_transport_vport_template;
drivers/scsi/qla2xxx/qla_os.c:	host->can_queue = req->length + 128;
drivers/scsi/qla2xxx/qla_os.c:			host->sg_tablesize = 32;
drivers/scsi/qla2xxx/qla_os.c:			host->sg_tablesize = QLA_SG_ALL;
drivers/scsi/qla2xxx/qla_os.c:	    host->can_queue, base_vha->req,
drivers/scsi/qla2xxx/qla_os.c:	    base_vha->mgmt_svr_loop_id, host->sg_tablesize);
drivers/scsi/qla2xxx/qla_os.c:	host->max_id = ha->max_fibre_devices;
drivers/scsi/qla2xxx/qla_os.c:	host->this_id = 255;
drivers/scsi/qla2xxx/qla_os.c:	host->cmd_per_lun = 3;
drivers/scsi/qla2xxx/qla_os.c:	host->unique_id = host->host_no;
drivers/scsi/qla2xxx/qla_os.c:		host->max_cmd_len = 32;
drivers/scsi/qla2xxx/qla_os.c:		host->max_cmd_len = MAX_CMDSZ;
drivers/scsi/qla2xxx/qla_os.c:	host->max_channel = MAX_BUSES - 1;
drivers/scsi/qla2xxx/qla_os.c:	host->max_lun = ql2xmaxlun;
drivers/scsi/qla2xxx/qla_os.c:	host->transportt = qla2xxx_transport_template;
drivers/scsi/qla2xxx/qla_os.c:	    "max_lun=%d transportt=%p, vendor_id=%llu.\n", host->max_id,
drivers/scsi/qla2xxx/qla_os.c:	    host->this_id, host->cmd_per_lun, host->unique_id,
drivers/scsi/qla2xxx/qla_os.c:	    host->max_cmd_len, host->max_channel, host->max_lun,
drivers/scsi/qla2xxx/qla_os.c:	    host->transportt, sht->vendor_id);
drivers/scsi/qla2xxx/qla_os.c:	base_vha->host->irq = ha->pdev->irq;
drivers/scsi/qla2xxx/qla_os.c:		spin_lock_irqsave(vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_os.c:		spin_unlock_irqrestore(vha->host->host_lock, flags);
drivers/scsi/qla2xxx/qla_os.c:	vha->host_no = host->host_no;
drivers/scsi/qla4xxx/ql4_isr.c:	ha->host->irq = ha->pdev->irq;
drivers/scsi/qla4xxx/ql4_os.c:	ret = device_for_each_child(&shost->shost_gendev, &chap_tbl_idx,
drivers/scsi/qla4xxx/ql4_os.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/qla4xxx/ql4_os.c:	ihost->port_speed = speed;
drivers/scsi/qla4xxx/ql4_os.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/qla4xxx/ql4_os.c:	ihost->port_state = state;
drivers/scsi/qla4xxx/ql4_os.c:		     __func__, ha->host->host_no));
drivers/scsi/qla4xxx/ql4_os.c:		for (index = 0; index < ha->host->can_queue; index++) {
drivers/scsi/qla4xxx/ql4_os.c:		if (index == ha->host->can_queue)
drivers/scsi/qla4xxx/ql4_os.c:	for (i = 0; i < ha->host->can_queue; i++) {
drivers/scsi/qla4xxx/ql4_os.c: * "host->can_queue". This can cause a panic if we were in our interrupt code.
drivers/scsi/qla4xxx/ql4_os.c:	ha->boot_kset = iscsi_boot_create_host_kset(ha->host->host_no);
drivers/scsi/qla4xxx/ql4_os.c:	ha->host_no = host->host_no;
drivers/scsi/qla4xxx/ql4_os.c:	host->cmd_per_lun = 3;
drivers/scsi/qla4xxx/ql4_os.c:	host->max_channel = 0;
drivers/scsi/qla4xxx/ql4_os.c:	host->max_lun = MAX_LUNS - 1;
drivers/scsi/qla4xxx/ql4_os.c:	host->max_id = MAX_TARGETS;
drivers/scsi/qla4xxx/ql4_os.c:	host->max_cmd_len = IOCB_MAX_CDB_LEN;
drivers/scsi/qla4xxx/ql4_os.c:	host->can_queue = MAX_SRBS ;
drivers/scsi/qla4xxx/ql4_os.c:	host->transportt = qla4xxx_scsi_transport;
drivers/scsi/qla4xxx/ql4_os.c:	for (cnt = 0; cnt < ha->host->can_queue; cnt++) {
drivers/scsi/qla4xxx/ql4_os.c:	if (shost->shost_state == SHOST_RECOVERY)
drivers/scsi/qlogicfas.c:	qinitid = host->this_id;
drivers/scsi/qlogicfas.c:	host->name = qlogicfas_name;
drivers/scsi/qlogicfas.c:	if (shost->irq) {
drivers/scsi/qlogicfas.c:		free_irq(shost->irq, shost);
drivers/scsi/qlogicfas.c:	if (shost->dma_channel != 0xff)
drivers/scsi/qlogicfas.c:		free_dma(shost->dma_channel);
drivers/scsi/qlogicfas.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/qlogicfas.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/qlogicfas408.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/qlogicfas408.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicfas408.c:	spin_lock_irqsave(cmd->device->host->host_lock, flags);
drivers/scsi/qlogicfas408.c:	spin_unlock_irqrestore(cmd->device->host->host_lock, flags);
drivers/scsi/qlogicfas408.h:#define get_priv_by_cmd(x) (struct qlogicfas408_priv *)&((x)->device->host->hostdata[0])
drivers/scsi/qlogicpti.c:	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
drivers/scsi/qlogicpti.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/qlogicpti.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/qlogicpti.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/qlogicpti.c:	qpti->qhost->irq = qpti->irq = op->archdata.irqs[0];
drivers/scsi/qlogicpti.c:	qpti->qhost->this_id = qpti->scsi_id;
drivers/scsi/qlogicpti.c:	qpti->qhost->max_sectors = 64;
drivers/scsi/qlogicpti.c:	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
drivers/scsi/qlogicpti.c:		qpti->qhost->irq, qpti->qregs);
drivers/scsi/qlogicpti.c:	host->can_queue = host->host_busy + num_free;
drivers/scsi/qlogicpti.c:	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
drivers/scsi/qlogicpti.c:	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
drivers/scsi/qlogicpti.c:	spin_lock_irqsave(qpti->qhost->host_lock, flags);
drivers/scsi/qlogicpti.c:	spin_unlock_irqrestore(qpti->qhost->host_lock, flags);
drivers/scsi/qlogicpti.c:	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
drivers/scsi/qlogicpti.c:	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
drivers/scsi/qlogicpti.c:	host->max_id = MAX_TARGETS;
drivers/scsi/qlogicpti.h: * slots available.  That is, host->can_queue and host->sg_tablesize
drivers/scsi/raid_class.c:		if (i->f->cookie != sdev->host->hostt)
drivers/scsi/scsi.c: *  Jiffies wrap fixes (host->resetting), 3 Dec 1998 Andrea Arcangeli
drivers/scsi/scsi.c:	cmd = scsi_pool_alloc_command(shost->cmd_pool, gfp_mask);
drivers/scsi/scsi.c:			scsi_pool_free_command(shost->cmd_pool, cmd);
drivers/scsi/scsi.c:		spin_lock_irqsave(&shost->free_list_lock, flags);
drivers/scsi/scsi.c:		if (likely(!list_empty(&shost->free_list))) {
drivers/scsi/scsi.c:			cmd = list_entry(shost->free_list.next,
drivers/scsi/scsi.c:		spin_unlock_irqrestore(&shost->free_list_lock, flags);
drivers/scsi/scsi.c:	spin_lock_irqsave(&shost->free_list_lock, flags);
drivers/scsi/scsi.c:	if (unlikely(list_empty(&shost->free_list))) {
drivers/scsi/scsi.c:		list_add(&cmd->list, &shost->free_list);
drivers/scsi/scsi.c:	spin_unlock_irqrestore(&shost->free_list_lock, flags);
drivers/scsi/scsi.c:		scsi_pool_free_command(shost->cmd_pool, cmd);
drivers/scsi/scsi.c:	const gfp_t gfp_mask = shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL;
drivers/scsi/scsi.c:	spin_lock_init(&shost->free_list_lock);
drivers/scsi/scsi.c:	INIT_LIST_HEAD(&shost->free_list);
drivers/scsi/scsi.c:	shost->cmd_pool = scsi_get_host_cmd_pool(gfp_mask);
drivers/scsi/scsi.c:	if (!shost->cmd_pool)
drivers/scsi/scsi.c:		shost->cmd_pool = NULL;
drivers/scsi/scsi.c:	list_add(&cmd->list, &shost->free_list);
drivers/scsi/scsi.c:	if (!shost->cmd_pool)
drivers/scsi/scsi.c:	while (!list_empty(&shost->free_list)) {
drivers/scsi/scsi.c:		cmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);
drivers/scsi/scsi.c:		scsi_pool_free_command(shost->cmd_pool, cmd);
drivers/scsi/scsi.c:	shost->cmd_pool = NULL;
drivers/scsi/scsi.c:	scsi_put_host_cmd_pool(shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL);
drivers/scsi/scsi.c:					cmd->device->host->hostt->queuecommand);
drivers/scsi/scsi.c:					    cmd->device->host->host_busy,
drivers/scsi/scsi.c:					    cmd->device->host->host_failed);
drivers/scsi/scsi.c:	cmd->serial_number = host->cmd_serial_number++;
drivers/scsi/scsi.c:		cmd->serial_number = host->cmd_serial_number++;
drivers/scsi/scsi.c:	timeout = host->last_reset + MIN_RESET_DELAY;
drivers/scsi/scsi.c:	if (host->resetting && time_before(jiffies, timeout)) {
drivers/scsi/scsi.c:		host->resetting = 0;
drivers/scsi/scsi.c:	if (cmd->cmd_len > cmd->device->host->max_cmd_len) {
drivers/scsi/scsi.c:			       "cdb_size=%d host->max_cmd_len=%d\n",
drivers/scsi/scsi.c:			       cmd->cmd_len, cmd->device->host->max_cmd_len));
drivers/scsi/scsi.c:	if (unlikely(host->shost_state == SHOST_DEL)) {
drivers/scsi/scsi.c:		rtn = host->hostt->queuecommand(host, cmd);
drivers/scsi/scsi.c:        shost->host_blocked = 0;
drivers/scsi/scsi.c:	if (!sdev->host->bqt) {
drivers/scsi/scsi.c:		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/scsi.c:	try_module_get(sdev->host->hostt->module);
drivers/scsi/scsi.c:	struct module *module = sdev->host->hostt->module;
drivers/scsi/scsi.c:	struct list_head *list = (prev ? &prev->siblings : &shost->__devices);
drivers/scsi/scsi.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi.c:	while (list->next != &shost->__devices) {
drivers/scsi/scsi.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi.c:	list_for_each_entry(sdev, &shost->__devices, siblings) {
drivers/scsi/scsi.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_debug.c:		hpnt = sdbg_host->shost;
drivers/scsi/scsi_debug.c:		int host_no = devip->sdbg_host->shost->host_no;
drivers/scsi/scsi_debug.c:	int host_no = devip->sdbg_host->shost->host_no;
drivers/scsi/scsi_debug.c:	target_dev_id = ((devip->sdbg_host->shost->host_no + 1) * 2000) +
drivers/scsi/scsi_debug.c:		list_add_tail(&devip->dev_list, &sdbg_host->dev_info_list);
drivers/scsi/scsi_debug.c:	list_for_each_entry(devip, &sdbg_host->dev_info_list, dev_list) {
drivers/scsi/scsi_debug.c:		       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);
drivers/scsi/scsi_debug.c:		       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);
drivers/scsi/scsi_debug.c:	if (sdp->host->max_cmd_len != SCSI_DEBUG_MAX_CMD_LEN)
drivers/scsi/scsi_debug.c:		sdp->host->max_cmd_len = SCSI_DEBUG_MAX_CMD_LEN;
drivers/scsi/scsi_debug.c:	if (sdp->host->cmd_per_lun)
drivers/scsi/scsi_debug.c:					sdp->host->cmd_per_lun);
drivers/scsi/scsi_debug.c:		       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);
drivers/scsi/scsi_debug.c:                                            &sdbg_host->dev_info_list,
drivers/scsi/scsi_debug.c:                list_for_each_entry(dev_info, &sdbg_host->dev_info_list,
drivers/scsi/scsi_debug.c:			       "non-zero result=0x%x\n", sdp->host->host_no,
drivers/scsi/scsi_debug.c:        INIT_LIST_HEAD(&sdbg_host->dev_info_list);
drivers/scsi/scsi_debug.c:        list_add_tail(&sdbg_host->host_list, &sdebug_host_list);
drivers/scsi/scsi_debug.c:        sdbg_host->dev.bus = &pseudo_lld_bus;
drivers/scsi/scsi_debug.c:        sdbg_host->dev.parent = pseudo_primary;
drivers/scsi/scsi_debug.c:        sdbg_host->dev.release = &sdebug_release_adapter;
drivers/scsi/scsi_debug.c:        dev_set_name(&sdbg_host->dev, "adapter%d", scsi_debug_add_host);
drivers/scsi/scsi_debug.c:        error = device_register(&sdbg_host->dev);
drivers/scsi/scsi_debug.c:	list_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,
drivers/scsi/scsi_debug.c:		list_del(&sdbg_host->host_list);
drivers/scsi/scsi_debug.c:        device_unregister(&sdbg_host->dev);
drivers/scsi/scsi_debug.c:	if (target == SCpnt->device->host->hostt->this_id) {
drivers/scsi/scsi_debug.c:        sdbg_host->shost = hpnt;
drivers/scsi/scsi_debug.c:        error = scsi_add_host(hpnt, &sdbg_host->dev);
drivers/scsi/scsi_debug.c:        scsi_remove_host(sdbg_host->shost);
drivers/scsi/scsi_debug.c:	list_for_each_entry_safe(sdbg_devinfo, tmp, &sdbg_host->dev_info_list,
drivers/scsi/scsi_debug.c:        scsi_host_put(sdbg_host->shost);
drivers/scsi/scsi_error.c:	if (shost->host_busy == shost->host_failed) {
drivers/scsi/scsi_error.c:		wake_up_process(shost->ehandler);
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:		shost->host_eh_scheduled++;
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	if (!shost->ehandler)
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	list_add_tail(&scmd->eh_entry, &shost->eh_cmd_q);
drivers/scsi/scsi_error.c:	shost->host_failed++;
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	if (host->transportt->eh_timed_out)
drivers/scsi/scsi_error.c:		rtn = host->transportt->eh_timed_out(scmd);
drivers/scsi/scsi_error.c:	else if (host->hostt->eh_timed_out)
drivers/scsi/scsi_error.c:		rtn = host->hostt->eh_timed_out(scmd);
drivers/scsi/scsi_error.c:	wait_event(sdev->host->host_wait, !scsi_host_in_recovery(sdev->host));
drivers/scsi/scsi_error.c:	struct scsi_host_template *sht = sdev->host->hostt;
drivers/scsi/scsi_error.c:	struct scsi_host_template *sht = sdev->host->hostt;
drivers/scsi/scsi_error.c:	eh_action = scmd->device->host->eh_action;
drivers/scsi/scsi_error.c:	struct scsi_host_template *hostt = host->hostt;
drivers/scsi/scsi_error.c:		spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/scsi_error.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/scsi_error.c:	struct scsi_host_template *hostt = host->hostt;
drivers/scsi/scsi_error.c:		spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/scsi_error.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/scsi_error.c:	struct scsi_host_template *hostt = host->hostt;
drivers/scsi/scsi_error.c:		spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/scsi_error.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/scsi_error.c:	struct scsi_host_template *hostt = scmd->device->host->hostt;
drivers/scsi/scsi_error.c:	if (scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd) != SUCCESS)
drivers/scsi/scsi_error.c:	shost->eh_action = &done;
drivers/scsi/scsi_error.c:	shost->hostt->queuecommand(shost, scmd);
drivers/scsi/scsi_error.c:	shost->eh_action = NULL;
drivers/scsi/scsi_error.c:	scmd->device->host->host_failed--;
drivers/scsi/scsi_error.c:		rtn = scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd);
drivers/scsi/scsi_error.c:	for (channel = 0; channel <= shost->max_channel; channel++) {
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	wake_up(&shost->host_wait);
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	if (shost->host_eh_scheduled)
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	list_splice_init(&shost->eh_cmd_q, &eh_work_q);
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
drivers/scsi/scsi_error.c:		    shost->host_failed != shost->host_busy) {
drivers/scsi/scsi_error.c:					shost->host_no));
drivers/scsi/scsi_error.c:				shost->host_no));
drivers/scsi/scsi_error.c:		if (!shost->eh_noresume && scsi_autopm_get_host(shost) != 0) {
drivers/scsi/scsi_error.c:						shost->host_no));
drivers/scsi/scsi_error.c:		if (shost->transportt->eh_strategy_handler)
drivers/scsi/scsi_error.c:			shost->transportt->eh_strategy_handler(shost);
drivers/scsi/scsi_error.c:		if (!shost->eh_noresume)
drivers/scsi/scsi_error.c:		printk("Error handler scsi_eh_%d exiting\n", shost->host_no));
drivers/scsi/scsi_error.c:	shost->ehandler = NULL;
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	shost->tmf_in_progress = 1;
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	shost->tmf_in_progress = 0;
drivers/scsi/scsi_error.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_error.c:	wake_up(&shost->host_wait);
drivers/scsi/scsi_ioctl.c:		if (host->hostt->info)
drivers/scsi/scsi_ioctl.c:			string = host->hostt->info(host);
drivers/scsi/scsi_ioctl.c:			string = host->hostt->name;
drivers/scsi/scsi_ioctl.c:			 + ((sdev->host->host_no & 0xff) << 24),
drivers/scsi/scsi_ioctl.c:		__put_user(sdev->host->unique_id,
drivers/scsi/scsi_ioctl.c:		return put_user(sdev->host->host_no, (int __user *)arg);
drivers/scsi/scsi_ioctl.c:		if (sdev->host->hostt->ioctl)
drivers/scsi/scsi_ioctl.c:			return sdev->host->hostt->ioctl(sdev, cmd, arg);
drivers/scsi/scsi_lib.c:		host->host_blocked = host->max_host_blocked;
drivers/scsi/scsi_lib.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	shost->host_busy--;
drivers/scsi/scsi_lib.c:		     (shost->host_failed || shost->host_eh_scheduled)))
drivers/scsi/scsi_lib.c:	spin_unlock(shost->host_lock);
drivers/scsi/scsi_lib.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	if ((shost->can_queue > 0 && shost->host_busy >= shost->can_queue) ||
drivers/scsi/scsi_lib.c:	    shost->host_blocked || shost->host_self_blocked)
drivers/scsi/scsi_lib.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:	list_splice_init(&shost->starved_list, &starved_list);
drivers/scsi/scsi_lib.c:				       &shost->starved_list);
drivers/scsi/scsi_lib.c:		spin_unlock(shost->host_lock);
drivers/scsi/scsi_lib.c:		spin_lock(shost->host_lock);
drivers/scsi/scsi_lib.c:	list_splice(&starved_list, &shost->starved_list);
drivers/scsi/scsi_lib.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_lib.c:		list_move_tail(&sdev->starved_entry, &shost->starved_list);
drivers/scsi/scsi_lib.c:	if (shost->host_busy == 0 && shost->host_blocked) {
drivers/scsi/scsi_lib.c:		if (--shost->host_blocked == 0) {
drivers/scsi/scsi_lib.c:					shost->host_no));
drivers/scsi/scsi_lib.c:			list_add_tail(&sdev->starved_entry, &shost->starved_list);
drivers/scsi/scsi_lib.c:	spin_lock(shost->host_lock);
drivers/scsi/scsi_lib.c:	shost->host_busy++;
drivers/scsi/scsi_lib.c:	spin_unlock(shost->host_lock);
drivers/scsi/scsi_lib.c:		spin_lock(shost->host_lock);
drivers/scsi/scsi_lib.c:					      &shost->starved_list);
drivers/scsi/scsi_lib.c:		shost->host_busy++;
drivers/scsi/scsi_lib.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/scsi_lib.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/scsi_lib.c:	if (shost->unchecked_isa_dma)
drivers/scsi/scsi_lib.c:	struct device *dev = shost->dma_dev;
drivers/scsi/scsi_lib.c:	blk_queue_max_segments(q, min_t(unsigned short, shost->sg_tablesize,
drivers/scsi/scsi_lib.c:		shost->sg_prot_tablesize =
drivers/scsi/scsi_lib.c:			min_not_zero(shost->sg_prot_tablesize,
drivers/scsi/scsi_lib.c:		BUG_ON(shost->sg_prot_tablesize < shost->sg_tablesize);
drivers/scsi/scsi_lib.c:		blk_queue_max_integrity_segments(q, shost->sg_prot_tablesize);
drivers/scsi/scsi_lib.c:	blk_queue_max_hw_sectors(q, shost->max_sectors);
drivers/scsi/scsi_lib.c:	blk_queue_segment_boundary(q, shost->dma_boundary);
drivers/scsi/scsi_lib.c:	dma_set_seg_boundary(dev, shost->dma_boundary);
drivers/scsi/scsi_lib.c:	if (!shost->use_clustering)
drivers/scsi/scsi_lib.c:	shost->host_self_blocked = 1;
drivers/scsi/scsi_lib.c:	shost->host_self_blocked = 0;
drivers/scsi/scsi_lib_dma.c:		struct device *dev = cmd->device->host->dma_dev;
drivers/scsi/scsi_lib_dma.c:		struct device *dev = cmd->device->host->dma_dev;
drivers/scsi/scsi_module.c:	l = &shost->sht_legacy_list;
drivers/scsi/scsi_netlink.c:		if (shost->hostt != driver->hostt) {
drivers/scsi/scsi_pm.c:	err = pm_runtime_get_sync(&shost->shost_gendev);
drivers/scsi/scsi_pm.c:		pm_runtime_put_sync(&shost->shost_gendev);
drivers/scsi/scsi_pm.c:	pm_runtime_put_sync(&shost->shost_gendev);
drivers/scsi/scsi_proc.c:	n = shost->hostt->proc_info(shost, buffer, start, offset, length, 0);
drivers/scsi/scsi_proc.c:		ret = shost->hostt->proc_info(shost, page, &start, 0, count, 1);
drivers/scsi/scsi_proc.c:	struct scsi_host_template *sht = shost->hostt;
drivers/scsi/scsi_proc.c:	sprintf(name,"%d", shost->host_no);
drivers/scsi/scsi_proc.c:		       "%s\n", __func__, shost->host_no,
drivers/scsi/scsi_proc.c:	if (!shost->hostt->proc_dir)
drivers/scsi/scsi_proc.c:	sprintf(name,"%d", shost->host_no);
drivers/scsi/scsi_proc.c:	remove_proc_entry(name, shost->hostt->proc_dir);
drivers/scsi/scsi_proc.c:		sdev->host->host_no, sdev->channel, sdev->id, sdev->lun);
drivers/scsi/scsi_proc.c:	if (shost->transportt->user_scan)
drivers/scsi/scsi_proc.c:		error = shost->transportt->user_scan(shost, channel, id, lun);
drivers/scsi/scsi_scan.c:	sdev = kzalloc(sizeof(*sdev) + shost->transportt->device_size,
drivers/scsi/scsi_scan.c:	scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
drivers/scsi/scsi_scan.c:	if (shost->hostt->slave_alloc) {
drivers/scsi/scsi_scan.c:		ret = shost->hostt->slave_alloc(sdev);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	if (shost->hostt->target_destroy)
drivers/scsi/scsi_scan.c:		shost->hostt->target_destroy(starget);
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	list_for_each_entry(starget, &shost->__targets, siblings) {
drivers/scsi/scsi_scan.c:		+ shost->transportt->target_size;
drivers/scsi/scsi_scan.c:	dev_set_name(dev, "target%d:%d:%d", shost->host_no, channel, id);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	list_add_tail(&starget->siblings, &shost->__targets);
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	if (shost->hostt->target_alloc) {
drivers/scsi/scsi_scan.c:		error = shost->hostt->target_alloc(starget);
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	if (sdev->host->hostt->slave_configure) {
drivers/scsi/scsi_scan.c:		ret = sdev->host->hostt->slave_configure(sdev);
drivers/scsi/scsi_scan.c:			((shost->unchecked_isa_dma) ? __GFP_DMA : 0));
drivers/scsi/scsi_scan.c:	res = scsi_add_lun(sdev, result, &bflags, shost->async_scan);
drivers/scsi/scsi_scan.c:	max_dev_lun = min(max_scsi_luns, shost->max_lun);
drivers/scsi/scsi_scan.c:		max_dev_lun = shost->max_lun;
drivers/scsi/scsi_scan.c:		max_dev_lun = shost->max_lun;
drivers/scsi/scsi_scan.c:	    (!(bflags & BLIST_REPORTLUN2) || shost->max_lun <= 8))
drivers/scsi/scsi_scan.c:		shost->host_no, sdev->channel, sdev->id);
drivers/scsi/scsi_scan.c:			   (sdev->host->unchecked_isa_dma ? __GFP_DMA : 0));
drivers/scsi/scsi_scan.c:		} else if (lun > sdev->host->max_lun) {
drivers/scsi/scsi_scan.c:	struct device *parent = &shost->shost_gendev;
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (!shost->async_scan)
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (shost->this_id == id)
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (!shost->async_scan)
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:		for (id = 0; id < shost->max_id; ++id) {
drivers/scsi/scsi_scan.c:			if (shost->reverse_ordering)
drivers/scsi/scsi_scan.c:				order_id = shost->max_id - id - 1;
drivers/scsi/scsi_scan.c:			__scsi_scan_target(&shost->shost_gendev, channel,
drivers/scsi/scsi_scan.c:		__scsi_scan_target(&shost->shost_gendev, channel,
drivers/scsi/scsi_scan.c:	if (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||
drivers/scsi/scsi_scan.c:	    ((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||
drivers/scsi/scsi_scan.c:	    ((lun != SCAN_WILD_CARD) && (lun > shost->max_lun)))
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (!shost->async_scan)
drivers/scsi/scsi_scan.c:			for (channel = 0; channel <= shost->max_channel;
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (shost->async_scan) {
drivers/scsi/scsi_scan.c:				shost->host_no);
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	shost->async_scan = 1;
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (!shost->async_scan) {
drivers/scsi/scsi_scan.c:				shost->host_no);
drivers/scsi/scsi_scan.c:		mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	shost->async_scan = 0;
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	if (shost->hostt->scan_finished) {
drivers/scsi/scsi_scan.c:		if (shost->hostt->scan_start)
drivers/scsi/scsi_scan.c:			shost->hostt->scan_start(shost);
drivers/scsi/scsi_scan.c:		while (!shost->hostt->scan_finished(shost, jiffies - start))
drivers/scsi/scsi_scan.c:	p = kthread_run(do_scan_async, data, "scsi_scan_%d", shost->host_no);
drivers/scsi/scsi_scan.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	list_for_each_entry(sdev, &shost->__devices, siblings) {
drivers/scsi/scsi_scan.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_scan.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	starget = scsi_alloc_target(&shost->shost_gendev, 0, shost->this_id);
drivers/scsi/scsi_scan.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_scan.c:	BUG_ON(sdev->id != sdev->host->this_id);
drivers/scsi/scsi_sysfs.c:	if (shost->transportt->user_scan)
drivers/scsi/scsi_sysfs.c:		res = shost->transportt->user_scan(shost, channel, id, lun);
drivers/scsi/scsi_sysfs.c:	return snprintf (buf, 20, format_string, shost->field);		\
drivers/scsi/scsi_sysfs.c:	const char *name = scsi_host_state_name(shost->shost_state);
drivers/scsi/scsi_sysfs.c:	unsigned int supported_mode = shost->hostt->supported_mode;
drivers/scsi/scsi_sysfs.c:	if (shost->active_mode == MODE_UNKNOWN)
drivers/scsi/scsi_sysfs.c:		return show_shost_mode(shost->active_mode, buf);
drivers/scsi/scsi_sysfs.c:	struct scsi_host_template *sht = shost->hostt;
drivers/scsi/scsi_sysfs.c:	spin_lock_irqsave(sdev->host->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	spin_unlock_irqrestore(sdev->host->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	struct scsi_host_template *sht = sdev->host->hostt;
drivers/scsi/scsi_sysfs.c:	struct scsi_host_template *sht = sdev->host->hostt;
drivers/scsi/scsi_sysfs.c:	if (sdev->host->hostt->change_queue_depth) {
drivers/scsi/scsi_sysfs.c:	if (sdev->host->hostt->change_queue_type)
drivers/scsi/scsi_sysfs.c:	if (sdev->host->hostt->sdev_attrs) {
drivers/scsi/scsi_sysfs.c:		for (i = 0; sdev->host->hostt->sdev_attrs[i]; i++) {
drivers/scsi/scsi_sysfs.c:					sdev->host->hostt->sdev_attrs[i]);
drivers/scsi/scsi_sysfs.c:	if (sdev->host->hostt->slave_destroy)
drivers/scsi/scsi_sysfs.c:		sdev->host->hostt->slave_destroy(sdev);
drivers/scsi/scsi_sysfs.c:	mutex_lock(&shost->scan_mutex);
drivers/scsi/scsi_sysfs.c:	mutex_unlock(&shost->scan_mutex);
drivers/scsi/scsi_sysfs.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	list_for_each_entry(sdev, &shost->__devices, siblings) {
drivers/scsi/scsi_sysfs.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	list_for_each_entry(starget, &shost->__targets, siblings) {
drivers/scsi/scsi_sysfs.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	if (shost->hostt->shost_attrs) {
drivers/scsi/scsi_sysfs.c:		for (i = 0; shost->hostt->shost_attrs[i]; i++) {
drivers/scsi/scsi_sysfs.c:			error = device_create_file(&shost->shost_dev,
drivers/scsi/scsi_sysfs.c:					shost->hostt->shost_attrs[i]);
drivers/scsi/scsi_sysfs.c:	transport_register_device(&shost->shost_gendev);
drivers/scsi/scsi_sysfs.c:	transport_configure_device(&shost->shost_gendev);
drivers/scsi/scsi_sysfs.c:		     sdev->host->host_no, sdev->channel, sdev->id, sdev->lun);
drivers/scsi/scsi_sysfs.c:		     sdev->host->host_no, sdev->channel, sdev->id, sdev->lun);
drivers/scsi/scsi_sysfs.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_sysfs.c:	list_add_tail(&sdev->siblings, &shost->__devices);
drivers/scsi/scsi_sysfs.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_tgt_if.c:	ev.p.cmd_req.host_no = shost->host_no;
drivers/scsi/scsi_tgt_if.c:	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
drivers/scsi/scsi_tgt_if.c:	ev.p.cmd_done.host_no = shost->host_no;
drivers/scsi/scsi_tgt_if.c:	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
drivers/scsi/scsi_tgt_lib.c:	if (!get_device(&shost->shost_gendev))
drivers/scsi/scsi_tgt_lib.c:	rq = blk_get_request(shost->uspace_req_q, !write, gfp_mask);
drivers/scsi/scsi_tgt_lib.c:	put_device(&shost->shost_gendev);
drivers/scsi/scsi_tgt_lib.c:	struct request_queue *q = shost->uspace_req_q;
drivers/scsi/scsi_tgt_lib.c:	__scsi_put_command(shost, cmd, &shost->shost_gendev);
drivers/scsi/scsi_tgt_lib.c:	q->nr_requests = shost->can_queue;
drivers/scsi/scsi_tgt_lib.c:	shost->uspace_req_q = q;
drivers/scsi/scsi_tgt_lib.c:	struct request_queue *q = shost->uspace_req_q;
drivers/scsi/scsi_tgt_lib.c:		shost->hostt->eh_abort_handler(cmd);
drivers/scsi/scsi_tgt_lib.c:	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
drivers/scsi/scsi_tgt_lib.c:	err = shost->hostt->eh_abort_handler(cmd);
drivers/scsi/scsi_tgt_lib.c:	if (!shost->uspace_req_q) {
drivers/scsi/scsi_tgt_lib.c:	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
drivers/scsi/scsi_tgt_lib.c:			qdata = shost->uspace_req_q->queuedata;
drivers/scsi/scsi_tgt_lib.c:	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, itn_id,
drivers/scsi/scsi_tgt_lib.c:	if (!shost->uspace_req_q) {
drivers/scsi/scsi_tgt_lib.c:	err = shost->transportt->tsk_mgmt_response(shost, itn_id, mid, result);
drivers/scsi/scsi_tgt_lib.c:	err = scsi_tgt_uspace_send_it_nexus_request(shost->host_no, itn_id, 0,
drivers/scsi/scsi_tgt_lib.c:			shost->host_no, (unsigned long long)itn_id);
drivers/scsi/scsi_tgt_lib.c:	err = scsi_tgt_uspace_send_it_nexus_request(shost->host_no,
drivers/scsi/scsi_tgt_lib.c:			shost->host_no, (unsigned long long)itn_id);
drivers/scsi/scsi_tgt_lib.c:	if (!shost->uspace_req_q) {
drivers/scsi/scsi_tgt_lib.c:	err = shost->transportt->it_nexus_response(shost, itn_id, result);
drivers/scsi/scsi_transport_fc.c:	fc_host->node_name = -1;
drivers/scsi/scsi_transport_fc.c:	fc_host->port_name = -1;
drivers/scsi/scsi_transport_fc.c:	fc_host->permanent_port_name = -1;
drivers/scsi/scsi_transport_fc.c:	fc_host->supported_classes = FC_COS_UNSPECIFIED;
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->supported_fc4s, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->supported_fc4s));
drivers/scsi/scsi_transport_fc.c:	fc_host->supported_speeds = FC_PORTSPEED_UNKNOWN;
drivers/scsi/scsi_transport_fc.c:	fc_host->maxframe_size = -1;
drivers/scsi/scsi_transport_fc.c:	fc_host->max_npiv_vports = 0;
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->serial_number, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->serial_number));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->manufacturer, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->manufacturer));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->model, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->model));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->model_description, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->model_description));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->hardware_version, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->hardware_version));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->driver_version, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->driver_version));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->firmware_version, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->firmware_version));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->optionrom_version, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->optionrom_version));
drivers/scsi/scsi_transport_fc.c:	fc_host->port_id = -1;
drivers/scsi/scsi_transport_fc.c:	fc_host->port_type = FC_PORTTYPE_UNKNOWN;
drivers/scsi/scsi_transport_fc.c:	fc_host->port_state = FC_PORTSTATE_UNKNOWN;
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->active_fc4s, 0,
drivers/scsi/scsi_transport_fc.c:		sizeof(fc_host->active_fc4s));
drivers/scsi/scsi_transport_fc.c:	fc_host->speed = FC_PORTSPEED_UNKNOWN;
drivers/scsi/scsi_transport_fc.c:	fc_host->fabric_name = -1;
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->symbolic_name, 0, sizeof(fc_host->symbolic_name));
drivers/scsi/scsi_transport_fc.c:	memset(fc_host->system_hostname, 0, sizeof(fc_host->system_hostname));
drivers/scsi/scsi_transport_fc.c:	fc_host->tgtid_bind_type = FC_TGTID_BIND_BY_WWPN;
drivers/scsi/scsi_transport_fc.c:	INIT_LIST_HEAD(&fc_host->rports);
drivers/scsi/scsi_transport_fc.c:	INIT_LIST_HEAD(&fc_host->rport_bindings);
drivers/scsi/scsi_transport_fc.c:	INIT_LIST_HEAD(&fc_host->vports);
drivers/scsi/scsi_transport_fc.c:	fc_host->next_rport_number = 0;
drivers/scsi/scsi_transport_fc.c:	fc_host->next_target_id = 0;
drivers/scsi/scsi_transport_fc.c:	fc_host->next_vport_number = 0;
drivers/scsi/scsi_transport_fc.c:	fc_host->npiv_vports_inuse = 0;
drivers/scsi/scsi_transport_fc.c:	snprintf(fc_host->work_q_name, sizeof(fc_host->work_q_name),
drivers/scsi/scsi_transport_fc.c:		 "fc_wq_%d", shost->host_no);
drivers/scsi/scsi_transport_fc.c:	fc_host->work_q = alloc_workqueue(fc_host->work_q_name, 0, 0);
drivers/scsi/scsi_transport_fc.c:	if (!fc_host->work_q)
drivers/scsi/scsi_transport_fc.c:	fc_host->dev_loss_tmo = fc_dev_loss_tmo;
drivers/scsi/scsi_transport_fc.c:	snprintf(fc_host->devloss_work_q_name,
drivers/scsi/scsi_transport_fc.c:		 sizeof(fc_host->devloss_work_q_name),
drivers/scsi/scsi_transport_fc.c:		 "fc_dl_%d", shost->host_no);
drivers/scsi/scsi_transport_fc.c:	fc_host->devloss_work_q =
drivers/scsi/scsi_transport_fc.c:			alloc_workqueue(fc_host->devloss_work_q_name, 0, 0);
drivers/scsi/scsi_transport_fc.c:	if (!fc_host->devloss_work_q) {
drivers/scsi/scsi_transport_fc.c:		destroy_workqueue(fc_host->work_q);
drivers/scsi/scsi_transport_fc.c:		fc_host->work_q = NULL;
drivers/scsi/scsi_transport_fc.c:	fc_bsg_remove(fc_host->rqst_q);
drivers/scsi/scsi_transport_fc.c:	event->host_no = shost->host_no;
drivers/scsi/scsi_transport_fc.c:		__func__, shost->host_no,
drivers/scsi/scsi_transport_fc.c:	event->host_no = shost->host_no;
drivers/scsi/scsi_transport_fc.c:		__func__, shost->host_no, err);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);	\
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	list_for_each_entry(rport, &fc_host->rports, peers)
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	stat = fc_vport_setup(shost, 0, &shost->shost_gendev, &vid, &vport);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	list_for_each_entry(vport, &fc_host->vports, peers) {
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_fc.c:	i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_fc.c:	i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_fc.c:	i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_fc.c:	i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:			spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||
drivers/scsi/scsi_transport_fc.c:	    ((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||
drivers/scsi/scsi_transport_fc.c:	    ((lun != SCAN_WILD_CARD) && (lun > shost->max_lun)))
drivers/scsi/scsi_transport_fc.c:		chhi = shost->max_channel + 1;
drivers/scsi/scsi_transport_fc.c:		tgthi = shost->max_id;
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/scsi_transport_fc.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/scsi_transport_fc.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/scsi_transport_fc.c:			"when no workqueue created.\n", shost->hostt->name);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	list_for_each_entry_safe(vport, next_vport, &fc_host->vports, peers)
drivers/scsi/scsi_transport_fc.c:			&fc_host->rports, peers) {
drivers/scsi/scsi_transport_fc.c:			&fc_host->rport_bindings, peers) {
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if (fc_host->work_q) {
drivers/scsi/scsi_transport_fc.c:		work_q = fc_host->work_q;
drivers/scsi/scsi_transport_fc.c:		fc_host->work_q = NULL;
drivers/scsi/scsi_transport_fc.c:	if (fc_host->devloss_work_q) {
drivers/scsi/scsi_transport_fc.c:		work_q = fc_host->devloss_work_q;
drivers/scsi/scsi_transport_fc.c:		fc_host->devloss_work_q = NULL;
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	put_device(&shost->shost_gendev);	/* for fc_host->rport list */
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *fci = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	rport->dev_loss_tmo = fc_host->dev_loss_tmo;
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	rport->number = fc_host->next_rport_number++;
drivers/scsi/scsi_transport_fc.c:		rport->scsi_target_id = fc_host->next_target_id++;
drivers/scsi/scsi_transport_fc.c:	list_add_tail(&rport->peers, &fc_host->rports);
drivers/scsi/scsi_transport_fc.c:	get_device(&shost->shost_gendev);	/* for fc_host->rport list */
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	dev->parent = get_device(&shost->shost_gendev); /* parent reference */
drivers/scsi/scsi_transport_fc.c:		     shost->host_no, channel, rport->number);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	put_device(&shost->shost_gendev);	/* for fc_host->rport list */
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *fci = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	list_for_each_entry(rport, &fc_host->rports, peers) {
drivers/scsi/scsi_transport_fc.c:			switch (fc_host->tgtid_bind_type) {
drivers/scsi/scsi_transport_fc.c:				spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:				spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:					spin_unlock_irqrestore(shost->host_lock,
drivers/scsi/scsi_transport_fc.c:					spin_unlock_irqrestore(shost->host_lock,
drivers/scsi/scsi_transport_fc.c:	if (fc_host->tgtid_bind_type != FC_TGTID_BIND_NONE) {
drivers/scsi/scsi_transport_fc.c:		list_for_each_entry(rport, &fc_host->rport_bindings,
drivers/scsi/scsi_transport_fc.c:			switch (fc_host->tgtid_bind_type) {
drivers/scsi/scsi_transport_fc.c:				list_move_tail(&rport->peers, &fc_host->rports);
drivers/scsi/scsi_transport_fc.c:				spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:				spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	    shost->active_mode & MODE_TARGET)
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:			rport->scsi_target_id = fc_host->next_target_id++;
drivers/scsi/scsi_transport_fc.c:	} else if (shost->active_mode & MODE_TARGET) {
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if ((fc_host->tgtid_bind_type == FC_TGTID_BIND_NONE) ||
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	list_move_tail(&rport->peers, &fc_host->rport_bindings);
drivers/scsi/scsi_transport_fc.c:	 *   host-specific target data to persist along with the
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		switch (fc_host->tgtid_bind_type) {
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *fci = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if (fc_host->npiv_vports_inuse >= fc_host->max_npiv_vports) {
drivers/scsi/scsi_transport_fc.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	fc_host->npiv_vports_inuse++;
drivers/scsi/scsi_transport_fc.c:	vport->number = fc_host->next_vport_number++;
drivers/scsi/scsi_transport_fc.c:	list_add_tail(&vport->peers, &fc_host->vports);
drivers/scsi/scsi_transport_fc.c:	get_device(&shost->shost_gendev);	/* for fc_host->vport list */
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		     shost->host_no, channel, vport->number);
drivers/scsi/scsi_transport_fc.c:	if (pdev != &shost->shost_gendev) {
drivers/scsi/scsi_transport_fc.c:		error = sysfs_create_link(&shost->shost_gendev.kobj,
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:			shost->host_no, channel);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	put_device(&shost->shost_gendev);	/* for fc_host->vport list */
drivers/scsi/scsi_transport_fc.c:	fc_host->npiv_vports_inuse--;
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	stat = fc_vport_setup(shost, channel, &shost->shost_gendev,
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:		fc_host->npiv_vports_inuse--;
drivers/scsi/scsi_transport_fc.c:		put_device(&shost->shost_gendev);  /* for fc_host->vport list */
drivers/scsi/scsi_transport_fc.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/scsi_transport_fc.c:	if (dev->parent != &shost->shost_gendev)
drivers/scsi/scsi_transport_fc.c:		sysfs_remove_link(&shost->shost_gendev.kobj, dev_name(dev));
drivers/scsi/scsi_transport_fc.c:			dev_name(&vport->dev), vport->shost->host_no,
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:		job->dev = &shost->shost_gendev;
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:		if ((shost->hostt->vendor_id == 0L) ||
drivers/scsi/scsi_transport_fc.c:			shost->hostt->vendor_id)) {
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	fc_bsg_request_handler(q, shost, NULL, &shost->shost_gendev);
drivers/scsi/scsi_transport_fc.c:	struct device *dev = &shost->shost_gendev;
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_fc.c:	fc_host->rqst_q = NULL;
drivers/scsi/scsi_transport_fc.c:		 "fc_host%d", shost->host_no);
drivers/scsi/scsi_transport_fc.c:				 shost->host_no);
drivers/scsi/scsi_transport_fc.c:				shost->host_no);
drivers/scsi/scsi_transport_fc.c:	fc_host->rqst_q = q;
drivers/scsi/scsi_transport_fc.c:	struct fc_internal *i = to_fc_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:	iface->dev.parent = get_device(&shost->shost_gendev);
drivers/scsi/scsi_transport_iscsi.c:		dev_set_name(&iface->dev, "ipv4-iface-%u-%u", shost->host_no,
drivers/scsi/scsi_transport_iscsi.c:		dev_set_name(&iface->dev, "ipv6-iface-%u-%u", shost->host_no,
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_internal *i = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:		if ((shost->hostt->vendor_id == 0L) ||
drivers/scsi/scsi_transport_iscsi.c:			shost->hostt->vendor_id)) {
drivers/scsi/scsi_transport_iscsi.c:	struct device *dev = &shost->shost_gendev;
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_internal *i = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:	snprintf(bsg_name, sizeof(bsg_name), "iscsi_host%d", shost->host_no);
drivers/scsi/scsi_transport_iscsi.c:	ihost->bsg_q = q;
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	atomic_set(&ihost->nr_scans, 0);
drivers/scsi/scsi_transport_iscsi.c:	mutex_init(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	if (ihost->bsg_q) {
drivers/scsi/scsi_transport_iscsi.c:		bsg_remove_queue(ihost->bsg_q);
drivers/scsi/scsi_transport_iscsi.c:		blk_cleanup_queue(ihost->bsg_q);
drivers/scsi/scsi_transport_iscsi.c:	device_for_each_child(&shost->shost_gendev, fn,
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	return !atomic_read(&ihost->nr_scans);
drivers/scsi/scsi_transport_iscsi.c:	ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	mutex_lock(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:	mutex_unlock(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:	return device_for_each_child(&shost->shost_gendev, &scan_data,
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	atomic_dec(&ihost->nr_scans);
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	if (shost->hostt->scan_finished) {
drivers/scsi/scsi_transport_iscsi.c:			atomic_inc(&ihost->nr_scans);
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	mutex_lock(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:		mutex_unlock(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:	mutex_unlock(&ihost->mutex);
drivers/scsi/scsi_transport_iscsi.c:	session->dev.parent = &shost->shost_gendev;
drivers/scsi/scsi_transport_iscsi.c:	ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:		ev->r.req_path.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:		ev->r.notify_if_down.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:		ev->r.d_session.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:		ev->r.c_session_ret.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:		ev->r.unbind_session.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:	ev->r.c_session_ret.host_no = shost->host_no;
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_internal *priv = to_iscsi_internal(shost->transportt); \
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_internal *priv = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	uint32_t port_speed = ihost->port_speed;
drivers/scsi/scsi_transport_iscsi.c:	struct iscsi_cls_host *ihost = shost->shost_data;
drivers/scsi/scsi_transport_iscsi.c:	uint32_t port_state = ihost->port_state;
drivers/scsi/scsi_transport_iscsi.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_iscsi.c:	priv = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_iscsi.c:	priv = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_iscsi.c:	if (!shost->transportt  ||
drivers/scsi/scsi_transport_iscsi.c:	    shost->transportt->host_attrs.ac.class != &iscsi_host_class.class)
drivers/scsi/scsi_transport_iscsi.c:        priv = to_iscsi_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:		handler = to_sas_internal(shost->transportt)->f->smp_handler;
drivers/scsi/scsi_transport_sas.c:	struct request_queue *q = sas_host->q;
drivers/scsi/scsi_transport_sas.c:	if (!to_sas_internal(shost->transportt)->f->smp_handler) {
drivers/scsi/scsi_transport_sas.c:		printk("%s can't handle SMP requests\n", shost->hostt->name);
drivers/scsi/scsi_transport_sas.c:		dev = &shost->shost_gendev;
drivers/scsi/scsi_transport_sas.c:			 "sas_host%d", shost->host_no);
drivers/scsi/scsi_transport_sas.c:	INIT_LIST_HEAD(&sas_host->rphy_list);
drivers/scsi/scsi_transport_sas.c:	mutex_init(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	sas_host->next_target_id = 0;
drivers/scsi/scsi_transport_sas.c:	sas_host->next_expander_id = 0;
drivers/scsi/scsi_transport_sas.c:	sas_host->next_port_id = 0;
drivers/scsi/scsi_transport_sas.c:			   shost->host_no);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	sas_remove_children(&shost->shost_gendev);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);	\
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);	\
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:		dev_set_name(&phy->dev, "phy-%d:%d:%d", shost->host_no,
drivers/scsi/scsi_transport_sas.c:		dev_set_name(&phy->dev, "phy-%d:%d", shost->host_no, number);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:		dev_set_name(&port->dev, "port-%d:%d:%d", shost->host_no,
drivers/scsi/scsi_transport_sas.c:		dev_set_name(&port->dev, "port-%d:%d", shost->host_no,
drivers/scsi/scsi_transport_sas.c:	mutex_lock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:		index = sas_host->next_port_id++;
drivers/scsi/scsi_transport_sas.c:	mutex_unlock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	struct sas_internal *i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_sas.c:	if (shost->transportt->host_attrs.ac.class !=
drivers/scsi/scsi_transport_sas.c:	i = to_sas_internal(shost->transportt);
drivers/scsi/scsi_transport_sas.c:			     shost->host_no, rphy->scsi_target_id,
drivers/scsi/scsi_transport_sas.c:			     shost->host_no, parent->port_identifier);
drivers/scsi/scsi_transport_sas.c:	mutex_lock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	rdev->rphy.scsi_target_id = sas_host->next_expander_id++;
drivers/scsi/scsi_transport_sas.c:	mutex_unlock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:		     shost->host_no, rdev->rphy.scsi_target_id);
drivers/scsi/scsi_transport_sas.c:	mutex_lock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	list_add_tail(&rphy->list, &sas_host->rphy_list);
drivers/scsi/scsi_transport_sas.c:		rphy->scsi_target_id = sas_host->next_target_id++;
drivers/scsi/scsi_transport_sas.c:	mutex_unlock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	mutex_lock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	mutex_unlock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	mutex_lock(&sas_host->lock);
drivers/scsi/scsi_transport_sas.c:	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
drivers/scsi/scsi_transport_sas.c:	mutex_unlock(&sas_host->lock);
drivers/scsi/scsi_transport_spi.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_spi.c:	return &shost->transportt->host_attrs.ac == cont;
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);	\
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);	\
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);	\
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	return sprintf(buf, "%s\n", shost->max_id == 16 ? "wide" : "narrow");
drivers/scsi/scsi_transport_spi.c:	return sprintf(buf, "%d\n", shost->this_id);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(sdev->host->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *i = to_spi_internal(sdev->host->transportt);
drivers/scsi/scsi_transport_spi.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_spi.c:	i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	if (!shost->transportt  || shost->transportt->host_attrs.ac.class
drivers/scsi/scsi_transport_spi.c:	i = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *si = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_spi.c:	struct spi_internal *si = to_spi_internal(shost->transportt);
drivers/scsi/scsi_transport_srp.c:	atomic_set(&srp_host->next_port_id, 0);
drivers/scsi/scsi_transport_srp.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_srp.c:	if (shost->transportt->host_attrs.ac.class != &srp_host_class.class)
drivers/scsi/scsi_transport_srp.c:	i = to_srp_internal(shost->transportt);
drivers/scsi/scsi_transport_srp.c:	if (!shost->transportt)
drivers/scsi/scsi_transport_srp.c:	if (shost->transportt->host_attrs.ac.class != &srp_host_class.class)
drivers/scsi/scsi_transport_srp.c:	i = to_srp_internal(shost->transportt);
drivers/scsi/scsi_transport_srp.c:	struct device *parent = &shost->shost_gendev;
drivers/scsi/scsi_transport_srp.c:	dev_set_name(&rport->dev, "port-%d:%d", shost->host_no, id);
drivers/scsi/scsi_transport_srp.c:	if (shost->active_mode & MODE_TARGET &&
drivers/scsi/scsi_transport_srp.c:	if (shost->active_mode & MODE_TARGET &&
drivers/scsi/scsi_transport_srp.c:	device_for_each_child(&shost->shost_gendev, NULL, do_srp_rport_del);
drivers/scsi/scsi_transport_srp.c:	struct srp_internal *i = to_srp_internal(shost->transportt);
drivers/scsi/scsi_transport_srp.c:	struct srp_internal *i = to_srp_internal(shost->transportt);
drivers/scsi/sd.c:	if (host->hostt->bios_param)
drivers/scsi/sd.c:		host->hostt->bios_param(sdp, bdev, sdkp->capacity, diskinfo);
drivers/scsi/sd.c:	if (sdev->host->hostt->compat_ioctl) {
drivers/scsi/sd.c:		ret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);
drivers/scsi/sd.c:	if (sdp->host->max_cmd_len < 16)
drivers/scsi/sd.c:	if (sdev->host->hostt->unlock_native_capacity)
drivers/scsi/sd.c:		sdev->host->hostt->unlock_native_capacity(sdev);
drivers/scsi/ses.c:		while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
drivers/scsi/ses.c:	while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
drivers/scsi/sg.c:			sfp->low_dma = sdp->device->host->unchecked_isa_dma;
drivers/scsi/sg.c:			__put_user((int) sdp->device->host->host_no,
drivers/scsi/sg.c:			__put_user((short) sdp->device->host->cmd_per_lun,
drivers/scsi/sg.c:		return put_user(sdp->device->host->hostt->emulated, ip);
drivers/scsi/sg.c:	if (sdev->host->hostt->compat_ioctl) { 
drivers/scsi/sg.c:		ret = sdev->host->hostt->compat_ioctl(sdev, cmd_in, (void __user *)arg);
drivers/scsi/sg.c:	    !sfp->parentdp->device->host->unchecked_isa_dma &&
drivers/scsi/sg.c:	    sdp->device->host->unchecked_isa_dma : 1;
drivers/scsi/sg.c:			      scsidp->host->host_no, scsidp->channel,
drivers/scsi/sg.c:			     scsidp->host->host_no,
drivers/scsi/sg.c:			     scsidp->host->hostt->emulated);
drivers/scsi/sgiwd93.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/sgiwd93.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/sgiwd93.c:		(struct hpc3_scsiregs *) cmd->device->host->base;
drivers/scsi/sgiwd93.c:	hregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;
drivers/scsi/sgiwd93.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/sgiwd93.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/sgiwd93.c:	host->base = (unsigned long) hregs;
drivers/scsi/sgiwd93.c:	host->irq = irq;
drivers/scsi/sgiwd93.c:	struct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;
drivers/scsi/sim710.c:	host->this_id = scsi_id;
drivers/scsi/sim710.c:	host->base = base_addr;
drivers/scsi/sim710.c:	host->irq = irq;
drivers/scsi/sim710.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/sim710.c:	free_irq(host->irq, host);
drivers/scsi/sim710.c:	release_region(host->base, 64);
drivers/scsi/sni_53c710.c:	host->this_id = 7;
drivers/scsi/sni_53c710.c:	host->base = base;
drivers/scsi/sni_53c710.c:	host->irq = platform_get_irq(dev, 0);
drivers/scsi/sni_53c710.c:	if(request_irq(host->irq, NCR_700_intr, IRQF_SHARED, "snirm710", host)) {
drivers/scsi/sni_53c710.c:		(struct NCR_700_Host_Parameters *)host->hostdata[0];
drivers/scsi/sni_53c710.c:	free_irq(host->irq, host);
drivers/scsi/sr_ioctl.c:#define SR_GFP_DMA(cd) (((cd)->device->host->unchecked_isa_dma) ? GFP_DMA : 0)
drivers/scsi/st.c:	if (sdev->host->hostt->compat_ioctl) { 
drivers/scsi/st.c:		ret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);
drivers/scsi/st.c:	tpnt->try_dio = try_direct_io && !SDp->host->unchecked_isa_dma;
drivers/scsi/stex.c:		dst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);
drivers/scsi/stex.c:		dst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);
drivers/scsi/stex.c:	scsi_activate_tcq(sdev, sdev->host->can_queue);
drivers/scsi/stex.c:	hba = (struct st_hba *) &host->hostdata[0];
drivers/scsi/stex.c:		if (hba->cardtype == st_shasta || id == host->max_id - 1) {
drivers/scsi/stex.c:		if (id == host->max_id - 1) {
drivers/scsi/stex.c:		if (lun >= host->max_lun) {
drivers/scsi/stex.c:		if (id != host->max_id - 1)
drivers/scsi/stex.c:			ver.console_id = host->max_id - 1;
drivers/scsi/stex.c:			ver.host_no = hba->host->host_no;
drivers/scsi/stex.c:	if (unlikely(tag >= host->can_queue))
drivers/scsi/stex.c:		if (unlikely(tag >= hba->host->can_queue)) {
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:		if (unlikely(tag >= hba->host->can_queue)) {
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:		if (hba->host->can_queue > data) {
drivers/scsi/stex.c:			hba->host->can_queue = data;
drivers/scsi/stex.c:			hba->host->cmd_per_lun = data;
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	struct st_hba *hba = (struct st_hba *)host->hostdata;
drivers/scsi/stex.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/stex.c:	if (tag < host->can_queue &&
drivers/scsi/stex.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:		spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:	for (tag = 0; tag < hba->host->can_queue; tag++) {
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/stex.c:	hba = (struct st_hba *) &cmd->device->host->hostdata[0];
drivers/scsi/stex.c:	hba = (struct st_hba *)host->hostdata;
drivers/scsi/stex.c:		host->sg_tablesize = 38;
drivers/scsi/stex.c:		host->sg_tablesize = 32;
drivers/scsi/stex.c:	host->can_queue = ci->rq_count;
drivers/scsi/stex.c:	host->cmd_per_lun = ci->rq_count;
drivers/scsi/stex.c:	host->max_id = ci->max_id;
drivers/scsi/stex.c:	host->max_lun = ci->max_lun;
drivers/scsi/stex.c:	host->max_channel = ci->max_channel;
drivers/scsi/stex.c:	host->unique_id = host->host_no;
drivers/scsi/stex.c:	host->max_cmd_len = STEX_CDB_LENGTH;
drivers/scsi/stex.c:		 "stex_wq_%d", host->host_no);
drivers/scsi/stex.c:	err = scsi_init_shared_tag_map(host, host->can_queue);
drivers/scsi/stex.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/stex.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/storvsc_drv.c:	for (id = 0; id < wrk->host->max_id; ++id) {
drivers/scsi/storvsc_drv.c:		if (wrk->host->reverse_ordering)
drivers/scsi/storvsc_drv.c:			order_id = wrk->host->max_id - id - 1;
drivers/scsi/storvsc_drv.c:		scsi_scan_target(&wrk->host->shost_gendev, 0,
drivers/scsi/storvsc_drv.c:	host_dev->port = host->host_no;
drivers/scsi/storvsc_drv.c:	stor_device->port_number = host->host_no;
drivers/scsi/storvsc_drv.c:	host->max_lun = STORVSC_MAX_LUNS_PER_TARGET;
drivers/scsi/storvsc_drv.c:	host->max_id = STORVSC_MAX_TARGETS;
drivers/scsi/storvsc_drv.c:	host->max_channel = STORVSC_MAX_CHANNELS - 1;
drivers/scsi/storvsc_drv.c:	host->max_cmd_len = STORVSC_MAX_CMD_LEN;
drivers/scsi/sun3_NCR5380.c:#define	H_NO(cmd)	(cmd)->device->host->host_no
drivers/scsi/sun3_NCR5380.c: * been issued, the host->busy array is still employed, as it is without
drivers/scsi/sun3x_esp.c:			       esp->host->unique_id);
drivers/scsi/sun3x_esp.c:			       "invalidate!\n", esp->host->unique_id);
drivers/scsi/sun3x_esp.c:	host->max_id = 8;
drivers/scsi/sun3x_esp.c:	host->irq = platform_get_irq(dev, 0);
drivers/scsi/sun3x_esp.c:	err = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED,
drivers/scsi/sun3x_esp.c:	esp->host->this_id = esp->scsi_id;
drivers/scsi/sun3x_esp.c:	free_irq(host->irq, esp);
drivers/scsi/sun3x_esp.c:	unsigned int irq = esp->host->irq;
drivers/scsi/sun_esp.c:	host->irq = op->archdata.irqs[0];
drivers/scsi/sun_esp.c:	return request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, "ESP", esp);
drivers/scsi/sun_esp.c:	esp->host->this_id = esp->scsi_id;
drivers/scsi/sun_esp.c:				       esp->host->unique_id);
drivers/scsi/sun_esp.c:			       esp->host->unique_id);
drivers/scsi/sun_esp.c:				       "invalidate!\n", esp->host->unique_id);
drivers/scsi/sun_esp.c:	host->max_id = (hme ? 16 : 8);
drivers/scsi/sun_esp.c:	free_irq(host->irq, esp);
drivers/scsi/sun_esp.c:	unsigned int irq = esp->host->irq;
drivers/scsi/sym53c416.c:	int base = SChost->io_port;
drivers/scsi/sym53c416.c:	int irq = SChost->irq;
drivers/scsi/sym53c416.c:	base = SCpnt->device->host->io_port;
drivers/scsi/sym53c416.c:	base = SCpnt->device->host->io_port;
drivers/scsi/sym53c416.c:	if (shost->irq)
drivers/scsi/sym53c416.c:		free_irq(shost->irq, shost);
drivers/scsi/sym53c416.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/sym53c416.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irqsave(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irqrestore(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_lock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_unlock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irqsave(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irqrestore(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irqsave(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irqrestore(np->s.host->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:		spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irqsave(shost->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->max_channel	= 0;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->this_id		= np->myaddr;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->max_id		= np->maxwide ? 16 : 8;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->max_lun		= SYM_CONF_MAX_LUN;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->unique_id	= pci_resource_start(pdev, 0);
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->cmd_per_lun	= SYM_CONF_MAX_TAG;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->can_queue	= (SYM_CONF_MAX_START-2);
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->sg_tablesize	= SYM_CONF_MAX_SG;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->max_cmd_len	= 16;
drivers/scsi/sym53c8xx_2/sym_glue.c:	shost->transportt	= sym2_transport_template;
drivers/scsi/sym53c8xx_2/sym_glue.c:		shost->dma_boundary = 0xFFFFFF;
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irqrestore(shost->host_lock, flags);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_lock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.c:	spin_unlock_irq(shost->host_lock);
drivers/scsi/sym53c8xx_2/sym_glue.h:	return ((struct sym_data *)host->hostdata)->ncb;
drivers/scsi/sym53c8xx_2/sym_nvram.c:			shost->reverse_ordering = 1;
drivers/scsi/t128.c:	if (shost->irq)
drivers/scsi/t128.c:		free_irq(shost->irq, shost);
drivers/scsi/t128.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/t128.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/tmscsim.c:	struct dc390_acb *acb = (struct dc390_acb *)sdev->host->hostdata;
drivers/scsi/tmscsim.c:	struct dc390_acb *pACB = (struct dc390_acb*) cmd->device->host->hostdata;
drivers/scsi/tmscsim.c:	struct dc390_acb*    pACB = (struct dc390_acb*) cmd->device->host->hostdata;
drivers/scsi/tmscsim.c:	spin_lock_irq(cmd->device->host->host_lock);
drivers/scsi/tmscsim.c:	spin_unlock_irq(cmd->device->host->host_lock);
drivers/scsi/tmscsim.c:	struct dc390_acb *pACB = (struct dc390_acb*) scsi_device->host->hostdata;
drivers/scsi/tmscsim.c:	struct dc390_acb* pACB = (struct dc390_acb*) scsi_device->host->hostdata;
drivers/scsi/tmscsim.c:	struct dc390_acb *acb = (struct dc390_acb *)sdev->host->hostdata;
drivers/scsi/tmscsim.c:	DC390_write8(CtrlReg1, DIS_INT_ON_SCSI_RST | shost->this_id);
drivers/scsi/tmscsim.c:		shost->last_reset = jiffies + HZ/2 +
drivers/scsi/tmscsim.c:	pACB = (struct dc390_acb *)shost->hostdata;
drivers/scsi/tmscsim.c:	shost->this_id = dc390_eepromBuf[dc390_adapterCnt][EE_ADAPT_SCSI_ID];
drivers/scsi/tmscsim.c:	shost->io_port = io_port;
drivers/scsi/tmscsim.c:	shost->n_io_port = 0x80;
drivers/scsi/tmscsim.c:	shost->irq = pdev->irq;
drivers/scsi/tmscsim.c:	shost->base = io_port;
drivers/scsi/tmscsim.c:	shost->unique_id = io_port;
drivers/scsi/tmscsim.c:	shost->last_reset = jiffies;
drivers/scsi/tmscsim.c:	shost->max_id = 8;
drivers/scsi/tmscsim.c:	if (shost->max_id - 1 ==
drivers/scsi/tmscsim.c:		shost->max_id--;
drivers/scsi/tmscsim.c:		shost->max_lun = 8;
drivers/scsi/tmscsim.c:		shost->max_lun = 1;
drivers/scsi/tmscsim.c:	if (!request_region(io_port, shost->n_io_port, "tmscsim")) {
drivers/scsi/tmscsim.c:	release_region(io_port, shost->n_io_port);
drivers/scsi/tmscsim.c:	struct dc390_acb* pACB = (struct dc390_acb*) scsi_host->hostdata;
drivers/scsi/tmscsim.c:	spin_lock_irqsave(scsi_host->host_lock, iflags);
drivers/scsi/tmscsim.c:	spin_unlock_irqrestore(scsi_host->host_lock, iflags);
drivers/scsi/tmscsim.c:	free_irq(scsi_host->irq, pACB);
drivers/scsi/tmscsim.c:	release_region(scsi_host->io_port, scsi_host->n_io_port);
drivers/scsi/u14-34f.c: *        + Use host->host_lock instead of io_request_lock.
drivers/scsi/u14-34f.c: *          Use host->wish_block instead of host->block.
drivers/scsi/u14-34f.c: *          The host->block flag is set for all the detected ISA boards.
drivers/scsi/u14-34f.c: *  the driver sets host->wish_block = TRUE for all ISA boards.
drivers/scsi/u14-34f.c:   j = ((struct hostdata *) host->hostdata)->board_number;
drivers/scsi/u14-34f.c:   j = ((struct hostdata *) SCpnt->device->host->hostdata)->board_number;
drivers/scsi/u14-34f.c:   j = ((struct hostdata *) SCarg->device->host->hostdata)->board_number;
drivers/scsi/u14-34f.c:   j = ((struct hostdata *) SCarg->device->host->hostdata)->board_number;
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(hba->host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock(hba->host->host_lock);
drivers/scsi/ufs/ufshcd.c:	spin_unlock(hba->host->host_lock);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:		spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ufs/ufshcd.c:	host->can_queue = hba->nutrs;
drivers/scsi/ufs/ufshcd.c:	host->cmd_per_lun = hba->nutrs;
drivers/scsi/ufs/ufshcd.c:	host->max_id = UFSHCD_MAX_ID;
drivers/scsi/ufs/ufshcd.c:	host->max_lun = UFSHCD_MAX_LUNS;
drivers/scsi/ufs/ufshcd.c:	host->max_channel = UFSHCD_MAX_CHANNEL;
drivers/scsi/ufs/ufshcd.c:	host->unique_id = host->host_no;
drivers/scsi/ufs/ufshcd.c:	host->max_cmd_len = MAX_CDB_SIZE;
drivers/scsi/ufs/ufshcd.c:	err = scsi_init_shared_tag_map(host, host->can_queue);
drivers/scsi/ultrastor.c:	if (shost->irq)
drivers/scsi/ultrastor.c:		free_irq(shost->irq, NULL);
drivers/scsi/ultrastor.c:	if (shost->dma_channel != 0xff)
drivers/scsi/ultrastor.c:		free_dma(shost->dma_channel);
drivers/scsi/ultrastor.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/ultrastor.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/ultrastor.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ultrastor.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ultrastor.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ultrastor.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ultrastor.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ultrastor.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/ultrastor.c:    spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/ultrastor.c:    spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/virtio_scsi.c:		BUG_ON(scsi_sg_count(sc) > shost->sg_tablesize);
drivers/scsi/virtio_scsi.c:	shost->sg_tablesize = sg_elems;
drivers/scsi/virtio_scsi.c:	shost->cmd_per_lun = min_t(u32, cmd_per_lun, shost->can_queue);
drivers/scsi/virtio_scsi.c:	shost->max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;
drivers/scsi/virtio_scsi.c:	shost->max_lun = virtscsi_config_get(vdev, max_lun) + 1;
drivers/scsi/virtio_scsi.c:	shost->max_id = virtscsi_config_get(vdev, max_target) + 1;
drivers/scsi/virtio_scsi.c:	shost->max_channel = 0;
drivers/scsi/virtio_scsi.c:	shost->max_cmd_len = VIRTIO_SCSI_CDB_SIZE;
drivers/scsi/vmw_pvscsi.c:		    adapter->host->host_no, cmd);
drivers/scsi/vmw_pvscsi.c:		    host->host_no, cmd->device->id);
drivers/scsi/vmw_pvscsi.c:		 "vmw_pvscsi_wq_%u", adapter->host->host_no);
drivers/scsi/vmw_pvscsi.c:	host->max_channel = 0;
drivers/scsi/vmw_pvscsi.c:	host->max_id      = 16;
drivers/scsi/vmw_pvscsi.c:	host->max_lun     = 1;
drivers/scsi/vmw_pvscsi.c:	host->max_cmd_len = 16;
drivers/scsi/vmw_pvscsi.c:	host->max_id = pvscsi_get_max_targets(adapter);
drivers/scsi/vmw_pvscsi.c:	dev_info(dev, "vmw_pvscsi: host->max_id: %u\n", host->max_id);
drivers/scsi/vmw_pvscsi.c:		 adapter->rev, host->host_no);
drivers/scsi/wd33c93.c:	hostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;
drivers/scsi/wd33c93.c:	hostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;
drivers/scsi/wd33c93.c:	disable_irq(cmd->device->host->irq);
drivers/scsi/wd33c93.c:			enable_irq(cmd->device->host->irq);
drivers/scsi/wd33c93.c:		enable_irq(cmd->device->host->irq);
drivers/scsi/wd33c93.c:			enable_irq(cmd->device->host->irq);
drivers/scsi/wd33c93.c:	enable_irq(cmd->device->host->irq);
drivers/scsi/wd7000.c: * use host->host_lock, not io_request_lock, cleanups
drivers/scsi/wd7000.c: *   - An icb is for host-only (non-SCSI) commands.  ICBs are 16 bytes each;
drivers/scsi/wd7000.c: *  This driver is written to allow host-only commands to be executed.
drivers/scsi/wd7000.c:	host->control |= INT_EN;
drivers/scsi/wd7000.c:	outb(host->control, host->iobase + ASC_CONTROL);
drivers/scsi/wd7000.c:	host->control |= DMA_EN;
drivers/scsi/wd7000.c:	outb(host->control, host->iobase + ASC_CONTROL);
drivers/scsi/wd7000.c:	set_dma_mode(host->dma, DMA_MODE_CASCADE);
drivers/scsi/wd7000.c:	enable_dma(host->dma);
drivers/scsi/wd7000.c:	if (!WAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0)) {
drivers/scsi/wd7000.c:				outb(*cmd, host->iobase + ASC_COMMAND);
drivers/scsi/wd7000.c:				WAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0);
drivers/scsi/wd7000.c:			} while (inb(host->iobase + ASC_STAT) & CMD_REJ);
drivers/scsi/wd7000.c:	spin_unlock_irq(host->host_lock);
drivers/scsi/wd7000.c:	spin_lock_irq(host->host_lock);
drivers/scsi/wd7000.c:	Mailbox *ogmbs = host->mb.ogmb;
drivers/scsi/wd7000.c:	int *next_ogmb = &(host->next_ogmb);
drivers/scsi/wd7000.c:	spin_lock_irqsave(host->sh->host_lock, flags);
drivers/scsi/wd7000.c:	spin_unlock_irqrestore(host->sh->host_lock, flags);
drivers/scsi/wd7000.c:#define wd7000_intr_ack(host)   outb (0, host->iobase + ASC_INTR_ACK)
drivers/scsi/wd7000.c:	Mailbox *icmbs = host->mb.icmb;
drivers/scsi/wd7000.c:	spin_lock_irqsave(host->sh->host_lock, flags);
drivers/scsi/wd7000.c:	host->int_counter++;
drivers/scsi/wd7000.c:	flag = inb(host->iobase + ASC_INTR_STAT);
drivers/scsi/wd7000.c:	if (!(inb(host->iobase + ASC_STAT) & INT_IM)) {
drivers/scsi/wd7000.c:	spin_unlock_irqrestore(host->sh->host_lock, flags);
drivers/scsi/wd7000.c:	Adapter *host = (Adapter *) SCpnt->device->host->hostdata;
drivers/scsi/wd7000.c:		host->bus_on,
drivers/scsi/wd7000.c:		host->bus_off,
drivers/scsi/wd7000.c:	outb(ASC_RES, host->iobase + ASC_CONTROL);
drivers/scsi/wd7000.c:	outb(0, host->iobase + ASC_CONTROL);
drivers/scsi/wd7000.c:	host->control = 0;	/* this must always shadow ASC_CONTROL */
drivers/scsi/wd7000.c:	if (WAIT(host->iobase + ASC_STAT, ASC_STATMASK, CMD_RDY, 0)) {
drivers/scsi/wd7000.c:	if ((diag = inb(host->iobase + ASC_INTR_STAT)) != 1) {
drivers/scsi/wd7000.c:	memset(&(host->mb), 0, sizeof(host->mb));
drivers/scsi/wd7000.c:	any2scsi((unchar *) & (init_cmd.mailboxes), (int) &(host->mb));
drivers/scsi/wd7000.c:	if (WAIT(host->iobase + ASC_STAT, ASC_STATMASK, ASC_INIT, 0)) {
drivers/scsi/wd7000.c:	if (request_irq(host->irq, wd7000_intr, IRQF_DISABLED, "wd7000", host)) {
drivers/scsi/wd7000.c:		printk("wd7000_init: can't get IRQ %d.\n", host->irq);
drivers/scsi/wd7000.c:	if (request_dma(host->dma, "wd7000")) {
drivers/scsi/wd7000.c:		printk("wd7000_init: can't get DMA channel %d.\n", host->dma);
drivers/scsi/wd7000.c:		free_irq(host->irq, host);
drivers/scsi/wd7000.c:		free_dma(host->dma);
drivers/scsi/wd7000.c:		free_irq(host->irq, NULL);
drivers/scsi/wd7000.c:	host->rev1 = icb.primary;
drivers/scsi/wd7000.c:	host->rev2 = icb.secondary;
drivers/scsi/wd7000.c:	Adapter *adapter = (Adapter *)host->hostdata;
drivers/scsi/wd7000.c:	spin_lock_irqsave(host->host_lock, flags);
drivers/scsi/wd7000.c:	SPRINTF("Host scsi%d: Western Digital WD-7000 (rev %d.%d)\n", host->host_no, adapter->rev1, adapter->rev2);
drivers/scsi/wd7000.c:	spin_unlock_irqrestore(host->host_lock, flags);
drivers/scsi/wd7000.c:				host->irq = configs[pass].irq;
drivers/scsi/wd7000.c:				host->dma = configs[pass].dma;
drivers/scsi/wd7000.c:				host->iobase = iobase;
drivers/scsi/wd7000.c:				host->int_counter = 0;
drivers/scsi/wd7000.c:				host->bus_on = configs[pass].bus_on;
drivers/scsi/wd7000.c:				host->bus_off = configs[pass].bus_off;
drivers/scsi/wd7000.c:				host->sh = wd7000_host[unit] = sh;
drivers/scsi/wd7000.c:				dprintk("wd7000_detect: Trying init WD-7000 card at IO " "0x%x, IRQ %d, DMA %d...\n", host->iobase, host->irq, host->dma);
drivers/scsi/wd7000.c:				if (host->rev1 < 6)
drivers/scsi/wd7000.c:				printk(KERN_INFO "Western Digital WD-7000 (rev %d.%d) ", host->rev1, host->rev2);
drivers/scsi/wd7000.c:				printk("using IO 0x%x, IRQ %d, DMA %d.\n", host->iobase, host->irq, host->dma);
drivers/scsi/wd7000.c:				printk("  BUS_ON time: %dns, BUS_OFF time: %dns\n", host->bus_on * 125, host->bus_off * 125);
drivers/scsi/wd7000.c:	if (shost->irq)
drivers/scsi/wd7000.c:		free_irq(shost->irq, NULL);
drivers/scsi/wd7000.c:	if (shost->io_port && shost->n_io_port)
drivers/scsi/wd7000.c:		release_region(shost->io_port, shost->n_io_port);
drivers/scsi/wd7000.c:	Adapter *host = (Adapter *) SCpnt->device->host->hostdata;
drivers/scsi/wd7000.c:	if (inb(host->iobase + ASC_STAT) & INT_IM) {
drivers/scsi/wd7000.c:		wd7000_intr_handle(host->irq, NULL, NULL);
drivers/scsi/wd7000.c:	Adapter *host = (Adapter *) SCpnt->device->host->hostdata;
drivers/scsi/wd7000.c:	spin_lock_irq(SCpnt->device->host->host_lock);
drivers/scsi/wd7000.c:		spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/wd7000.c:	spin_unlock_irq(SCpnt->device->host->host_lock);
drivers/scsi/zorro7xx.c:	host->this_id = 7;
drivers/scsi/zorro7xx.c:	host->base = ioaddr;
drivers/scsi/zorro7xx.c:	host->irq = IRQ_AMIGA_PORTS;
drivers/scsi/zorro7xx.c:	if (request_irq(host->irq, NCR_700_intr, IRQF_SHARED, "zorro7xx-scsi",
drivers/scsi/zorro7xx.c:	free_irq(host->irq, host);
drivers/ssb/driver_pcicore.c:		/* This SSB device is not on a PCI host-bus. So the IRQs are
drivers/ssb/main.c:/* Ops for the plain SSB bus without a host-device (no PCI or PCMCIA). */
drivers/staging/comedi/drivers/plx9080.h: * memory so host-side accesses cannot occur.
drivers/staging/cxt1e1/musycc.c:         * Otherwise, we have a valid, host-owned message descriptor which
drivers/staging/cxt1e1/musycc.c:         * Note: Per MUSYCC Ref 6.4.9, the host does not poll a host-owned
drivers/staging/keucr/scsiglue.c:		for (i = 1; i < host->max_id; ++i)
drivers/staging/keucr/scsiglue.c:	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
drivers/staging/keucr/usb.c:	host->max_cmd_len = 16;
drivers/staging/keucr/usb.h:	return (struct us_data *) host->hostdata;
drivers/staging/keucr/usb.h:#define scsi_unlock(host)	spin_unlock_irq(host->host_lock)
drivers/staging/keucr/usb.h:#define scsi_lock(host)		spin_lock_irq(host->host_lock)
drivers/staging/rtl8187se/ieee80211/ieee80211_crypt_ccmp.c: * Host AP crypt: host-based CCMP encryption implementation for Host AP driver
drivers/staging/rtl8187se/ieee80211/ieee80211_crypt_tkip.c: * Host AP crypt: host-based TKIP encryption implementation for Host AP driver
drivers/staging/rtl8187se/ieee80211/ieee80211_crypt_wep.c: * Host AP crypt: host-based WEP encryption implementation for Host AP driver
drivers/staging/rtl8192e/rtllib_crypt_ccmp.c: * Host AP crypt: host-based CCMP encryption implementation for Host AP driver
drivers/staging/rtl8192e/rtllib_crypt_tkip.c: * Host AP crypt: host-based TKIP encryption implementation for Host AP driver
drivers/staging/rtl8192e/rtllib_crypt_wep.c: * Host AP crypt: host-based WEP encryption implementation for Host AP driver
drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c: * Host AP crypt: host-based CCMP encryption implementation for Host AP driver
drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c: * Host AP crypt: host-based TKIP encryption implementation for Host AP driver
drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_wep.c: * Host AP crypt: host-based WEP encryption implementation for Host AP driver
drivers/staging/rts5139/rts51x.c:	host->max_cmd_len = 16;
drivers/staging/rts5139/rts51x.h:#define scsi_unlock(host)	spin_unlock_irq(host->host_lock)
drivers/staging/rts5139/rts51x.h:#define scsi_lock(host)		spin_lock_irq(host->host_lock)
drivers/staging/rts5139/rts51x.h:	return (struct rts51x_chip *)(host->hostdata);
drivers/staging/rts5139/rts51x_scsi.c:	SPRINTF("   Host scsi%d: %s\n", host->host_no, RTS51X_NAME);
drivers/staging/rts_pstor/rtsx.c:	SPRINTF("   Host scsi%d: %s\n", host->host_no, CR_DRIVER_NAME);
drivers/staging/rts_pstor/rtsx.c:	host->max_id = 1;
drivers/staging/rts_pstor/rtsx.c:	host->max_lun = dev->chip->max_lun;
drivers/staging/rts_pstor/rtsx.h:	return (struct rtsx_dev *) host->hostdata;
drivers/staging/rts_pstor/rtsx.h:#define scsi_unlock(host)	spin_unlock_irq(host->host_lock)
drivers/staging/rts_pstor/rtsx.h:#define scsi_lock(host)		spin_lock_irq(host->host_lock)
drivers/staging/tidspbridge/dynload/cload.c: * be purged, and any host-side storage used by the dynamic loader for
drivers/staging/tidspbridge/include/dspbridge/dynamic_loader.h: * be purged, and any host-side storage used by the dynamic loader for
drivers/staging/tidspbridge/include/dspbridge/dynamic_loader.h: * miscellaneous host-side functions
drivers/staging/tidspbridge/rmgr/node.c:	/*  Free host-side resources allocated by node_create()
drivers/staging/usbip/Makefile:usbip-host-y := stub_dev.o stub_main.o stub_rx.o stub_tx.o
drivers/staging/wlags49_h2/hcf.c: *  - resolve the "last host-owned descriptor" problems when a descriptor list is reclaimed by the MSF.
drivers/staging/wlags49_h2/hcf.c: * This function makes a copy of that last host-owned descriptor, so the MSF will get a copy of the descriptor.
drivers/staging/wlags49_h2/hcf.c: *                - A Tx packet has been copied from host-RAM into NIC-RAM by the DMA engine
drivers/staging/wlags49_h2/wl_internal.h:	DESC_STRCT  *rx_reclaim_desc, *tx_reclaim_desc; // Descriptors for host-reclaim purposes (see HCF)
drivers/staging/wlan-ng/prism2sta.c:* we'd like to have in host-side data structures.
drivers/target/loopback/tcm_loop.c:		" scsi_buf_len: %u\n", sc->device->host->host_no,
drivers/target/target_core_file.c:	fd_host->fd_host_id = host_id;
drivers/target/target_core_file.c:		hba->hba_id, fd_host->fd_host_id, FD_MAX_SECTORS);
drivers/target/target_core_file.c:		" Target Core\n", hba->hba_id, fd_host->fd_host_id);
drivers/target/target_core_file.c:	fd_dev->fd_dev_id = fd_host->fd_host_dev_id_count++;
drivers/target/target_core_file.c:		" %llu total bytes\n", fd_host->fd_host_id, fd_dev->fd_dev_id,
drivers/target/target_core_pscsi.c:			(scsi_host->hostt->name) ? (scsi_host->hostt->name) :
drivers/target/target_core_pscsi.c:	limits->max_hw_sectors = min_t(int, sd->host->max_sectors, queue_max_hw_sectors(q));
drivers/target/target_core_pscsi.c:	limits->max_sectors = min_t(int, sd->host->max_sectors, queue_max_sectors(q));
drivers/target/target_core_pscsi.c:		 * Functions will release the held struct scsi_host->host_lock
drivers/target/target_core_rd.c:	rd_host->rd_host_id = host_id;
drivers/target/target_core_rd.c:		rd_host->rd_host_id, RD_MAX_SECTORS);
drivers/target/target_core_rd.c:		" Generic Target Core\n", hba->hba_id, rd_host->rd_host_id);
drivers/target/target_core_rd.c:		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
drivers/target/target_core_rd.c:		" %u pages in %u tables\n", rd_dev->rd_host->rd_host_id,
drivers/target/target_core_rd.c:	rd_dev->rd_dev_id = rd_host->rd_host_dev_id_count++;
drivers/target/target_core_rd.c:		rd_host->rd_host_id, (!rd_dev->rd_direct) ? "MEMCPY" :
drivers/usb/Kconfig:	  Say Y here if your computer has a host-side USB port and you want
drivers/usb/core/hub.c:	 * many devices can't handle it.  Instead just reset the host-side
drivers/usb/core/message.c: * Resets any host-side endpoint state such as the toggle bit,
drivers/usb/dwc3/dwc3_otg.c:					__func__, otg->host->bus_name);
drivers/usb/dwc3/dwc3_otg.c:					__func__, otg->host->bus_name);
drivers/usb/dwc3/dwc3_otg.c:					__func__, host->bus_name);
drivers/usb/gadget/Kconfig:# NOTE:  Gadget support ** DOES NOT ** depend on host-side CONFIG_USB !!
drivers/usb/gadget/Kconfig:	  which can be configured for peripheral-only, host-only, hub-only
drivers/usb/gadget/Kconfig:	  USB peripheral controller driver.  Then you can use host-side
drivers/usb/gadget/Kconfig:	  Gadget Zero also works with the host-side "usb-skeleton" driver,
drivers/usb/gadget/Kconfig:	  and with many kinds of host-side test software.  You may need
drivers/usb/gadget/Kconfig:	  The Linux-USB host-side "usbnet" driver interoperates with this
drivers/usb/gadget/ether.c: * with pxa250.  We're protocol-compatible, if the host-side drivers
drivers/usb/gadget/goku_udc.h:	/* analogous to a host-side qh */
drivers/usb/gadget/net2272.c:	/* host-to-device transfer */
drivers/usb/gadget/net2272.c:	/* host-to-device transfer completed */
drivers/usb/gadget/net2272.h:	/* analogous to a host-side qh */
drivers/usb/gadget/net2280.h:	/* analogous to a host-side qh */
drivers/usb/gadget/u_ether.c:	/* two kinds of host-initiated state changes:
drivers/usb/host/ehci-xilinx-of.c:		{.compatible = "xlnx,xps-usb-host-1.00.a",},
drivers/usb/host/ohci-ssb.c:		/* Put the device into host-mode. */
drivers/usb/host/xhci-ring.c:		 * U3Exit state after a host-initiated resume.  If it's a device
drivers/usb/image/microtek.c:	struct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);
drivers/usb/image/microtek.c:	struct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);
drivers/usb/image/microtek.c:	struct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);
drivers/usb/image/microtek.c:	new_desc->host->hostdata[0] = (unsigned long)new_desc;
drivers/usb/musb/musb_core.c: *  - Lack of host-side transaction scheduling, for all transfer types.
drivers/usb/musb/musb_core.c:					&& otg->host->b_hnp_enable;
drivers/usb/musb/musb_core.c:	/* For the host-only role, we can activate right away.
drivers/usb/musb/musb_core.h: * OTG or host-only go to A_IDLE when ID is sensed.
drivers/usb/musb/musb_virthub.c:					&& otg->host->b_hnp_enable;
drivers/usb/musb/musb_virthub.c:					&& otg->host->b_hnp_enable;
drivers/usb/musb/musb_virthub.c:				&& otg->host->b_hnp_enable) {
drivers/usb/otg/Kconfig:# USB OTG infrastructure may be needed for peripheral-only, host-only,
drivers/usb/otg/fsl_otg.c:	if (!fsl_otg_dev->phy.otg->host->b_hnp_enable)
drivers/usb/otg/fsl_otg.c:	dev = otg->host->controller;
drivers/usb/otg/fsl_otg.c:		otg->host->otg_port = fsl_otg_initdata.otg_port;
drivers/usb/otg/fsl_otg.c:		otg->host->is_b_host = otg_dev->fsm.id;
drivers/usb/otg/fsl_otg.c:				otg->host->is_b_host = fsm->id;
drivers/usb/otg/isp1301_omap.c:	dev = isp->phy.otg->host->controller;
drivers/usb/otg/isp1301_omap.c:	dev = isp->phy.otg->host->controller;
drivers/usb/otg/isp1301_omap.c:		isp->phy.otg->host->is_b_host = 0;
drivers/usb/otg/isp1301_omap.c:		isp->phy.otg->host->is_b_host = 1;
drivers/usb/otg/isp1301_omap.c:			usb_bus_start_enum(otg->host, otg->host->otg_port);
drivers/usb/otg/isp1301_omap.c:	if (otg->default_a && (otg->host == NULL || !otg->host->b_hnp_enable))
drivers/usb/otg/msm72k_otg.c:	host->otg_port = 1;
drivers/usb/otg/msm72k_otg.c:			if (dev->phy.otg->host->b_hnp_enable &&
drivers/usb/otg/msm72k_otg.c:			dev->phy.otg->host->is_b_host = 1;
drivers/usb/otg/msm72k_otg.c:			dev->phy.otg->host->is_b_host = 0;
drivers/usb/otg/msm72k_otg.c:			dev->phy.otg->host->is_b_host = 0;
drivers/usb/otg/msm72k_otg.c:			dev->phy.otg->host->is_b_host = 0;
drivers/usb/otg/msm72k_otg.c:			if (dev->phy.otg->host->b_hnp_enable) {
drivers/usb/otg/msm72k_otg.c:				dev->phy.otg->host->b_hnp_enable) {
drivers/usb/otg/msm72k_otg.c:				!dev->phy.otg->host->b_hnp_enable) {
drivers/usb/otg/msm_otg.c:	struct usb_device *rhub = otg->host->root_hub;
drivers/usb/otg/msm_otg.c:	host->otg_port = 1;
drivers/usb/otg/msm_otg.c: * of OTG, mode switch (host-->peripheral/peripheral-->host) can happen
drivers/usb/otg/msm_otg.c:			otg->host->is_b_host = 1;
drivers/usb/otg/msm_otg.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg.c:			if (otg->host->b_hnp_enable)
drivers/usb/otg/msm_otg.c:				otg->host->b_hnp_enable) {
drivers/usb/otg/msm_otg.c:				!otg->host->b_hnp_enable) {
drivers/usb/otg/msm_otg.c:			if (otg->host->b_hnp_enable && (pc & PORTSC_CSC) &&
drivers/usb/otg/msm_otg_htc.c:	struct usb_device *rhub = otg->host->root_hub;
drivers/usb/otg/msm_otg_htc.c:	host->otg_port = 1;
drivers/usb/otg/msm_otg_htc.c:			otg->host->is_b_host = 1;
drivers/usb/otg/msm_otg_htc.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg_htc.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg_htc.c:			otg->host->is_b_host = 0;
drivers/usb/otg/msm_otg_htc.c:			if (otg->host->b_hnp_enable)
drivers/usb/otg/msm_otg_htc.c:				otg->host->b_hnp_enable) {
drivers/usb/otg/msm_otg_htc.c:				!otg->host->b_hnp_enable) {
drivers/usb/otg/msm_otg_htc.c:			if (otg->host->b_hnp_enable && (pc & PORTSC_CSC) &&
drivers/usb/otg/otg_fsm.c:				fsm->otg->host->otg_port);
drivers/usb/otg/otg_fsm.c:				fsm->otg->host->b_hnp_enable)
drivers/usb/otg/otg_fsm.c:		if (!fsm->b_conn && fsm->otg->host->b_hnp_enable)
drivers/usb/otg/otg_fsm.c:		else if (!fsm->b_conn && !fsm->otg->host->b_hnp_enable)
drivers/usb/storage/scsiglue.c:		for (i = 1; i < host->max_id; ++i)
drivers/usb/storage/scsiglue.c:	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
drivers/usb/storage/uas.c:	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
drivers/usb/storage/uas.c:	sdev->hostdata = (void *)sdev->host->hostdata[0];
drivers/usb/storage/uas.c:	shost->max_cmd_len = 16 + 252;
drivers/usb/storage/uas.c:	shost->max_id = 1;
drivers/usb/storage/uas.c:	shost->sg_tablesize = udev->bus->sg_tablesize;
drivers/usb/storage/uas.c:	shost->hostdata[0] = (unsigned long)devinfo;
drivers/usb/storage/uas.c:	struct uas_dev_info *devinfo = (void *)shost->hostdata[0];
drivers/usb/storage/usb.c:	host->max_cmd_len = 16;
drivers/usb/storage/usb.c:	host->sg_tablesize = usb_stor_sg_tablesize(intf);
drivers/usb/storage/usb.h:	return (struct us_data *) host->hostdata;
drivers/usb/storage/usb.h:#define scsi_unlock(host)	spin_unlock_irq(host->host_lock)
drivers/usb/storage/usb.h:#define scsi_lock(host)		spin_lock_irq(host->host_lock)
drivers/usb/wusbcore/Kconfig:	  Enable the host-side support for Wireless USB.
drivers/vhost/net.c:	.name = "vhost-net",
drivers/vhost/net.c:MODULE_ALIAS("devname:vhost-net");
drivers/vhost/test.c:	"vhost-test",
drivers/vhost/vhost.c:	worker = kthread_create(vhost_worker, dev, "vhost-%d", current->pid);
drivers/video/backlight/apple_bl.c:	if (host->vendor == PCI_VENDOR_ID_INTEL)
drivers/video/backlight/apple_bl.c:	else if (host->vendor == PCI_VENDOR_ID_NVIDIA)
drivers/video/mxsfb.c:#define mxsfb_is_v3(host) (host->devdata->ipversion == 3)
drivers/video/mxsfb.c:#define mxsfb_is_v4(host) (host->devdata->ipversion == 4)
drivers/video/mxsfb.c:	return (val & host->devdata->hs_wdth_mask) <<
drivers/video/mxsfb.c:		host->devdata->hs_wdth_shift;
drivers/video/mxsfb.c:	return (val >> host->devdata->hs_wdth_shift) &
drivers/video/mxsfb.c:		host->devdata->hs_wdth_mask;
drivers/video/mxsfb.c:		switch (host->ld_intf_width) {
drivers/video/mxsfb.c:	dev_dbg(&host->pdev->dev, "%s\n", __func__);
drivers/video/mxsfb.c:	clk_prepare_enable(host->clk);
drivers/video/mxsfb.c:	clk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);
drivers/video/mxsfb.c:	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);
drivers/video/mxsfb.c:	reg = readl(host->base + LCDC_VDCTRL4);
drivers/video/mxsfb.c:	writel(reg, host->base + LCDC_VDCTRL4);
drivers/video/mxsfb.c:	writel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);
drivers/video/mxsfb.c:	host->enabled = 1;
drivers/video/mxsfb.c:	dev_dbg(&host->pdev->dev, "%s\n", __func__);
drivers/video/mxsfb.c:	writel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);
drivers/video/mxsfb.c:		reg = readl(host->base + LCDC_CTRL);
drivers/video/mxsfb.c:	writel(VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4 + REG_CLR);
drivers/video/mxsfb.c:	clk_disable_unprepare(host->clk);
drivers/video/mxsfb.c:	host->enabled = 0;
drivers/video/mxsfb.c:	if (host->enabled) {
drivers/video/mxsfb.c:	writel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);
drivers/video/mxsfb.c:		CTRL_SET_BUS_WIDTH(host->ld_intf_width);
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");
drivers/video/mxsfb.c:		writel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");
drivers/video/mxsfb.c:		switch (host->ld_intf_width) {
drivers/video/mxsfb.c:			dev_dbg(&host->pdev->dev,
drivers/video/mxsfb.c:		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Unhandled color depth of %u\n",
drivers/video/mxsfb.c:	writel(ctrl, host->base + LCDC_CTRL);
drivers/video/mxsfb.c:			host->base + host->devdata->transfer_count);
drivers/video/mxsfb.c:	writel(vdctrl0, host->base + LCDC_VDCTRL0);
drivers/video/mxsfb.c:		host->base + LCDC_VDCTRL1);
drivers/video/mxsfb.c:		host->base + LCDC_VDCTRL2);
drivers/video/mxsfb.c:		host->base + LCDC_VDCTRL3);
drivers/video/mxsfb.c:		vdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);
drivers/video/mxsfb.c:	writel(vdctrl4, host->base + LCDC_VDCTRL4);
drivers/video/mxsfb.c:			host->base + host->devdata->next_buf);
drivers/video/mxsfb.c:		if (host->enabled)
drivers/video/mxsfb.c:		if (!host->enabled)
drivers/video/mxsfb.c:			host->base + host->devdata->next_buf);
drivers/video/mxsfb.c:	struct fb_info *fb_info = &host->fb_info;
drivers/video/mxsfb.c:	ctrl = readl(host->base + LCDC_CTRL);
drivers/video/mxsfb.c:	vdctrl0 = readl(host->base + LCDC_VDCTRL0);
drivers/video/mxsfb.c:	vdctrl2 = readl(host->base + LCDC_VDCTRL2);
drivers/video/mxsfb.c:	vdctrl3 = readl(host->base + LCDC_VDCTRL3);
drivers/video/mxsfb.c:	vdctrl4 = readl(host->base + LCDC_VDCTRL4);
drivers/video/mxsfb.c:	transfer_count = readl(host->base + host->devdata->transfer_count);
drivers/video/mxsfb.c:	vmode.pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);
drivers/video/mxsfb.c:	period = readl(host->base + LCDC_VDCTRL1);
drivers/video/mxsfb.c:	host->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);
drivers/video/mxsfb.c:	host->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);
drivers/video/mxsfb.c:	pa = readl(host->base + host->devdata->cur_buf);
drivers/video/mxsfb.c:		writel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);
drivers/video/mxsfb.c:	clk_prepare_enable(host->clk);
drivers/video/mxsfb.c:	host->enabled = 1;
drivers/video/mxsfb.c:	struct fb_info *fb_info = &host->fb_info;
drivers/video/mxsfb.c:	struct mxsfb_platform_data *pdata = host->pdev->dev.platform_data;
drivers/video/mxsfb.c:	host->dotclk_delay = pdata->dotclk_delay;
drivers/video/mxsfb.c:	host->ld_intf_width = pdata->ld_intf_width;
drivers/video/mxsfb.c:		if (!request_mem_region(fb_phys, fb_size, host->pdev->name))
drivers/video/mxsfb.c:		host->mapped = 1;
drivers/video/mxsfb.c:	struct fb_info *fb_info = &host->fb_info;
drivers/video/mxsfb.c:	if (host->mapped) {
drivers/video/mxsfb.c:	host->base = ioremap(res->start, resource_size(res));
drivers/video/mxsfb.c:	if (!host->base) {
drivers/video/mxsfb.c:	host->pdev = pdev;
drivers/video/mxsfb.c:	host->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];
drivers/video/mxsfb.c:	host->clk = clk_get(&host->pdev->dev, NULL);
drivers/video/mxsfb.c:	if (IS_ERR(host->clk)) {
drivers/video/mxsfb.c:		ret = PTR_ERR(host->clk);
drivers/video/mxsfb.c:	if (!host->enabled) {
drivers/video/mxsfb.c:		writel(0, host->base + LCDC_CTRL);
drivers/video/mxsfb.c:	if (host->enabled)
drivers/video/mxsfb.c:		clk_disable_unprepare(host->clk);
drivers/video/mxsfb.c:	clk_put(host->clk);
drivers/video/mxsfb.c:	iounmap(host->base);
drivers/video/mxsfb.c:	if (host->enabled)
drivers/video/mxsfb.c:	iounmap(host->base);
drivers/video/mxsfb.c:	clk_put(host->clk);
firmware/keyspan_pda/keyspan_pda.S: *  The host-side driver is set to recognize the device ID values stashed in
firmware/keyspan_pda/xircom_pgs.S: *  The host-side driver is set to recognize the device ID values stashed in
fs/adfs/inode.c:		loff_t isize = mapping->host->i_size;
fs/affs/file.c:		loff_t isize = mapping->host->i_size;
fs/afs/file.c:	       key_serial(key), mapping->host->i_ino, nr_pages);
fs/bfs/file.c:		loff_t isize = mapping->host->i_size;
fs/btrfs/disk-io.c:	struct super_block *sb = page->mapping->host->i_sb;
fs/btrfs/extent_io.c:	return btrfs_sb(tree->mapping->host->i_sb);
fs/btrfs/extent_io.c:			"sector %llu)\n", page->mapping->host->i_ino, start,
fs/btrfs/extent_io.c:	size_t blocksize = page->mapping->host->i_sb->s_blocksize;
fs/btrfs/extent_io.c:	    page->mapping->host->i_size > 16 * 1024 * 1024) {
fs/cifs/cifs_unicode.c: * cifs_mapchar - convert a host-endian char to proper char in codepage
fs/cifs/cifs_unicode.c: * @src_char - 2 byte host-endian source character
fs/cifs/file.c:	if (offset > mapping->host->i_size) {
fs/cifs/file.c:	if (mapping->host->i_size - offset < (loff_t)to)
fs/cifs/file.c:		to = (unsigned)(mapping->host->i_size - offset);
fs/cifs/file.c:	struct cifs_sb_info *cifs_sb = CIFS_SB(mapping->host->i_sb);
fs/cifs/file.c:			if (page_offset(page) >= mapping->host->i_size) {
fs/cramfs/README:All data is currently in host-endian format; neither mkcramfs nor the
fs/cramfs/inode.c:	devsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;
fs/exofs/inode.c:		     mapping->host->i_ino, wbc->range_start, wbc->range_end,
fs/ext2/file.c:	struct super_block *sb = file->f_mapping->host->i_sb;
fs/ext4/inode.c:	struct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);
fs/hfs/inode.c:		loff_t isize = mapping->host->i_size;
fs/hfsplus/inode.c:		loff_t isize = mapping->host->i_size;
fs/hpfs/file.c:		loff_t isize = mapping->host->i_size;
fs/jfs/inode.c:		loff_t isize = mapping->host->i_size;
fs/jfs/jfs_metapage.c:		l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;
fs/jfs/jfs_metapage.c:	int l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;
fs/lockd/clntlock.c:	struct net *net = host->net;
fs/lockd/clntlock.c:	if (!host->h_reclaiming++) {
fs/lockd/clntlock.c:		task = kthread_run(reclaimer, host, "%s-reclaim", host->h_name);
fs/lockd/clntlock.c:				"(%ld)\n", host->h_name, PTR_ERR(task));
fs/lockd/clntlock.c:	struct net *net = host->net;
fs/lockd/clntlock.c:	down_write(&host->h_rwsem);
fs/lockd/clntlock.c:	dprintk("lockd: reclaiming locks for host %s\n", host->h_name);
fs/lockd/clntlock.c:	nsmstate = host->h_nsmstate;
fs/lockd/clntlock.c:	host->h_nextrebind = jiffies;
fs/lockd/clntlock.c:	list_splice_init(&host->h_granted, &host->h_reclaim);
fs/lockd/clntlock.c:	list_for_each_entry_safe(fl, next, &host->h_reclaim, fl_u.nfs_fl.list) {
fs/lockd/clntlock.c:		list_add_tail(&fl->fl_u.nfs_fl.list, &host->h_granted);
fs/lockd/clntlock.c:		if (host->h_nsmstate != nsmstate) {
fs/lockd/clntlock.c:	host->h_reclaiming = 0;
fs/lockd/clntlock.c:	up_write(&host->h_rwsem);
fs/lockd/clntlock.c:	dprintk("NLM: done reclaiming locks for host %s\n", host->h_name);
fs/lockd/clntproc.c:	if (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))
fs/lockd/clntproc.c:	spin_unlock(&lockowner->host->h_lock);
fs/lockd/clntproc.c:	list_for_each_entry(lockowner, &host->h_lockowners, list) {
fs/lockd/clntproc.c:		res = host->h_pidcount++;
fs/lockd/clntproc.c:	list_for_each_entry(lockowner, &host->h_lockowners, list) {
fs/lockd/clntproc.c:	spin_lock(&host->h_lock);
fs/lockd/clntproc.c:		spin_unlock(&host->h_lock);
fs/lockd/clntproc.c:		spin_lock(&host->h_lock);
fs/lockd/clntproc.c:			list_add(&new->list, &host->h_lockowners);
fs/lockd/clntproc.c:	spin_unlock(&host->h_lock);
fs/lockd/clntproc.c:			(int)proc, host->h_name);
fs/lockd/clntproc.c:		if (host->h_reclaiming && !argp->reclaim)
fs/lockd/clntproc.c:				wake_up_all(&host->h_gracewait);
fs/lockd/clntproc.c:		status = nlm_wait_on_grace(&host->h_gracewait);
fs/lockd/clntproc.c:			(int)proc, host->h_name);
fs/lockd/clntproc.c:	spin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);
fs/lockd/clntproc.c:	list_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);
fs/lockd/clntproc.c:	spin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);
fs/lockd/clntproc.c:	spin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);
fs/lockd/clntproc.c:	spin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);
fs/lockd/clntproc.c:		fl->fl_u.nfs_fl.state = host->h_state;
fs/lockd/clntproc.c:		down_read(&host->h_rwsem);
fs/lockd/clntproc.c:		if (fl->fl_u.nfs_fl.state != host->h_state) {
fs/lockd/clntproc.c:			up_read(&host->h_rwsem);
fs/lockd/clntproc.c:		up_read(&host->h_rwsem);
fs/lockd/clntproc.c:	down_read(&host->h_rwsem);
fs/lockd/clntproc.c:	up_read(&host->h_rwsem);
fs/lockd/clntproc.c:	down_read(&host->h_rwsem);
fs/lockd/clntproc.c:	up_read(&host->h_rwsem);
fs/lockd/host.c:	host->h_addrlen    = ni->salen;
fs/lockd/host.c:	host->h_srcaddrlen = 0;
fs/lockd/host.c:	host->h_rpcclnt    = NULL;
fs/lockd/host.c:	host->h_name	   = nsm->sm_name;
fs/lockd/host.c:	host->h_version    = ni->version;
fs/lockd/host.c:	host->h_proto      = ni->protocol;
fs/lockd/host.c:	host->h_reclaiming = 0;
fs/lockd/host.c:	host->h_server     = ni->server;
fs/lockd/host.c:	host->h_noresvport = ni->noresvport;
fs/lockd/host.c:	host->h_inuse      = 0;
fs/lockd/host.c:	init_waitqueue_head(&host->h_gracewait);
fs/lockd/host.c:	init_rwsem(&host->h_rwsem);
fs/lockd/host.c:	host->h_state      = 0;
fs/lockd/host.c:	host->h_nsmstate   = 0;
fs/lockd/host.c:	host->h_pidcount   = 0;
fs/lockd/host.c:	atomic_set(&host->h_count, 1);
fs/lockd/host.c:	mutex_init(&host->h_mutex);
fs/lockd/host.c:	host->h_nextrebind = now + NLM_HOST_REBIND;
fs/lockd/host.c:	host->h_expires    = now + NLM_HOST_EXPIRE;
fs/lockd/host.c:	INIT_LIST_HEAD(&host->h_lockowners);
fs/lockd/host.c:	spin_lock_init(&host->h_lock);
fs/lockd/host.c:	INIT_LIST_HEAD(&host->h_granted);
fs/lockd/host.c:	INIT_LIST_HEAD(&host->h_reclaim);
fs/lockd/host.c:	host->h_nsmhandle  = nsm;
fs/lockd/host.c:	host->h_addrbuf    = nsm->sm_addrbuf;
fs/lockd/host.c:	host->net	   = ni->net;
fs/lockd/host.c:	dprintk("lockd: destroy host %s\n", host->h_name);
fs/lockd/host.c:	BUG_ON(!list_empty(&host->h_lockowners));
fs/lockd/host.c:	BUG_ON(atomic_read(&host->h_count));
fs/lockd/host.c:	hlist_del_init(&host->h_hash);
fs/lockd/host.c:	nsm_release(host->h_nsmhandle);
fs/lockd/host.c:	clnt = host->h_rpcclnt;
fs/lockd/host.c:		if (host->net != net)
fs/lockd/host.c:			nsm = host->h_nsmhandle;
fs/lockd/host.c:		if (host->h_proto != protocol)
fs/lockd/host.c:		if (host->h_version != version)
fs/lockd/host.c:			host->h_name, host->h_addrbuf);
fs/lockd/host.c:	hlist_add_head(&host->h_hash, chain);
fs/lockd/host.c:		host->h_name, host->h_addrbuf);
fs/lockd/host.c:	dprintk("lockd: release client host %s\n", host->h_name);
fs/lockd/host.c:	BUG_ON(atomic_read(&host->h_count) < 0);
fs/lockd/host.c:	BUG_ON(host->h_server);
fs/lockd/host.c:	if (atomic_dec_and_test(&host->h_count)) {
fs/lockd/host.c:		BUG_ON(!list_empty(&host->h_lockowners));
fs/lockd/host.c:		BUG_ON(!list_empty(&host->h_granted));
fs/lockd/host.c:		BUG_ON(!list_empty(&host->h_reclaim));
fs/lockd/host.c:		if (host->net != net)
fs/lockd/host.c:			nsm = host->h_nsmhandle;
fs/lockd/host.c:		if (host->h_proto != ni.protocol)
fs/lockd/host.c:		if (host->h_version != ni.version)
fs/lockd/host.c:		hlist_del(&host->h_hash);
fs/lockd/host.c:		hlist_add_head(&host->h_hash, chain);
fs/lockd/host.c:			__func__, host->h_name, host->h_addrbuf);
fs/lockd/host.c:	host->h_srcaddrlen = src_len;
fs/lockd/host.c:	hlist_add_head(&host->h_hash, chain);
fs/lockd/host.c:		__func__, host->h_name, host->h_addrbuf);
fs/lockd/host.c:	dprintk("lockd: release server host %s\n", host->h_name);
fs/lockd/host.c:	BUG_ON(atomic_read(&host->h_count) < 0);
fs/lockd/host.c:	BUG_ON(!host->h_server);
fs/lockd/host.c:	atomic_dec(&host->h_count);
fs/lockd/host.c:			host->h_name, host->h_addrbuf);
fs/lockd/host.c:	mutex_lock(&host->h_mutex);
fs/lockd/host.c:	if ((clnt = host->h_rpcclnt) != NULL) {
fs/lockd/host.c:		if (time_after_eq(jiffies, host->h_nextrebind)) {
fs/lockd/host.c:			host->h_nextrebind = jiffies + NLM_HOST_REBIND;
fs/lockd/host.c:					host->h_nextrebind - jiffies);
fs/lockd/host.c:			.net		= host->net,
fs/lockd/host.c:			.protocol	= host->h_proto,
fs/lockd/host.c:			.addrsize	= host->h_addrlen,
fs/lockd/host.c:			.servername	= host->h_name,
fs/lockd/host.c:			.version	= host->h_version,
fs/lockd/host.c:		if (!host->h_server)
fs/lockd/host.c:		if (host->h_noresvport)
fs/lockd/host.c:		if (host->h_srcaddrlen)
fs/lockd/host.c:			host->h_rpcclnt = clnt;
fs/lockd/host.c:			printk("lockd: couldn't create RPC handle for %s\n", host->h_name);
fs/lockd/host.c:	mutex_unlock(&host->h_mutex);
fs/lockd/host.c:	dprintk("lockd: rebind host %s\n", host->h_name);
fs/lockd/host.c:	if (host->h_rpcclnt && time_after_eq(jiffies, host->h_nextrebind)) {
fs/lockd/host.c:		rpc_force_rebind(host->h_rpcclnt);
fs/lockd/host.c:		host->h_nextrebind = jiffies + NLM_HOST_REBIND;
fs/lockd/host.c:		dprintk("lockd: get host %s\n", host->h_name);
fs/lockd/host.c:		atomic_inc(&host->h_count);
fs/lockd/host.c:		host->h_expires = jiffies + NLM_HOST_EXPIRE;
fs/lockd/host.c:		if (host->h_nsmhandle == nsm
fs/lockd/host.c:		    && host->h_nsmstate != info->state) {
fs/lockd/host.c:			host->h_nsmstate = info->state;
fs/lockd/host.c:			host->h_state++;
fs/lockd/host.c:		if (net && host->net != net)
fs/lockd/host.c:		host->h_expires = jiffies - 1;
fs/lockd/host.c:		if (host->h_rpcclnt) {
fs/lockd/host.c:			rpc_shutdown_client(host->h_rpcclnt);
fs/lockd/host.c:			host->h_rpcclnt = NULL;
fs/lockd/host.c:				host->h_name, atomic_read(&host->h_count),
fs/lockd/host.c:				host->h_inuse, host->h_expires, host->net);
fs/lockd/host.c:		host->h_inuse = 0;
fs/lockd/host.c:		if (atomic_read(&host->h_count) || host->h_inuse
fs/lockd/host.c:		 || time_before(jiffies, host->h_expires)) {
fs/lockd/host.c:				host->h_name, atomic_read(&host->h_count),
fs/lockd/host.c:				host->h_inuse, host->h_expires);
fs/lockd/mon.c:	struct nsm_handle *nsm = host->h_nsmhandle;
fs/lockd/mon.c:	status = nsm_mon_unmon(nsm, NSMPROC_MON, &res, host->net);
fs/lockd/mon.c:	struct nsm_handle *nsm = host->h_nsmhandle;
fs/lockd/mon.c:		status = nsm_mon_unmon(nsm, NSMPROC_UNMON, &res, host->net);
fs/lockd/svc4proc.c:	if (host->h_nsmstate && host->h_nsmstate != argp->state) {
fs/lockd/svcproc.c:	if (host->h_nsmstate && host->h_nsmstate != argp->state) {
fs/lockd/svcsubs.c:	host->h_inuse = 1;
fs/lockd/svcsubs.c:	if (host->h_server) {
fs/lockd/svcsubs.c:		if (host->h_nsmhandle)
fs/lockd/svcsubs.c:			host->h_nsmhandle->sm_sticky = 1;
fs/lockd/svcsubs.c:			host->h_name);
fs/logfs/file.c:		struct super_block *sb = page->mapping->host->i_sb;
fs/logfs/file.c:	struct super_block *sb = file->f_mapping->host->i_sb;
fs/logfs/readwrite.c:		ino = page->mapping->host->i_ino;
fs/minix/inode.c:		loff_t isize = mapping->host->i_size;
fs/nfs/file.c:		mapping->host->i_ino, len, (long long) pos);
fs/nfs/file.c:		mapping->host->i_ino, len, (long long) pos);
fs/nfs/file.c:		filp->f_mapping->host->i_ino,
fs/nilfs2/inode.c:		loff_t isize = mapping->host->i_size;
fs/nilfs2/page.c:	ino = m ? m->host->i_ino : 0;
fs/ocfs2/aops.c:	journal_t *journal = OCFS2_SB(page->mapping->host->i_sb)->journal->j_journal;
fs/ocfs2/aops.c:	journal_t *journal = OCFS2_SB(page->mapping->host->i_sb)->journal->j_journal;
fs/ocfs2/aops.c:	struct ocfs2_super *osb = OCFS2_SB(mapping->host->i_sb);
fs/ocfs2/dlmglue.c:	return OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);
fs/ocfs2/dlmglue.c:	struct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);
fs/ocfs2/journal.c:	ocfs2_error(bh->b_assoc_map->host->i_sb,
fs/omfs/file.c:		loff_t isize = mapping->host->i_size;
fs/open.c:	file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);
fs/sysv/itree.c:		loff_t isize = mapping->host->i_size;
fs/ubifs/journal.c:		host->i_ino, inode->i_ino, nm->name,
fs/ubifs/journal.c:	xent_key_init(c, &xent_key, host->i_ino, nm);
fs/ubifs/journal.c:		ubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, host->i_ino);
fs/ubifs/journal.c:	ino_key_init(c, &key1, host->i_ino);
fs/ubifs/journal.c:	dbg_jnl("ino %lu, ino %lu", host->i_ino, inode->i_ino);
fs/ubifs/journal.c:	ubifs_assert(host->i_nlink > 0);
fs/ubifs/journal.c:		ubifs_wbuf_add_ino_nolock(wbuf, host->i_ino);
fs/ubifs/journal.c:	ino_key_init(c, &key, host->i_ino);
fs/ubifs/xattr.c:	host->i_ctime = ubifs_current_time(host);
fs/ubifs/xattr.c:	host->i_ctime = ubifs_current_time(host);
fs/ubifs/xattr.c:	struct ubifs_info *c = host->i_sb->s_fs_info;
fs/ubifs/xattr.c:		host->i_ino, dentry->d_name.len, dentry->d_name.name, size);
fs/ubifs/xattr.c:	ubifs_assert(mutex_is_locked(&host->i_mutex));
fs/ubifs/xattr.c:	xent_key_init(c, &key, host->i_ino, &nm);
fs/ubifs/xattr.c:	struct ubifs_info *c = host->i_sb->s_fs_info;
fs/ubifs/xattr.c:		host->i_ino, dentry->d_name.len, dentry->d_name.name, size);
fs/ubifs/xattr.c:	xent_key_init(c, &key, host->i_ino, &nm);
fs/ubifs/xattr.c:	struct ubifs_info *c = host->i_sb->s_fs_info;
fs/ubifs/xattr.c:	dbg_gen("ino %lu ('%.*s'), buffer size %zd", host->i_ino,
fs/ubifs/xattr.c:	lowest_xent_key(c, &key, host->i_ino);
fs/ubifs/xattr.c:	host->i_ctime = ubifs_current_time(host);
fs/ubifs/xattr.c:	struct ubifs_info *c = host->i_sb->s_fs_info;
fs/ubifs/xattr.c:		host->i_ino, dentry->d_name.len, dentry->d_name.name);
fs/ubifs/xattr.c:	ubifs_assert(mutex_is_locked(&host->i_mutex));
fs/ubifs/xattr.c:	xent_key_init(c, &key, host->i_ino, &nm);
fs/ufs/inode.c:		loff_t isize = mapping->host->i_size;
fs/ufs/util.c:			       mapping->host->i_ino, index);
fs/ufs/util.c:			       mapping->host->i_ino, index);
include/acpi/actypes.h: * any type of integer. It is up to the host-dependent OSL to cast the
include/linux/cleancache.h:	return page->mapping->host->i_sb->cleancache_poolid >= 0;
include/linux/cleancache.h:	return mapping->host->i_sb->cleancache_poolid >= 0;
include/linux/firewire-cdev.h: * @channels is a host-endian bitfield with the least significant bit
include/linux/libata.h:	/* bits 24:31 of host->flags are reserved for LLD specific flags */
include/linux/libata.h:	return *(struct ata_port **)&host->hostdata[0];
include/linux/lockd/lockd.h:	return (struct sockaddr_in *)&host->h_addr;
include/linux/lockd/lockd.h:	return (struct sockaddr *)&host->h_addr;
include/linux/lockd/lockd.h:	return (struct sockaddr_in *)&host->h_srcaddr;
include/linux/lockd/lockd.h:	return (struct sockaddr *)&host->h_srcaddr;
include/linux/memstick.h:	return (void *)host->private;
include/linux/mmc/host.h:	return (void *)host->private;
include/linux/mmc/host.h:		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
include/linux/mmc/host.h:		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
include/linux/mmc/host.h:       host->bus_resume_flags = 0;
include/linux/mmc/host.h:	host->ops->enable_sdio_irq(host, 0);
include/linux/mmc/host.h:	host->sdio_irq_pending = true;
include/linux/mmc/host.h:	wake_up_process(host->sdio_irq_thread);
include/linux/mmc/host.h:	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
include/linux/mmc/host.h:	return host->pm_flags & MMC_PM_KEEP_POWER;
include/linux/mmc/host.h:	return host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;
include/linux/mmc/host.h:	return host->caps & MMC_CAP_CMD23;
include/linux/mmc/host.h:	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
include/linux/mmc/host.h:	return host->ios.clock;
include/linux/nfsd/nfsfh.h: * All four-byte values are in host-byte-order.
include/linux/raid/md_u.h: *     little-ending representation rather than host-endian
include/linux/ssb/ssb.h:	 * Not valid on all host-buses. So don't use outside of SSB. */
include/linux/ssb/ssb.h:	/* The host-bus this backplane is running on. */
include/linux/ssb/ssb.h:	/* Pointers to the host-bus. Check bustype before using any of these pointers. */
include/linux/ti_wilink_st.h: *	the change baud rate of host-side UART, which
include/linux/vhost.h:/* vhost-net should add virtio_net_hdr for RX, and strip for TX packets. */
include/linux/wimax/i2400m.h:/* Packet types for the host-device interface */
include/scsi/fc_encode.h:			dev_name(&lport->host->shost_gendev),
include/scsi/fc_encode.h:			strnlen(dev_name(&lport->host->shost_gendev),
include/scsi/libsrp.h:	return (struct srp_target *) host->hostdata;
include/scsi/scsi_host.h:		spin_lock_irqsave(shost->host_lock, irq_flags);		\
include/scsi/scsi_host.h:		spin_unlock_irqrestore(shost->host_lock, irq_flags);	\
include/scsi/scsi_host.h:	return (void *)shost->hostdata;
include/scsi/scsi_host.h:	return shost->shost_state == SHOST_RECOVERY ||
include/scsi/scsi_host.h:		shost->shost_state == SHOST_CANCEL_RECOVERY ||
include/scsi/scsi_host.h:		shost->shost_state == SHOST_DEL_RECOVERY ||
include/scsi/scsi_host.h:		shost->tmf_in_progress;
include/scsi/scsi_host.h:        return shost->shost_gendev.parent;
include/scsi/scsi_host.h:	return shost->shost_state == SHOST_RUNNING ||
include/scsi/scsi_host.h:	       shost->shost_state == SHOST_RECOVERY;
include/scsi/scsi_host.h:	shost->prot_capabilities = mask;
include/scsi/scsi_host.h:	return shost->prot_capabilities;
include/scsi/scsi_host.h:	return shost->prot_capabilities >= SHOST_DIX_TYPE0_PROTECTION;
include/scsi/scsi_host.h:	return shost->prot_capabilities & cap[target_type] ? target_type : 0;
include/scsi/scsi_host.h:	return shost->prot_capabilities & cap[target_type];
include/scsi/scsi_host.h:	shost->prot_guard_type = type;
include/scsi/scsi_host.h:	return shost->prot_guard_type;
include/scsi/scsi_tcq.h:				    sdev->host->bqt);
include/scsi/scsi_tcq.h:	if (!shost->bqt) {
include/scsi/scsi_tcq.h:		shost->bqt = blk_init_tags(depth);
include/scsi/scsi_tcq.h:		if (!shost->bqt)
include/scsi/scsi_tcq.h:		req = blk_map_queue_find_tag(shost->bqt, tag);
include/scsi/scsi_transport.h:		+ shost->transportt->target_private_offset;
include/scsi/scsi_transport.h:		+ shost->transportt->device_private_offset;
include/scsi/scsi_transport_fc.h:	/* allocation lengths for host-specific data */
include/trace/events/btrfs.h:		__entry->ino	= page->mapping->host->i_ino;
include/trace/events/ext3.h:		__entry->ino	= page->mapping->host->i_ino;
include/trace/events/ext3.h:		__entry->dev	= page->mapping->host->i_sb->s_dev;
include/trace/events/ext3.h:		__entry->ino	= page->mapping->host->i_ino;
include/trace/events/ext3.h:		__entry->dev	= page->mapping->host->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= page->mapping->host->i_ino;
include/trace/events/ext4.h:		__entry->dev	= page->mapping->host->i_sb->s_dev;
include/trace/events/ext4.h:		__entry->ino	= page->mapping->host->i_ino;
include/trace/events/ext4.h:		__entry->dev	= page->mapping->host->i_sb->s_dev;
include/trace/events/scsi.h:		__entry->host_no	= cmd->device->host->host_no;
include/trace/events/scsi.h:		__entry->host_no	= cmd->device->host->host_no;
include/trace/events/scsi.h:		__entry->host_no	= cmd->device->host->host_no;
include/trace/events/scsi.h:		__entry->host_no	= shost->host_no;
mm/cleancache.c:	pool_id = page->mapping->host->i_sb->cleancache_poolid;
mm/cleancache.c:	pool_id = page->mapping->host->i_sb->cleancache_poolid;
mm/cleancache.c:	int pool_id = mapping->host->i_sb->cleancache_poolid;
mm/cleancache.c:	int pool_id = mapping->host->i_sb->cleancache_poolid;
mm/filemap_xip.c:	    (!(mapping->host->i_sb->s_flags & MS_RDONLY))) {
mm/filemap_xip.c:	blocksize = 1 << mapping->host->i_blkbits;
mm/memory-failure.c:	dev = mapping->host->i_sb->s_dev;
mm/truncate.c:	if (!S_ISREG(mapping->host->i_mode))
net/dccp/feat.c: * dccp_feat_init  -  Seed feature negotiation with host-specific defaults
net/mac80211/ieee80211_i.h:	/* Fragment table for host-based reassembly */
net/rxrpc/ar-internal.h:	u32			real_conn_id;	/* connection ID (host-endian) */
net/wireless/lib80211_crypt_ccmp.c: * lib80211 crypt: host-based CCMP encryption implementation for lib80211
net/wireless/lib80211_crypt_tkip.c: * lib80211 crypt: host-based TKIP encryption implementation for lib80211
net/wireless/lib80211_crypt_wep.c: * lib80211 crypt: host-based WEP encryption implementation for lib80211
scripts/Makefile.build:ifdef host-progs
scripts/Makefile.build:ifneq ($(hostprogs-y),$(host-progs))
scripts/Makefile.build:$(warning kbuild: $(obj)/Makefile - Usage of host-progs is deprecated. Please replace with hostprogs-y!)
scripts/Makefile.build:hostprogs-y += $(host-progs)
scripts/Makefile.clean:		   $(host-progs)                         \
scripts/Makefile.host:host-csingle	:= $(foreach m,$(__hostprogs),$(if $($(m)-objs),,$(m)))
scripts/Makefile.host:host-cmulti	:= $(foreach m,$(__hostprogs),\
scripts/Makefile.host:host-cobjs	:= $(sort $(foreach m,$(__hostprogs),$($(m)-objs)))
scripts/Makefile.host:host-cxxmulti	:= $(foreach m,$(__hostprogs),$(if $($(m)-cxxobjs),$(m)))
scripts/Makefile.host:host-cxxobjs	:= $(sort $(foreach m,$(host-cxxmulti),$($(m)-cxxobjs)))
scripts/Makefile.host:host-cshlib	:= $(sort $(filter %.so, $(host-cobjs)))
scripts/Makefile.host:host-cobjs	:= $(filter-out %.so,$(host-cobjs))
scripts/Makefile.host:host-cshobjs	:= $(sort $(foreach m,$(host-cshlib),$($(m:.so=-objs))))
scripts/Makefile.host:host-objdirs := $(foreach f,$(__hostprogs), $(if $(dir $(f)),$(dir $(f))))
scripts/Makefile.host:host-objdirs += $(foreach f,$(host-cmulti),                  \
scripts/Makefile.host:host-objdirs += $(foreach f,$(host-cxxmulti),                  \
scripts/Makefile.host:host-objdirs := $(strip $(sort $(filter-out ./,$(host-objdirs))))
scripts/Makefile.host:host-csingle	:= $(addprefix $(obj)/,$(host-csingle))
scripts/Makefile.host:host-cmulti	:= $(addprefix $(obj)/,$(host-cmulti))
scripts/Makefile.host:host-cobjs	:= $(addprefix $(obj)/,$(host-cobjs))
scripts/Makefile.host:host-cxxmulti	:= $(addprefix $(obj)/,$(host-cxxmulti))
scripts/Makefile.host:host-cxxobjs	:= $(addprefix $(obj)/,$(host-cxxobjs))
scripts/Makefile.host:host-cshlib	:= $(addprefix $(obj)/,$(host-cshlib))
scripts/Makefile.host:host-cshobjs	:= $(addprefix $(obj)/,$(host-cshobjs))
scripts/Makefile.host:host-objdirs    := $(addprefix $(obj)/,$(host-objdirs))
scripts/Makefile.host:obj-dirs += $(host-objdirs)
scripts/Makefile.host:# host-csingle -> Executable
scripts/Makefile.host:quiet_cmd_host-csingle 	= HOSTCC  $@
scripts/Makefile.host:      cmd_host-csingle	= $(HOSTCC) $(hostc_flags) -o $@ $< \
scripts/Makefile.host:$(host-csingle): $(obj)/%: $(src)/%.c FORCE
scripts/Makefile.host:	$(call if_changed_dep,host-csingle)
scripts/Makefile.host:# host-cmulti -> executable
scripts/Makefile.host:quiet_cmd_host-cmulti	= HOSTLD  $@
scripts/Makefile.host:      cmd_host-cmulti	= $(HOSTCC) $(HOSTLDFLAGS) -o $@ \
scripts/Makefile.host:$(host-cmulti): $(obj)/%: $(host-cobjs) $(host-cshlib) FORCE
scripts/Makefile.host:	$(call if_changed,host-cmulti)
scripts/Makefile.host:# host-cobjs -> .o
scripts/Makefile.host:quiet_cmd_host-cobjs	= HOSTCC  $@
scripts/Makefile.host:      cmd_host-cobjs	= $(HOSTCC) $(hostc_flags) -c -o $@ $<
scripts/Makefile.host:$(host-cobjs): $(obj)/%.o: $(src)/%.c FORCE
scripts/Makefile.host:	$(call if_changed_dep,host-cobjs)
scripts/Makefile.host:# host-cxxmulti -> executable
scripts/Makefile.host:quiet_cmd_host-cxxmulti	= HOSTLD  $@
scripts/Makefile.host:      cmd_host-cxxmulti	= $(HOSTCXX) $(HOSTLDFLAGS) -o $@ \
scripts/Makefile.host:$(host-cxxmulti): $(obj)/%: $(host-cobjs) $(host-cxxobjs) $(host-cshlib) FORCE
scripts/Makefile.host:	$(call if_changed,host-cxxmulti)
scripts/Makefile.host:quiet_cmd_host-cxxobjs	= HOSTCXX $@
scripts/Makefile.host:      cmd_host-cxxobjs	= $(HOSTCXX) $(hostcxx_flags) -c -o $@ $<
scripts/Makefile.host:$(host-cxxobjs): $(obj)/%.o: $(src)/%.cc FORCE
scripts/Makefile.host:	$(call if_changed_dep,host-cxxobjs)
scripts/Makefile.host:# host-cshobjs -> .o
scripts/Makefile.host:quiet_cmd_host-cshobjs	= HOSTCC  -fPIC $@
scripts/Makefile.host:      cmd_host-cshobjs	= $(HOSTCC) $(hostc_flags) -fPIC -c -o $@ $<
scripts/Makefile.host:$(host-cshobjs): $(obj)/%.o: $(src)/%.c FORCE
scripts/Makefile.host:	$(call if_changed_dep,host-cshobjs)
scripts/Makefile.host:# *.o -> .so shared library (host-cshlib)
scripts/Makefile.host:quiet_cmd_host-cshlib	= HOSTLLD -shared $@
scripts/Makefile.host:      cmd_host-cshlib	= $(HOSTCC) $(HOSTLDFLAGS) -shared -o $@ \
scripts/Makefile.host:$(host-cshlib): $(obj)/%: $(host-cshobjs) FORCE
scripts/Makefile.host:	$(call if_changed,host-cshlib)
scripts/Makefile.host:targets += $(host-csingle)  $(host-cmulti) $(host-cobjs)\
scripts/Makefile.host:	   $(host-cxxmulti) $(host-cxxobjs) $(host-cshlib) $(host-cshobjs) 
sound/isa/sscape.c: * Read the SoundScape's host-mode control register, but leave
sound/isa/sscape.c: * Read the SoundScape's host-mode control register, performing
sound/isa/sscape.c: * Write to the SoundScape's host-mode control registers, but
sound/isa/sscape.c: * Write to the SoundScape's host-mode control registers, performing
sound/pci/korg1212/korg1212.c:// host-to-card doorbell to initiate a command.
sound/pci/korg1212/korg1212.c:        u32 __iomem * outDoorbellPtr;	     // address of the host->card doorbell register
tools/virtio/virtio_test.c:        dev->control = open("/dev/vhost-test", O_RDWR);
virt/kvm/eventfd.c: * create a host-wide workqueue for issuing deferred shutdown requests
